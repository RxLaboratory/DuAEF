/**
 * After Effects composition methods
 * @namespace
 */
var DuAEComp = {};

/**
 * Converts the number of frames to the time in seconds
 * @param {int} frames The frames
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The comp
 * @returns {float} The time, in seconds
 */
DuAEComp.framesToTime = function( frames, comp )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return 0;

    return frames * comp.frameDuration;
}

/**
 * Converts the time in seconds to the number of frames
 * @param {float} [time=comp.time] The time in seconds
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The comp
 * @returns {int} The number of frames, rounded
 */
DuAEComp.timeToFrames = function( time, comp )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return 0;
    time = def(time, comp.time);

    return Math.round( time / comp.frameDuration );
}

/**
 * Replaces text in Expressions
 * @param {string} oldString - The string to replace
 * @param {string} newString - The new string
 * @param {boolean} [caseSensitive=true] - Whether the search has to be case sensitive
 * @param {boolean} [selectedLayers=false] Set to true to cache only selected layers.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp with expressions to cache.
 */
DuAEComp.replaceInExpressions = function ( oldString, newString, caseSensitive, selectedLayers ) {
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;
    caseSensitive = def (caseSensitive, true);
    selectedLayers = def (selectedLayers, false);

    var re = new RegExp( DuRegExp.escape(oldString), caseSensitive ? 'g' : 'gi');

    DuAEExpression.doInExpresssions(function(e) {
        e.changed = re.test( e.expression );
        if (e.changed) e.expression = e.expression.replace( re, newString );
        return e;
    }, true, false, selectedLayers);
}

/**
 * Replace all <code>thisComp</code> occurences by <code>comp("name")</code>.
 * @param {bool} [selectedLayers=false] true to replace only in selected layers
 */
DuAEComp.removeThisCompInExpressions = function( selectedLayers )
{
    selectedLayers = def(selectedLayers, false);
    
    var re = new RegExp("(^|" + DuRegExp.javascriptSymbols + ")thisComp(?!" + DuRegExp.javascriptVarChars + ")",'gm')

    DuAEExpression.doInExpresssions(function(e) {
        e.changed = re.test( e.expression );
        if (e.changed) e.expression = e.expression.replace( re, '$1comp("' + e.comp.name + '")' );
    }, true, false, selectedLayers);
}

/**
 * Replace all <code>comp("name")</code> occurences by <code>thisComp</code>.
 * @param {bool} [selectedComps=false] true to replace only in selected compositions
 */
DuAEComp.removeCompInExpressions = function( selectedLayers )
{
    selectedLayers = def(selectedLayers, false);
    
    DuAEExpression.doInExpresssions(function(e) {
        var name = e.comp.name;
        var re = new RegExp("(^|" + DuRegExp.javascriptSymbols + ")comp\\s*\\(\\s*[\"']" + DuRegExp.escape(name) + "[\"']\\s*\\)", 'gm');
        e.changed = re.test( e.expression );
        if (e.changed) e.expression = e.expression.replace( re, '$1thisComp' );
    }, true, false, selectedLayers);
}

/**
 * Makes sure the composition has a unique name, renaming it if needed.
 * @param {CompItem} comp - The composition
 * @return {string} The new name.
 */
DuAEComp.setUniqueCompName = function ( comp ) {
    if ( !( comp instanceof CompItem ) ) throw "Cannot set a unique composition name, this is not a composition.";
    //temporarily rename the comp to check for its name
    var newName = comp.name;
    comp.name = '***DuAEF-temp-name-xxx***';
    comp.name = DuAEProject.newUniqueCompName( newName, false );
    app.project.autoFixExpressions( newName, comp.name );
    return comp.name;
}

/**
 * Makes sure all layers in the comp have unique names, renaming them if needed.
 * @param {Array|LayerCollection} [layers=comp.layers] - The layers
 * @param {CompItem} [comp=DuAEProject.getActiveComp] - The composition
 */
DuAEComp.setUniqueLayerNames = function ( layers, comp ) {
    comp = def( comp, DuAEProject.getActiveComp() );
    if (!comp) return;
    layers = def(layers, comp.layers);
    var it = new DuList( layers );
    it.do( function ( layer ) {
        var locked = layer.locked;
        layer.locked = false;
        //temporarily set another name to correctly generate a new unique name 
        var oldName = layer.name;
        layer.name = '***Duik-temp-name-xxx***';
        layer.name = DuAEComp.newUniqueLayerName( oldName, comp );
        app.project.autoFixExpressions(oldName, layer.name);
        layer.locked = locked;
    } );
}

/**
 * Gets the After Effects selected properties in the current comp
 * @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
 * A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
 * @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
 * @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
 * @return {DuAEProperty[]} The selected properties, an empty Array if nothing active or selected
 */
DuAEComp.getSelectedProps = function ( filter, strict, caseSensitive ) {
    var props = [];
    var comp = DuAEProject.getActiveComp();
    if ( !comp ) return props;

    //if no filter, get all using AE native API
    if ( typeof filter === 'undefined' ) {
        var layers = comp.selectedLayers;
        var itLayers = new DuList( layers );
        itLayers.do( function ( layer ) {
            props = props.concat( layer.selectedProperties );
        } );
    } else {
        var layers = comp.selectedLayers;
        if ( layers.length === 0 ) return props;

        for ( var i = 0, numL = layers.length; i < numL; i++ ) {
            props = props.concat( DuAELayer.getSelectedProps( layers[ i ], filter, strict, caseSensitive ) );
        }
    }

    return DuAE.getDuAEProperty( props );
}

/**
 * Gets the selected layers in the current comp
 * @return {Layer[]} The selected layers
 */
DuAEComp.getSelectedLayers = function () {
    var comp = DuAEProject.getActiveComp();
    if ( !comp ) return [];
    return comp.selectedLayers;
}

/**
 * Gets the first selected layer in the After Effects current composition
 * @return {Layer|null} The layer or null if there's no current comp / no selected layer
 */
DuAEComp.getActiveLayer = function() {
    var layers = DuAEComp.getSelectedLayers();
    return layers[0];
}

/**
 * Runs a function on all the selected layers
 * @param {function} method - The function to run on the layers, which takes a layer as its only argument.
 * @param {string} [undoGroupName] - The name of the undoGroup created before the execution. If not provided, there will not be any undoGroup created.
 */
DuAEComp.doSelectedLayers = function ( method, undoGroupName ) {
    //get layers
    var layers = DuAEComp.unselectLayers();

    // run
    DuAELayer.doLayers( layers, method, undoGroupName );

    //reselect
    DuAEComp.selectLayers( layers );
}

/**
 * Runs a function on all the layers
 * @param {function} method - The function to run on the layers, which takes a layer as its only argument.
 * @param {string} [undoGroupName] - The name of the undoGroup created before the execution. If not provided, there will not be any undoGroup created.
 * @param {CompItem} [comp] - The comp containing the layers. Will use the current comp if not provided.
 */
DuAEComp.doLayers = function ( method, undoGroupName, comp ) {
    comp = def( comp, DuAEProject.getActiveComp() );
    if ( !( comp instanceof CompItem ) ) return;

    //get layers
    var layers = comp.layers;
    if ( layers.length == 0 ) return;

    // run
    DuAELayer.doLayers( layers, method, undoGroupName );
}

/**
 * Gets the After Effects animated (with keyframes) properties in the current comp
 * @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
 * A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
 * @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
 * @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
 * @param {boolean}	[selectedLayersOnly=false]	- True to get the properties on the selected layers only
 * @param {CompItem}	[comp=DuAEProject.getActiveComp]	- The composition
 * @return {DuAEProperty[]} The selected properties, an empty Array if nothing active or selected
 */
DuAEComp.getAnimatedProps = function ( filter, strict, caseSensitive, selectedLayersOnly, comp ) {
    var props = [];
    if ( typeof comp === 'undefined' ) comp = DuAEProject.getActiveComp();
    if ( !comp ) return props;

    selectedLayersOnly = def( selectedLayersOnly, false);


    var layers;
    if ( selectedLayersOnly ) layers = comp.selectedLayers;
    else layers = comp.layers;

    var it = new DuList( layers );
    it.do( function ( layer ) {
        props = props.concat( DuAEProperty.getAnimatedProps( layer, filter, strict, caseSensitive ) );
    } );

    return props;
}

/**
 * Deselects all properties in the current composition
 */
DuAEComp.unselectProperties = function () {
    var comp = DuAEProject.getActiveComp();
    if ( !comp ) return props;
    var props = comp.selectedProperties;
    for ( var i = 0; i < props.length; i++ ) {
        props[ i ].selected = false;
    }
}

/**
 * Deselects all layers in a composition
 * @param {CompItem} [comp=app.project.activeItem] - The composition
 * @return {Layer[]} The previously selected layers.<br />
 * A custom attribute, Layer.props is added on each layer object which is an array of all previously selected properties as DuAEProperty objects
 */
DuAEComp.unselectLayers = function ( comp ) {
    if ( typeof comp === 'undefined' ) comp = DuAEProject.getActiveComp();
    if ( !comp ) return [];

    var layers = [];

    if ( !comp ) return layers;
    if ( !( comp instanceof CompItem ) ) return layers;

    layers = [];

    while ( comp.selectedLayers.length > 0 ) {
        var layer = comp.selectedLayers[ 0 ];
        layer.props = DuAE.getDuAEProperty( layer.selectedProperties );
        layer.selected = false;
        layers.push( layer );
    }

    return layers;
}

/**
 * Selects the layers
 * @param {Layer[]|DuList.<Layer>} layers - The layers
 */
DuAEComp.selectLayers = function ( layers ) {
    new DuList( layers ).do( function ( layer ) {
        if ( layer == undefined ) return;
        if ( layer == null ) return;
        layer.selected = true;
    } );
}

/**
 * Generates a new unique name for a layer
 * @param {string} newName	- The wanted new name
 * @param {CompItem} [comp] 	- The comp
 * @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
 * @return {string}	The unique name, with a new number at the end if needed.
 */
DuAEComp.newUniqueLayerName = function ( newName, comp, increment ) {
    // Ignore the last block
    var nName = newName.split(' | ');
    var lastBlock = '';
    if (nName.length == 4)
    {
        lastBlock = nName.pop();
        newName = nName.join(' | ');
    }

    increment = def(increment, true);
    comp = def(comp, DuAEProject.getActiveComp() );
    var layerNames = [];
    for ( var i = 1; i <= comp.layers.length; i++ )
    {
        // Ignore the last block
        var n = comp.layer( i ).name;
        var tName = n.split(' | ');
        if (tName.length == 4)
        {
            tName.pop();
            n = tName.join(' | ');
        }
        layerNames.push( n );
    }
    newName = DuString.generateUnique( newName, layerNames, increment );
    if (lastBlock != '') newName += ' | ' + lastBlock;
    return newName;
}

/**
 * Generates a new unique name for a marker for this comp
 * @param {string} newName	- The wanted new name
 * @param {CompItem} comp 	- The comp
 * @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
 * @return {string}	The unique name, with a new number at the end if needed.
 */
DuAEComp.newUniqueMarkerName = function ( newName, comp, increment ) {
    if ( increment == undefined ) increment = true;
    var markerNames = [];
    for ( var i = 1, num = comp.markerProperty.numKeys; i <= num; i++ ) {
        markerNames.push( comp.markerProperty.keyValue( i ).comment );
    }
    return DuString.generateUnique( newName, markerNames, increment );
}

/**
 * Creates a new Adjustment layer
 * @param {CompItem} comp 	- The comp
 * @return {AVLayer}	The layer.
 */
DuAEComp.addAdjustmentLayer = function ( comp ) {
    if ( comp == undefined ) return null;
    var layer = comp.layers.addSolid( [ 1, 1, 1 ], DuAEComp.newUniqueLayerName( "Adjustment Layer", comp ), comp.width, comp.height, comp.pixelAspect, comp.duration );
    layer.adjustmentLayer = true;
    return layer;
}

/**
 * Links all orphan layers in the comp to a layer
 * @param {Layer} layer - The parent layer
 * @param {bool} [includeLockedLayers=false] - True to parent layers even if they are locked
 */
DuAEComp.parentAllOrphans = function ( layer, includeLockedLayers ) {
    includeLockedLayers = def( includeLockedLayers, false );
    var comp = layer.containingComp;
    for ( var i = 1, num = comp.numLayers; i <= num; i++ ) {
        if ( i == layer.index ) continue;
        var l = comp.layer( i );
        if ( DuAELayer.getRelation( l, layer ) < 0 ) continue;
        var locked = l.locked;
        if ( locked && includeLockedLayers ) l.locked = false;
        if ( !locked && l.parent == null ) l.parent = layer;
        if ( locked && includeLockedLayers ) l.locked = locked;
    }
}

/**
 * Gets all precomps and parent comps of the composition
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] - The composition
 * @param {bool} [recursive=false] - True to search to more than one level of precomposition
 * @return {CompItem[]} The related compositons
 */
DuAEComp.getRelatives = function ( comp, recursive ) {
    recursive = def( recursive, false );
    comp = def( comp, DuAEProject.getActiveComp() );
    if ( !comp ) return [];
    //get precomps
    var precomps = DuAEComp.getPrecomps( comp, recursive );
    //get parent
    var parentComps = [];
    if ( recursive ) {
        parentComps = DuAEComp.getParentComps( comp );
    } else {
        parentComps = comp.usedIn;
    }

    return precomps.concat( parentComps );
}

/**
 * Gets all the precomposition found in the comp.
 * @param {CompItem} comp - The composition
 * @param {bool} [recursive=false] - True to get nested compositions
 * @return {CompItem[]} The precompositions
 */
DuAEComp.getPrecomps = function ( comp, recursive ) {
    recursive = def( recursive, true );
    var precomps = [];
    var it = new DuList( comp.layers );
    it.do( function ( layer ) {
        var precomp = layer.source;
        if ( precomp instanceof CompItem ) {
            precomps.push( precomp );
            if ( recursive ) precomps = precomps.concat( DuAEComp.getPrecomps( precomp ) );
        }
    } );
    //remove duplicates
    DuList.removeDuplicates( precomps );
    return precomps;
}

/**
 * Recursively gets all compositions where this item is used
 * @param {AVItem} item - The item
 * @return {CompItem[]} The compositions
 */
DuAEComp.getParentComps = function ( item ) {
    var parentComps = item.usedIn;
    new DuList( parentComps ).do( function ( parentComp ) {
        parentComps = parentComps.concat( DuAEComp.getParentComps( parentComp ) );
    } );
    DuList.removeDuplicates( parentComps );
    return parentComps;
}

/**
 * Gets all the layers with audio in the composition
 * @param {CompItem}	 comp	The composition where the audio will be searched
 * @param {bool}	[audioActiveOnly=false]	 If true, does not get muted layers.
 * @return {AVLayer[]} An array of AVLayer containing the audio layers
 */
DuAEComp.getAudioLayers = function ( comp, audioActiveOnly ) {
    audioActiveOnly = def(audioActiveOnly, false);
    var layers = comp.layers;
    var audioLayers = [];
    var it = new DuList( layers );
    it.do( function ( layer ) {
        if ( layer.hasAudio ) {
            if ( audioActiveOnly && layer.audioEnabled || !audioActiveOnly ) {
                audioLayers.push( layer );
            }
        }
    } );

    return audioLayers;
}

/**
 * Gets the total number of master properties used on precompositions in the comp.
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The composition to check
 * @return {int} The number of master properties
 */
DuAEComp.numMasterProperties = function(comp) {
    if (DuAE.version.version < 15.1) return 0;
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return 0;
    var numMP = 0;
    for (var i = 1, n = comp.numLayers; i <= n; i++)
    {
        var l = comp.layer(i);
        if (!l.source) continue;
        if (l.source instanceof CompItem)
        {
            numMP += l('ADBE Layer Overrides').numProperties;
        }
    }
    return numMP;
}

/**
 * Checks if all layers have a different name.
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The comp to check
 * @return {Object} The list of names used several times. Check the length attribute to know how many duplicates were found, loop through the keys to get the names. Eech key is an array containing the list of layers with that name.
 * @example
 * var dupes = DuAEComp.checkLayerNames();
 * if (dupes.length != 0) {
 * for (name in dupes)
 * {
 *     if (dupes.hasOwnProperty(name)) alert(dupes[name]); //dupes[name] is an array of Layer
 * }
 * }
 */
DuAEComp.checkLayerNames = function (comp) {
    comp = def(comp, DuAEProject.getActiveComp());
    var duplicatedNames = {};
    duplicatedNames.length  = 0;
    if (!comp) return duplicatedNames;
    var layerNames = {};
    var layers = app.project.items;
    for (var i = 1, n = comp.numLayers; i <= n; i++)
    {
        var layer = comp.layer(i);
        var name = layer.name;

        if (duplicatedNames.hasOwnProperty(name))
        {
            duplicatedNames[name].push(layer);
            continue;
        }
        
        if ( layerNames.hasOwnProperty(name) ) 
        {
            duplicatedNames[name] = [layerNames[name], layer];
            duplicatedNames.length++;
            continue;
        }
        layerNames[name] = layer;
    }
    return duplicatedNames;
}

/**
 * Creates a new "Shape Null" in the comp.
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The comp where to create the layer
 * @param {float} [size=100] The size of the null
 * @param {Layer} [layer] A layer for the location of the null
 * @returns {ShapeLayer} The null layer
 */
DuAEComp.addNull = function (comp, size, layer)
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;
    size = def(size, 100);
    layer = def(layer, null);

    var nullLayer = comp.layers.addShape();
    nullLayer.guideLayer = true;
    nullLayer.name = DuScriptUI.String.NULL_LAYER;
    nullLayer.label = 1;

    var anchorGroup = nullLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    anchorGroup.name = 'Anchor';
    var anchorContent = anchorGroup.property("ADBE Vectors Group");
    var centerCircle = anchorContent.addProperty("ADBE Vector Shape - Ellipse");
    centerCircle("ADBE Vector Ellipse Size").setValue([4,4]);
    var fill = anchorContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").setValue([0,0,0,1]);

    var squareGroup = nullLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    squareGroup.name = 'Icon';
    var squareContent = squareGroup.property("ADBE Vectors Group");
    var square = squareContent.addProperty("ADBE Vector Shape - Rect");
    square('ADBE Vector Rect Size').setValue([size, size]);
    var stroke = squareContent.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").setValue(DuColor.Color.APP_HIGHLIGHT_COLOR.floatRGBA());
    stroke("ADBE Vector Stroke Width").setValue(1);
    stroke("ADBE Vector Stroke Line Cap").setValue(2);
    stroke("ADBE Vector Stroke Dashes").addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").setValue(2);

    // Select and close
    nullLayer.selected = true;
    DuAE.executeCommand( DuAE.MenuCommandID.REVEAL_EXPRESSION_ERRORS, true );

    if (layer != null)
    {
        layerParent = layer.parent;
        layer.parent = null;
        nullLayer.transform.position.setValue( layer.transform.position.value );
        layer.parent = layerParent;
        nullLayer.moveBefore( layer );
        nullLayer.name = "Null " + layer.name;
    }

    return nullLayer;
}

/**
 * Creates a new "Shape Adjustment Layer" in the comp.
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The comp where to create the layer
 * @returns {ShapeLayer} The adjustment layer
 */
DuAEComp.addAdjustmentLayer = function (comp)
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    var layer = comp.layers.addShape();
    layer.name = DuScriptUI.String.ADJUSTMENT_LAYER;
    layer.adjustmentLayer = true;
    layer.label = 5;

    var solidGroup = layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    solidGroup.name = 'Solid';
    var solidContent = solidGroup.property("ADBE Vectors Group");
    var solid = solidContent.addProperty("ADBE Vector Shape - Rect");
    solid('ADBE Vector Rect Size').setValue([comp.width, comp.height]);
    var fill = solidContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").setValue([1,1,1,1]);

    return layer;
}

/**
 * Creates a new "Solid Adjustment Layer" in the comp.
 * @param {DuColor} [color=DuColor.Color.RAINBOX_RED] The color of the solid
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The comp where to create the layer
 * @returns {ShapeLayer} The adjustment layer
 */
DuAEComp.addSolid = function (color, comp)
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    color = def(color, DuColor.Color.RAINBOX_RED);

    var layer = comp.layers.addShape();
    layer.name = DuScriptUI.String.SOLID_LAYER;
    layer.label = 1;

    var solidGroup = layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    solidGroup.name = 'Solid';
    var solidContent = solidGroup.property("ADBE Vectors Group");
    var solid = solidContent.addProperty("ADBE Vector Shape - Rect");
    solid('ADBE Vector Rect Size').setValue([comp.width, comp.height]);
    var fill = solidContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").setValue(color.floatRGBA());

    return layer;
}

/**
 * Creates a new Shape Layer in the comp.
 * @param {DuAEShapeLayer.Primitive} [shape=DuAEShapeLayer.Primitive.NONE] The shape
 * @param {DuColor} [color=DuColor.Color.RAINBOX_RED] The color of the shape
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The comp where to create the layer
 * @returns {ShapeLayer} The adjustment layer
 */
DuAEComp.addShape = function (shape, color, comp)
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    shape = def(shape, DuAEShapeLayer.Primitive.NONE);
    color = def(color, DuColor.Color.RAINBOX_RED);

    var layer = comp.layers.addShape();
    layer.name = DuScriptUI.String.SHAPE_LAYER;

    if (shape == DuAEShapeLayer.Primitive.NONE) return layer;

    var solidGroup = layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    var solidContent = solidGroup.property("ADBE Vectors Group");

    var size = comp.height/3;

    if (shape == DuAEShapeLayer.Primitive.SQUARE)
    {
        solidGroup.name = DuScriptUI.String.RECTANGLE;
        layer.name = DuScriptUI.String.RECTANGLE;
        var solid = solidContent.addProperty("ADBE Vector Shape - Rect");
        solid('ADBE Vector Rect Size').setValue([size, size]);
    }
    else if (shape == DuAEShapeLayer.Primitive.ROUNDED_SQUARE)
    {
        solidGroup.name =  DuScriptUI.String.ROUNDED_RECTANGLE;
        layer.name =  DuScriptUI.String.ROUNDED_RECTANGLE;
        var solid = solidContent.addProperty("ADBE Vector Shape - Rect");
        solid('ADBE Vector Rect Size').setValue([size, size]);
        solid('ADBE Vector Rect Roundness').setValue(size/10);
    }
    else if (shape == DuAEShapeLayer.Primitive.CIRCLE)
    {
        solidGroup.name =  DuScriptUI.String.CIRCLE;
        layer.name =  DuScriptUI.String.CIRCLE;
        var solid = solidContent.addProperty("ADBE Vector Shape - Ellipse");
        solid('ADBE Vector Ellipse Size').setValue([size, size]);
    }
    else if (shape == DuAEShapeLayer.Primitive.POLYGON)
    {
        solidGroup.name =  DuScriptUI.String.POLYGON;
        layer.name =  DuScriptUI.String.POLYGON;
        var solid = solidContent.addProperty("ADBE Vector Shape - Star");
        solid('ADBE Vector Star Type').setValue(2);
        solid('ADBE Vector Star Outer Radius').setValue(size);
    }
    else if (shape == DuAEShapeLayer.Primitive.STAR)
    {
        solidGroup.name =  DuScriptUI.String.STAR;
        layer.name =  DuScriptUI.String.STAR;
        var solid = solidContent.addProperty("ADBE Vector Shape - Star");
        solid('ADBE Vector Star Inner Radius').setValue(size*.385);
        solid('ADBE Vector Star Outer Radius').setValue(size);
    }

    var fill = solidContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").setValue(DuColor.Color.RAINBOX_RED.floatRGBA());

    return layer;
}
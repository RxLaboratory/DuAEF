
/**
	* Constructs a new DuAEProperty
	* @example
	* var propInfo = new DuAEProperty(property);
	* layer("ADBE effect parade").addProperty("ADBE layer control"); //now the property object is broken
	* property = propInfo.getProperty(); // You can retrieve the property like this, fixed if it's an effect
	* @class DuAEProperty
	* @classdesc Get some handy informations about a property<br />
	* This class is able to "fix" effects properties which have been broken by
	* the addition of another effect on the same layer, as long as the class has been
	* instanciated before the effect has been broken.
	* @param {PropertyBase|DuAEProperty} property - The property. If a DuAEProperty is provided, the constructor returns it (it does not make a copy).<br />
	* This makes it easy to avoid type checking, as you can always pass any property or DuAEProperty to the constructor to be sure to handle a DuAEProperty, without any impact on performance.<br />
	* @example
	* myFunction (prop) //This function can be passed either a property or a DuAEProperty
	* {
	* propInfo = new DuAEProperty(prop);
	* prop = propInfo.getProperty();
	* }
	* @property {int} index - The propertyIndex
	* @property {boolean} isEffect - true if this is an effect (sub)property
	* @property {boolean} riggable  - true if this prop can be rigged (it's a value which can set expressions)
	* @property {Layer} layer - The layer containing the property
	* @property {int} dimensions - The number of dimensions, 0 if this is not a dimensionnal value (text, shape...)
	* @property {string} name - The name of the property
	* @property {string} matchName - The matchName of the property
	* @property {PropertyGroup|null} effect - The effect containing the property
	* @property {boolean} editable - true if the value of the property can be changed
	* @property {boolean} numerical - true if the value is a number or an array of numbers
	* @property {boolean} isPercent - true if the unit is a percentage
	* @property {boolean} isAngle - true if the unit is a degree
	* @property {boolean} isPixels - true if the unit is a pixel
	* @property {int} numKeys - the number of keyframes on the property
	* @property {bool} group - true if the property is a PropertyGroup
	* @property {string} unitsText - the name of the unit (localized)
	* @property {string} unit - the abbreviated unit, as displayed in the UI (localized)
	* @property {string} expression - the expression in the property
*/
function DuAEProperty(property)
{
	if (property instanceof DuAEProperty) return property;
	if (typeof property === 'undefined') 
	{
		DuDebug.throwTypeError(property, "property", "Property", "DuAEProperty(property)");
		return;
	}
	
	var expressionEnabled = property.expressionEnabled;
	if (property.propertyType == PropertyType.PROPERTY)
	{
		this.numKeys = property.numKeys;
		this.group = false;
	}
	else
	{
		this.group = true;
		this.numKeys = 0;
	}
	this.property = property;
	this.name = property.name;
	this.matchName = property.matchName;
	this.index = property.propertyIndex;
	this.parentIndices  = [this.index];
	this.isEffect = property.isEffect;
	this.effect = null;
	if (!this.isEffect)
	{
		var parentProp = property;
		while (parentProp.parentProperty)
		{
			// Traverse up the property tree
			parentProp = parentProp.parentProperty;
			this.isEffect = parentProp.isEffect;
			this.parentIndices.unshift(parentProp.propertyIndex);
			if (this.isEffect) this.effect = parentProp;
			if (this.isEffect) break;
		}
	}
	else this.effect = property;

	this.unitsText = property.unitsText;
	this.isPercent = this.unitsText == localize("$$$/AE/TLW/GraphEditor/PercentSource=percent");
	this.isAngle = this.unitsText == localize("$$$/AE/TLW/GraphEditor/DegreesSource=degrees");
	this.isPixels = this.unitsText == localize("$$$/AE/TLW/GraphEditor/PixelsSource=pixels");
	this.unit = "";
	if (this.isPercent) this.unit = "%";
	if (this.isAngle) this.unit = "Â°";
	if (this.isPixels) this.unit = localize("$$$/AE/TLW/GraphEditor/PixelsDest=px");

}

/**
	* Gets the original Property<br />
	* Always works even if this DuAEProperty represents an effect which has been broken<br />
	* ---AE Hack---
	* @memberof DuAEProperty
	* @return {PropertyBase} The property
	* @todo When returning an effect, check if the matchName corresponds too.
*/
DuAEProperty.prototype.getProperty = function() {
	if (this.isEffect)
	{
		var parentProp = this.layer("ADBE Effect Parade");
		for (var i = 0 ; i < this.parentIndices.length ; i++)
		{
			parentProp = parentProp(this.parentIndices[i]);
		}
		this.property = parentProp;
	}
	return this.property;
}

/**
 * Gets the layer containing the property
 * @return {Layer}	The layer
 */
DuAEProperty.prototype.layer = function ( ) {
    var prop = this.getProperty();
    var parentProp = prop;
    while ( parentProp.parentProperty ) {
        // Traverse up the property tree
        parentProp = parentProp.parentProperty;
    }
    return parentProp;
}

DuAEProperty.prototype.comp = function() {
    return this.layer().containingComp;
}

/**
 * Gets the number of dimensions of a property
 * @return {int}	The number of dimensions, 0 if this is not a dimensionnal value (ie color, text, shape...)
 */
DuAEProperty.prototype.dimensions = function ( ) {
    var prop = this.getProperty();

    var dimensions = 0;
    if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD ) {
        //if this is a position or scale and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
        if ( ( prop.matchName == "ADBE Scale" || prop.matchName == "ADBE Position" ) && !DuAEProperty.getLayer( prop ).threeDLayer ) {
            dimensions = 2;
        } else {
            dimensions = 3;
        }
    } else if ( prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD ) {
        dimensions = 2;
    } else if ( prop.propertyValueType == PropertyValueType.OneD ) {
        dimensions = 1;
    } else if ( prop.propertyValueType == PropertyValueType.COLOR ) {
        dimensions = 4;
    }
    return dimensions;
}

/**
 * Checks if this property value can be edited
 * @return {bool} true if the value of the property can be edited, false otherwise
 */
DuAEProperty.prototype.editable = function ( ) {
    var prop = this.getProperty();

    if ( prop.propertyType != PropertyType.PROPERTY ) return false;
    if ( prop.elided ) return false;
    if ( prop.dimensionsSeparated ) return false;
    if ( prop.propertyValueType == PropertyValueType.NO_VALUE ) return false;
    if ( prop.propertyValueType == PropertyValueType.CUSTOM_VALUE ) return false;
    if ( prop.propertyValueType == PropertyValueType.LAYER_INDEX ) return false;
    if ( prop.propertyValueType == PropertyValueType.MASK_INDEX ) return false;
    try {
        if ( typeof prop.value === 'undefined' ) return false;
    } catch ( e ) {
        return false;
    }

    if (this.isMasterProperty( prop )) return true;
    
    //TODO find a way to detect if prop is hidden without using a try/catch and without setting a value
    //try to set a value if there's no keyframe
    if ( prop.numKeys == 0 ) {
        try {
            prop.setValue( prop.valueAtTime( 0, true ) );
            return true;
        } catch ( e ) {
            return false;
        }
    } else {
        try {
            prop.setValueAtKey( 1, prop.keyValue( 1 ) );
            return true;
        } catch ( e ) {
            return false;
        }
    }

    return true;
}

/**
 * Checks if a property is part of the master properties of a precomp
 * @return {Boolean} true if property is part of the master properties
 */
DuAEProperty.prototype.isMasterProperty = function ( ) {
    var prop = this.getProperty();
    while ( prop.parentProperty !== null ) {
        if (prop.matchName == 'ADBE Layer Overrides') return true;
        prop = prop.parentProperty;
    }
    return false;
}

/**
 * Checks if this property value can be rigged (with an expression)
 * @return {bool} true if the value of the property can be rigged, false otherwise
 */
DuAEProperty.prototype.riggable = function (  ) {
    var prop = this.getProperty();

    if ( prop.propertyType != PropertyType.PROPERTY ) return false;
    if ( !prop.canVaryOverTime ) return false;
    if ( !prop.canSetExpression ) return false;
    if ( prop.elided ) return false;
    if ( prop.dimensionsSeparated ) return false;
    if ( typeof prop.expression !== 'string' ) return false;
    //TODO find a way to detect if prop is hidden without using a try/catch
    var expressionEnabled = prop.expressionEnabled;
    try {
        prop.expressionEnabled = expressionEnabled;
        return true;
    } catch ( e ) {
        return false;
    }
}

/**
 * Gets the key at a given index on a property
 * @param {int}	keyIndex The index of the key to retrieve. If the index is negative, it is counted from the end i.e. to retrieve the keyframe before the last one, use -2 (-1 is the last)
 * @return {DuAEKeyFrame}	The keyframe, or null if incorrect index
 */
DuAEProperty.prototype.keyAtIndex = function ( keyIndex ) {
    var prop = this.getProperty();
    if ( Math.abs( keyIndex ) > prop.numKeys || keyIndex == 0 ) {
        return null;
    }
    if ( keyIndex < 0 ) {
        keyIndex = prop.numKeys - keyIndex + 1;
    }

    var key = new DuAEKeyFrame();
    key._time = prop.keyTime( keyIndex );
    key.value = prop.keyValue( keyIndex );
    key._inInterpolationType = prop.keyInInterpolationType( keyIndex );
    key._outInterpolationType = prop.keyOutInterpolationType( keyIndex );
    if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) {
        key._spatial = true;
        key.spatialProperties.inTangent = prop.keyInSpatialTangent( keyIndex );
        key.spatialProperties.outTangent = prop.keyOutSpatialTangent( keyIndex );
        key.spatialProperties._continuous = prop.keySpatialContinuous( keyIndex );
        key.spatialProperties._autoBezier = prop.keySpatialAutoBezier( keyIndex );
        key.spatialProperties._roving = prop.keyRoving( keyIndex );
    }
    key.inEase = prop.keyInTemporalEase( keyIndex );
    key.outEase = prop.keyOutTemporalEase( keyIndex );
    key._continuous = prop.keyTemporalContinuous( keyIndex );
    key._autoBezier = prop.keyTemporalAutoBezier( keyIndex );
    key._index = keyIndex;

    return key;
}

/**
 * Gets the nearest key at a given time on a property
 * @param {float}	time	- The time of the key to retrieve.
 * @return {DuAEKeyFrame}	The keyframe, or null if incorrect time or not found
 */
DuAEProperty.prototype.nearestKeyAtTime = function ( time ) {
    var prop = this.getProperty();
    return this.keyAtIndex( prop.nearestKeyIndex( time ) );
}

/**
 * Gets the key at an exactly given time on a property
 * @param {float}	time	- The time of the key to retrieve.
 * @return {DuAEKeyFrame}	The keyframe, or null if incorrect time
 */
DuAEProperty.prototype.keyAtTime = function ( time ) {
    var prop = this.getProperty();
    if ( !prop.canVaryOverTime ) return null;
    if ( prop.numKeys == 0 ) return null;
    var key = this.keyAtIndex( prop.nearestKeyIndex( time ) );
    if ( key === null ) return key;
    if ( DuMath.equals( key._time, time, 4) ) return key;
    else return null;
}

/**
 * Gets the property keyframes in the whole timeline or in the time range<br />
 * The DuAEKeyFrame._time will be adjusted relatively to the start of the time range instead of the startTime of the composition.
 * @param {boolean}	[selected=false]	- true to get only selected keyframes.
 * @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds. If not provided, will use the comp time range.<br />
 * Ignored if selected is true;
 * @return {DuAEKeyFrame[]}	The keyframes, or null of this property is of type PropertyValueType.NO_VALUE or PropertyValueType.CUSTOM_VALUE
 */
DuAEProperty.prototype.keys = function ( selected, timeRange ) {
    var prop = this.getProperty();
    if ( prop.propertyValueType == PropertyValueType.NO_VALUE ) return [];
    if ( prop.propertyValueType == PropertyValueType.CUSTOM_VALUE ) return [];

    var comp = this.comp( );
    if ( timeRange == undefined ) timeRange = [ 0, comp.duration ];
    if ( selected == undefined ) selected = false;

    var keyFrames = [];

    if ( prop.elided ) return keyFrames;

    if ( prop.isTimeVarying ) {
        if ( selected ) {
            for ( var keyIndex = 0; keyIndex < prop.selectedKeys.length; keyIndex++ ) {
                var key = this.keyAtIndex( prop.selectedKeys[ keyIndex ] );
                if ( key._time >= timeRange[ 0 ] && key._time <= timeRange[ 1 ] ) {
                    key._time = key._time - timeRange[ 0 ];
                    keyFrames.push( key );
                }
            }
        } else if ( prop.numKeys > 0 ) {
            for ( var keyIndex = 1; keyIndex <= prop.numKeys; keyIndex++ ) {
                var key = this.keyAtIndex( keyIndex );
                if ( key._time >= timeRange[ 0 ] && key._time <= timeRange[ 1 ] ) {
                    key._time = key._time - timeRange[ 0 ];
                    keyFrames.push( key );
                }
            }
        }
    }
    return keyFrames;
}

/**
 * Recursilvely gets all animations in the property and subproperties in the whole timeline or in the time range<br />
 * The first DuAEKeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
 * @param {boolean}	[selected=false]	- true to get only selected keyframes.
 * @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds. If not provided, will use the comp time range.
 * @return {DuAEPropertyGroupAnimation|DuAEPropertyAnimation}	The animations. A DuAEPropertyAnimation if prop is a Property, a PopertyGroupAnim if it is a PropertyGroup
 */
DuAEProperty.prototype.animation = function ( selected, timeRange ) {
    var comp = this.comp( );
    timeRange = def( timeRange, [ 0, comp.duration ] );
    selected = def( selected, false );

    var prop = this.getProperty();

    if ( selected && !this.hasSelectedKeys( ) ) return null;

    if ( prop.propertyType === PropertyType.PROPERTY ) {
        if ( prop.propertyValueType == PropertyValueType.NO_VALUE ) return null;
        if ( prop.elided ) return null;
        if ( !prop.canVaryOverTime ) return null;
        var anim = new DuAEPropertyAnimation();
        anim._name = prop.name;
        anim._matchName = prop.matchName;
        anim.startValue = prop.valueAtTime( timeRange[ 0 ], true );
        anim.endValue = prop.valueAtTime( timeRange[ 1 ], true );
        anim.keys = this.keys( selected, timeRange );
        if ( anim.keys.length > 0 ) {
            anim.startTime = anim.keys[ 0 ]._time;
            anim.endTime = anim.keys[ anim.keys.length - 1 ]._time;
        } else {
            anim.startTime = 0;
            anim.endTime = 0;
        }
        anim.dimensions = this.dimensions( );
        if ( prop.canSetExpression ) anim.expression = prop.expression;
        return anim;
    } else if ( prop.numProperties > 0 ) {
        var groupAnim = new DuAEPropertyGroupAnimation();
        groupAnim._name = prop.name;
        groupAnim._matchName = prop.matchName;

        for ( var propIndex = 1, numP = prop.numProperties; propIndex <= numP; propIndex++ ) {
            var subProp = new DuAEProperty( prop.property( propIndex ) );
            var anim = subProp.animation( selected, timeRange );
            if ( anim != null ) {
                if ( groupAnim.startTime == null ) groupAnim.startTime = anim.startTime;
                else if ( groupAnim.startTime > anim.startTime ) groupAnim.startTime = anim.startTime;
                if ( groupAnim.endTime == null ) groupAnim.endTime = anim.endTime;
                else if ( groupAnim.endTime > anim.endTime ) groupAnim.endTime = anim.endTimeendTime;
                groupAnim.anims.push( anim );
            }
        }
        return groupAnim;
    }
    return null;
}

// low-level undocumented method to get all expressions and cache them
DuAEProperty.prototype.addToExpressionCache = function ( ) {
    var prop = this.getProperty();
    //it it's a prop, add to cache
    if ( prop.propertyType === PropertyType.PROPERTY ) {
        var exp = new DuAEPropertyExpression(prop);
        if ( !exp.empty ) DuAEExpression.cache.push(exp);
    }
    //if it's a group, get props inside
    else if ( prop.numProperties > 0 ) {
        for ( var p = 1, numP = prop.numProperties; p <= numP; p++ ) {
            var subProp = new DuAEProperty( prop.property(p) );
            subProp.addToExpressionCache( );
        }
    }
}

/**
 * Recursilvely gets the time of the first keyFrame in this prop or subprops
 * @param {boolean} selected - true to check selected keyframes only
 * @return {float|null} The keyframe time or null if there are no keyframe
 */
DuAEProperty.prototype.firstKeyTime = function ( selected ) {
    var time = null;
    
    var prop = prop.getProperty();

    if ( prop.propertyType == PropertyType.PROPERTY ) {
        if ( !prop.canVaryOverTime ) return null;
        if ( selected ) {
            if ( prop.selectedKeys.length == 0 ) return null;
            for ( var keyIndex = 0, numK = prop.selectedKeys.length; keyIndex < numK; keyIndex++ ) {
                var key = this.keyAtIndex( prop.selectedKeys[ keyIndex ] );
                if ( time == null ) time = key._time;
                else if ( time > key._time ) time = key._time;
            }
        } else {
            if ( prop.numKeys == 0 ) return null;
            for ( var keyIndex = 1, numK = prop.numKeys; keyIndex <= numK; keyIndex++ ) {
                var key = this.keyAtIndex( keyIndex );
                if ( time == null ) time = key._time;
                else if ( time > key._time ) time = key._time;
            }
        }
    } else if ( prop.numProperties > 0 ) {
        for ( var propIndex = 1, numP = prop.numProperties; propIndex <= numP; propIndex++ ) {
            var subProp = new DuAEProperty( prop.property( propIndex ) );
            var test = subProp.firstKeyTime( selected );
            if ( time == null ) time = test;
            else if ( test != null ) {
                if ( time > test ) time = test;
            }
        }
    }

    return time;
}

/**
 * Sets a {@linkcode DuAEKeyFrame} on a property
 * @param {DuAEKeyFrame}	key	- The DuAEKeyFrame.
 * @param {float}	[timeOffset=comp.time]	- The time offset (added to DuAEKeyFrame._time) where to add the key frame.
 */
DuAEProperty.prototype.setKey = function ( key, timeOffset ) {
    var prop = this.getProperty();

    if ( prop.elided ) return;

    if ( !prop.propertyType === PropertyType.PROPERTY )
    {
        DuDebug.throwError("Can not set a key on a group property", 'DuAEProperty.setKey');
        return;
    }
    if ( !prop.canVaryOverTime ) return;
    if ( prop.isSeparationLeader )
        if ( prop.dimensionsSeparated ) return;

    if ( timeOffset == undefined ) timeOffset = this.comp( ).time;
    var time = key._time + timeOffset;
    var propDimensions = this.dimensions( );
    var val = key.value;

    if ( propDimensions > 1 && !( val instanceof Array ) ) {
        val = [ val ];
    }

    //adjust dimensions
    if ( val instanceof Array ) {
        while ( val.length < propDimensions ) {
            val.push( 0 );
        }
        while ( val.length > propDimensions ) {
            val.pop();
        }
    }

    this.setValueAtTime( val, time );
    if ( prop.numKeys == 0 ) return;

    //get the index of the created key
    var index = prop.nearestKeyIndex( time );

    //set interpolations
    if ( key._spatial && ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) ) {
        try {
            prop.setSpatialContinuousAtKey( index, key.spatialProperties._continuous );
            prop.setSpatialAutoBezierAtKey( index, key.spatialProperties._autoBezier );
            prop.setRovingAtKey( index, key.spatialProperties._roving );
            prop.setSpatialTangentsAtKey( index, key.spatialProperties.inTangent, key.spatialProperties.outTangent );
        } catch ( err ) {
            if ( DuESF.debug ) alert( err.description );
        };
    }

    try {
        prop.setTemporalContinuousAtKey( index, key._continuous );
        prop.setTemporalAutoBezierAtKey( index, key._autoBezier );
        prop.setTemporalEaseAtKey( index, key.inEase, key.outEase );
        prop.setInterpolationTypeAtKey( index, key._inInterpolationType, key._outInterpolationType );
    } catch ( err ) {
        if ( DuESF.debug ) alert( err.description );
    }

}

/**
 * Checks if the property value is a number or an Array of Number.<br >
 * I.e if its value type is one of: one D, two D, three D (spatial or not), Color.
 * @return {bool}
 */
DuAEProperty.prototype.numerical = function ( ) {
    if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL ) return true;
    if ( prop.propertyValueType == PropertyValueType.ThreeD ) return true;
    if ( prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) return true;
    if ( prop.propertyValueType == PropertyValueType.TwoD ) return true;
    if ( prop.propertyValueType == PropertyValueType.OneD ) return true;
    if ( prop.propertyValueType == PropertyValueType.COLOR ) return true;
    return false;
}

/**
 * Sets a value on a property, adjusting the dimensions if needed
 * @param {any} value - The value to set
 * @param {float} [defaultTime=comp().time] - The time at which to set the value if the property has keyframes
 * @return {boolean} True if the value has correctly been set, false otherwise.
 */
DuAEProperty.prototype.setValue = function ( value, defaultTime ) {
    var prop = this.getProperty();

    var dimensions = this.dimensions();

    if ( prop.isSeparationLeader )
        if ( prop.dimensionsSeparated ) return false;

    if ( !this.editable() ) return false;

    if ( prop.numKeys > 0 ) return this.setValueAtTime( value, defaultTime );

    //check dimensions of the property
    if ( dimensions == 0 || dimensions == 1 ) {
        if ( value instanceof Array ) value = value[ 0 ];
        try {
            prop.setValue( value );
            return true;
        } catch ( e ) {
            if ( DuESF.debug ) alert( e.description );
            return false;
        }
    } else {
        if ( !( value instanceof Array ) ) value = [ value ];
        while ( value.length < dimensions ) {
            value.push( 0 );
        }
        while ( value.length > dimensions ) {
            value.pop();
        }
        try {
            prop.setValue( value );
            return true;
        } catch ( e ) {
            if ( DuESF.debug ) alert( e.description );
            return false;
        }
    }
}

/**
 * Sets a new keyframe on a property, adjusting the dimensions if needed, at desired time
 * @param {any} value - The value to set
 * @param {float} [time] - The time of the new keyframe
 * @return {boolean} True if the value has correctly been set, false otherwise.
 */
DuAEProperty.prototype.setValueAtTime = function ( value, time ) {
    var prop = this.getProperty();
    var dimensions = this.dimensions();

    time = def( time, this.comp().time );

    if ( !prop.canVaryOverTime ) return false;
    if ( prop.isSeparationLeader )
        if ( prop.dimensionsSeparated ) return false;

    if ( !this.editable() ) return false;

    //check dimensions of the property
    if ( dimensions == 0 || dimensions == 1 ) {
        if ( value instanceof Array ) value = value[ 0 ];
        try {
            prop.setValueAtTime( time, value );
            return true;
        } catch ( e ) {
            if ( DuESF.debug ) alert( e.description );
            return false;
        }
    } else {
        if ( !( value instanceof Array ) ) value = [ value ];
        while ( value.length < dimensions ) {
            value.push( 0 );
        }
        while ( value.length > dimensions ) {
            value.pop();
        }
        try {
            prop.setValueAtTime( time, value );
            return true;
        } catch ( e ) {
            if ( DuESF.debug ) alert( e.description );
            return false;
        }
    }
}

/**
 * Sets the property animation on the property.<br />
 * Use this method only to force the animation onto the property without checks.<br />
 * Must be used on a Property (not a group) with a DuAEPropertyAnimation (not a DuAEPropertyGroupAnimation).<br />
 * To easily set an animation on a property with automatic compatibility checks, you should use setGroupAnim().
 * @param {DuAEPropertyAnimation} anims	- The animation
 * @param {float}	[time=comp.time]	- The time where to begin the animation
 * @param {boolean}	[setExpression=false]	- Sets the expression too
 * @param {boolean}	[replace=false]	- true to remove any existing keyframe on the properties before adding new keyframes
 * @param {boolean}	[offset=false]	- true to offset the current value, instead of replacing it
 * @return {boolean} true if the anim was actually set.
 */
DuAEProperty.prototype.setAnimation = function ( anim, time, setExpression, replace, offset ) {
    var prop = this.getProperty();
    var comp = this.comp();

    time = def( time, comp.time );
    setExpression = def( setExpression, false );
    replace = def( replace, false );
    offset = def( offset, false );

    if ( !this.numerical() ) offset = false;

    var dimensions = anim.dimensions;

    var ok = false;

    if ( anim == null ) return true;
    if ( anim.type == 'group' ) return false;

    if ( this.editable() ) {
        //keep current value
        var val = prop.valueAtTime( comp.time, true );

        //remove keyframes
        if ( replace && prop.numKeys > 0 ) {
            for ( var i = prop.numKeys; i > 0; i-- ) {
                prop.removeKey( i );
            }
            this.setValue( val );
        }

        //if there are keys, set them
        if ( anim.keys.length > 0 ) {
            for ( var iclef = 0; iclef < anim.keys.length; iclef++ ) {
                var key = anim.keys[ iclef ];
                if ( offset ) {
                    if ( iclef == 0 ) key.value = val;
                    else key.value = val + ( key.value - anim.startValue );
                }
                this.setKey( key, time );
                ok = true;
            }
        } else //set the start value
        {
            var value = anim.startValue;
            
            if ( anim.startValue != null && !offset ) {
                this.setValue( anim.startValue, time );
            }
            ok = true;
        }

        //set the expression
        if ( this.riggable() && setExpression ) {
            try {
                prop.expression = anim.expression;
            } catch ( e ) {
                if ( DuESF.debug ) alert( e.description );
            };
        }
    }

    return ok;
}

// =========== STATIC ====================

/**
 * Gets the After Effects properties in the property
 * @static
 * @param {PropertyBase|DuAEProperty}	property	- The layer
 * @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
 * A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
 * @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
 * @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
 * @return {DuAEProperty[]} The selected properties, an empty Array if nothing found
 */
DuAEProperty.getProps = function ( property, filter, strict, caseSensitive ) {
    if ( strict == undefined ) strict = false;
    if ( caseSensitive == undefined ) caseSensitive = true;
    var prop;
    if ( property instanceof DuAEProperty ) prop = property.getProperty();
    else prop = property;

    var props = [];

    if ( !caseSensitive && typeof filter === "string" ) filter = filter.toLowerCase();

    var name = prop.name;
    var matchName = prop.matchName;
    if ( !caseSensitive ) {
        name = name.toLowerCase();
        matchName = matchName.toLowerCase();
    }

    if ( strict && name === filter ) props.push( prop );
    else if ( strict && matchName === filter ) props.push( prop );
    else if ( !strict && typeof filter === "string" ) {
        if ( name.indexOf( filter ) >= 0 ) props.push( prop );
        else if ( matchName.indexOf( filter ) >= 0 ) props.push( prop );
    }
    else if ( typeof filter === "function" ) {
        if ( filter( prop ) ) props.push( prop );
    }
    else if ( prop.propertyType == filter ) {
        props.push( prop );
    }
    else if ( prop.propertyType == PropertyType.PROPERTY ) {
        if ( prop.propertyValueType == filter ) props.push( prop );
    }    
    

    if ( prop.numProperties > 0 ) {
        for ( var k = 1, numP = prop.numProperties; k <= numP; k++ ) {
            props = props.concat( DuAEProperty.getProps( prop.property( k ), filter, strict, caseSensitive ) );
        }
    }

    return DuAE.getDuAEProperty( props );
}

/**
 * Generates a new unique name for a marker for this marker porperty
 * @static
 * @param {string} newName	- The wanted new name
 * @param {Property} markerProp 	- The marker property
 * @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
 * @return {string}	The unique name, with a new number at the end if needed.
 */
DuAEProperty.newUniqueMarkerName = function ( newName, markerProp, increment ) {
    if ( increment == undefined ) increment = true;
    var markerNames = [];
    for ( var i = 1, num = prop.numKeys; i <= num; i++ ) {
        markerNames.push( prop.keyValue( i ).comment );
    }
    return DuString.generateUnique( newName, markerNames, increment );
}


// =========== DEPRECATED ===============



/**
 * Sets all animations on a Property or a PropertyGroup.
 * @param {PropertyGroup|DuAEProperty}	prop	- The property group.
 * @param {DuAEPropertyAnimation} anims	- The animation
 * @param {float}	[time=comp.time]	- The time where to begin the animation
 * @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
 * @param {boolean}	[setExpression=false]	- Sets the expression too
 * @param {boolean}	[onlyKeyframes=true]	- If false, the value of properties without keyframes will be set too.
 * @param {boolean}	[replace=false]	- true to remove any existing keyframe on the properties before adding new keyframes
 * @param {string[]}	[whiteList]	- A list of matchNames used as a white list for properties to set anims.<br />
 * Can be the matchName of a propertyGroup to set all the subproperties.<br />
 * Ignored if the list is empty.
 * @param {boolean}	[offset=false]	- true to offset the current value, instead of replacing it
 * @return {boolean} true if the anim was actually set.
 */
DuAEProperty.setGroupAnim = function ( prop, anim, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, set ) {
    if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
    time = def( time, DuAEProperty.getComp( prop ).time );
    ignoreName = def( ignoreName, false );
    setExpression = def( setExpression, false );
    onlyKeyframes = def( onlyKeyframes, false );
    replace = def( replace, false );
    whiteList = def( whiteList, [] );
    offset = def( offset, false );
    reverse = def( reverse, false );
    set = def( set, false );

    if ( whiteList.length == 0 ) set = true;

    whiteList = new DuList( whiteList );
    if ( whiteList.indexOf( anim._matchName ) >= 0 ) set = true;

    var ok = false;

    if ( anim == null ) return true;

    if ( anim.type == 'anim' ) {
        if ( set ) {
            var okToSet = false;
            if ( prop.matchName == anim._matchName ) {
                if ( !ignoreName && prop.name == anim._name ) okToSet = true;
                if ( ignoreName ) okToSet = true;
                if ( onlyKeyframes && anim.keys.length == 0 ) okToSet = false;
            }

            if ( okToSet ) return DuAEProperty.setAnim( prop, anim, time, setExpression, replace, offset );
        }
    } else {
        for ( var i = 0; i < anim.anims.length; i++ ) {
            var propAnim = anim.anims[ i ];
            //find the property with the same name and matchname
            for ( var j = 1; j <= prop.numProperties; j++ ) {
                var subProp = prop.property( j );
                var okToSet = false;
                if ( subProp.matchName == propAnim._matchName ) {
                    if ( !ignoreName && subProp.name == propAnim._name ) okToSet = true;
                    if ( ignoreName ) okToSet = true;
                }
                if ( okToSet ) {
                    ok = DuAEProperty.setGroupAnim( subProp, propAnim, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, set );
                    break;
                }
            }
        }
    }

    return ok;
}

/**
 * Removes the animation from the property
 * @param {Property|DuAEProperty} prop -The property
 * @param {boolean} [removeExpression=false] - Set to true to remove the expression too
 */
DuAEProperty.removeAnim = function ( prop, removeExpression ) {
    if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
    while ( prop.numKeys > 0 ) {
        prop.removeKey( 1 );
    }
    if ( removeExpression && prop.canSetExpression ) {
        prop.expression = '';
    }
}

/**
 * Selects the keyframes in the propoerty.<br />
 * Selects all nested keyframes if the property is a group.
 * @param {PropertyBase|DuAEProperty} property - The property
 * @param {float} [inTime=0] - The time at which to select the keyframes
 * @param {float} [outTime=inTime] - The end time
 */
DuAEProperty.selectKeyFrames = function ( property, inTime, outTime ) {
    if ( inTime == undefined ) inTime = 0;
    if ( outTime == undefined ) outTime = inTime;
    var prop;
    if ( property instanceof DuAEProperty ) prop = property.getProperty();
    else prop = property;

    if ( prop.propertyType == PropertyType.PROPERTY ) {
        if ( prop.elided ) return;
        if ( prop.isSeparationLeader )
            if ( prop.dimensionsSeparated ) return;
        if ( inTime == outTime ) {
            //get key
            var key = DuAEProperty.getKeyFrameAtTime( prop, inTime );
            if ( key ) prop.setSelectedAtKey( key._index, true );
        } else {
            //get keys
            var keys = DuAEProperty.getKeyFrames( prop, false, [ inTime, outTime ] );
            if ( !keys ) return;
            for ( var i = 0; i < keys.length; i++ ) {
                prop.setSelectedAtKey( keys[ i ]._index, true );
            }
        }
    } else if ( prop.numProperties > 0 ) {
        for ( var i = 1; i <= prop.numProperties; i++ ) {
            DuAEProperty.selectKeyFrames( prop.property( i ), inTime, outTime );
        }
    }
}

/**
 * Gets an expression link to the property
 * @memberof DuAEProperty
 * @param {Property|DuAEProperty}	prop			- The property
 * @param {bool}		[useThisComp=false]		- Wether to begin the expression by 'thisComp' or 'comp("name")'
 * @param {bool}		[fromLayer=true]		- Wether to begin the expression by comp.layer or directly from the first prop of the layer
 * @return {str}		The expression link to the property
 */
DuAEProperty.getExpressionLink = function ( prop, useThisComp, fromLayer ) {
    if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
    if ( useThisComp == undefined ) useThisComp = false;
    if ( fromLayer == undefined ) fromLayer = true;

    //get compact expression from matchName, if available
    function getCompactExpression( matchName, name ) {
        var translatedName = DuAECompactExpression[ matchName ];

        if ( translatedName !== undefined )
            return eval( translatedName );
        else
            return ( "(" + name + ")" );
    }

    var exprCode = "";
    var name;
    while ( prop.parentProperty !== null ) {
        //do not translate master properties
        if (prop.parentProperty.matchName != "ADBE Layer Overrides")
        {
            if ( prop.propertyType == PropertyType.PROPERTY ) name = prop.propertyIndex;
            else if ( prop.parentProperty.propertyType == PropertyType.INDEXED_GROUP ) {
                name = "\"" + prop.name + "\"";
            } else {
                name = "\"" + prop.matchName + "\"";
            }
            compactName = getCompactExpression( prop.matchName, name );
            exprCode = compactName + exprCode;
        }
        else
        {
            exprCode = '("' + prop.name + '")';
        }
        
        // Traverse up the property tree
        prop = prop.parentProperty;
    }

    if ( exprCode.indexOf( "(" ) != 0 && exprCode != "" ) exprCode = '.' + exprCode;

    if ( fromLayer ) {
        var comp = prop.containingComp;
        // Prefix the layer reference
        name = "\"" + prop.name + "\"";
        exprCode = "layer(" + name + ")" + exprCode;
        // Prefix the comp reference
        if ( useThisComp ) exprCode = "thisComp." + exprCode;
        else exprCode = "comp(\"" + comp.name + "\")." + exprCode;
    }

    return exprCode;
}



/**
 * Changes the interpolation type on selected keyframes, or sets a new key at current time if there are no keyframes selected.
 * @param {Layer[]|LayerCollection} layers - The layers containing the properties
 * @param {PropertyBase[]|DuAEProperty[]} props - The properties
 * @param {KeyframeInterpolationType|string} typeIn - The in interpolation type (see AE API) or the string "roving" or "continuous"
 * @param {KeyframeInterpolationType|string} [typeOut=typeIn] - The out interpolation type (see AE API)
 * @param {int[]|int} [easeInValue=33] - The in interpolation ease value (used if typeIn is KeyframeInterpolationType.BEZIER)
 * @param {int[]|int} [easeOutValue=easeInValue] - The out interpolation ease value (used if typeOut is KeyframeInterpolationType.BEZIER)
 */
DuAEProperty.setInterpolationType = function ( layers, props, typeIn, typeOut, easeInValue, easeOutValue ) {
    if ( typeOut == undefined ) typeOut = typeIn;
    if ( easeInValue == undefined ) easeInValue = 33;
    if ( isNaN( easeInValue ) ) easeInValue = 33;
    if ( easeOutValue == undefined ) easeOutValue = easeInValue;
    if ( isNaN( easeOutValue ) ) easeOutValue = 33;

    if ( layers.length == 0 ) return;

    if ( !DuAELayer.haveSelectedKeys( layers ) ) {
        DuAEProperty.addKey( props, typeIn, typeOut, easeInValue, easeOutValue );
    } else {
        for ( var i = 0; i < props.length; i++ ) {
            var propInfo = props[ i ];
            var prop = props[ i ];
            if ( !( propInfo instanceof DuAEProperty ) ) propInfo = new DuAEProperty( prop );
            prop = props[ i ].getProperty();

            if ( prop.canVaryOverTime ) {
                //for keys
                for ( var k = 0, num = prop.selectedKeys.length; k < num; k++ ) {
                    DuAEProperty.setKeyInterpolation( prop, prop.selectedKeys[ k ], typeIn, typeOut, easeInValue, easeOutValue );
                }
            }
        }
    }
}

/**
 * Sets interpolations on a keyframe.<br />
 * @param {Property} prop - The property
 * @param {int} key - The key index
 * @param {KeyframeInterpolationType|string} typeIn - The in interpolation type (see AE API) or the string "roving" or "continuous"
 * @param {KeyframeInterpolationType|string} [typeOut=typeIn] - The out interpolation type (see AE API)
 * @param {int[]|int} [easeInValue=33] - The in interpolation ease value (used if typeIn is KeyframeInterpolationType.BEZIER)
 * @param {int[]|int} [easeOutValue=easeInValue] - The out interpolation ease value (used if typeOut is KeyframeInterpolationType.BEZIER)
 */
DuAEProperty.setKeyInterpolation = function ( prop, key, typeIn, typeOut, easeInValue, easeOutValue ) {
    if ( typeOut == undefined ) typeOut = typeIn;
    if ( easeInValue == undefined ) easeInValue = 33;
    if ( isNaN( easeInValue ) ) easeInValue = 33;
    if ( easeOutValue == undefined ) easeOutValue = easeInValue;
    if ( isNaN( easeOutValue ) ) easeOutValue = 33;

    easeInValue = new KeyframeEase( 0, easeInValue );
    easeOutValue = new KeyframeEase( 0, easeOutValue );

    if ( typeIn == "roving" && prop.isSpatial ) {
        prop.setRovingAtKey( key, true );
    } else if ( typeIn == "continuous" ) {
        prop.setInterpolationTypeAtKey( key, KeyframeInterpolationType.BEZIER );
        prop.setTemporalContinuousAtKey( key, true );
        prop.setTemporalAutoBezierAtKey( key, true );
        //not roving
        if ( prop.isSpatial ) prop.setRovingAtKey( key, false );
    } else if ( typeIn != "roving" ) {
        //influences
        if ( !prop.isSpatial && prop.value.length == 3 ) {
            prop.setTemporalEaseAtKey( key, [ easeInValue, easeInValue, easeInValue ], [ easeOutValue, easeOutValue, easeOutValue ] );
        } else if ( !prop.isSpatial && prop.value.length == 2 ) {
            prop.setTemporalEaseAtKey( key, [ easeInValue, easeInValue ], [ easeOutValue, easeOutValue ] );
        } else {
            prop.setTemporalEaseAtKey( key, [ easeInValue ], [ easeOutValue ] );
        }
        //type
        prop.setInterpolationTypeAtKey( key, typeIn, typeOut );
        //not roving
        if ( prop.isSpatial ) {
            if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) prop.setRovingAtKey( key, false );
        }
        //not continuous
        prop.setTemporalContinuousAtKey( key, false );
    }
}

/**
 * Adds a new keyframe on the properties.<br />
 * To set a value of your choice on one property,<br />
 * you can create a new {@link DuAEKeyFrame}, then use {@link DuAEProperty.setKey}.
 * @param {PropertyBase[]|DuAEProperty[]} props - The properties
 * @param {KeyframeInterpolationType|string} typeIn - The in interpolation type (see AE API) or the string "roving" or "continuous"
 * @param {KeyframeInterpolationType|string} [typeOut=typeIn] - The out interpolation type (see AE API)
 * @param {int[]|int} [easeInValue=33] - The in interpolation ease value (used if typeIn is KeyframeInterpolationType.BEZIER)
 * @param {int[]|int} [easeOutValue=easeInValue] - The out interpolation ease value (used if typeOut is KeyframeInterpolationType.BEZIER)
 * @param {float} [time=comp.time] - The time at which to add the key
 */
DuAEProperty.addKey = function ( props, typeIn, typeOut, easeInValue, easeOutValue, time ) {
    for ( var i = 0; i < props.length; i++ ) {
        var propInfo = props[ i ];
        var prop = props[ i ];
        if ( !( propInfo instanceof DuAEProperty ) ) propInfo = new DuAEProperty( prop );
        prop = props[ i ].getProperty();
        var comp = DuAEProperty.getComp( prop );
        if ( prop.canVaryOverTime ) {
            var keyTime;
            if ( typeof time === 'undefined' ) keyTime = comp.time;
            else keyTime = time;
            var key = prop.addKey( keyTime );
            DuAEProperty.setKeyInterpolation( prop, key, typeIn, typeOut, easeInValue, easeOutValue );
        }
    }
}

/**
 * Computes a percentage from a velocity on a given keyframe. 
 * @param {Property|DuAEProperty} prop - The property
 * @param {int} key - The index of the keyframe where to compute the velocity
 * @return {float[]} The velocities [in, out] as a percentage.
 */
DuAEProperty.velocityToPercent = function ( prop, key ) {
    var propInfo = new DuAEProperty( prop );
    prop = propInfo.getProperty();

    var speedIn = prop.keyInTemporalEase( key )[ 0 ].speed;
    var speedOut = prop.keyOutTemporalEase( key )[ 0 ].speed;

    //get speed just before and after as if it was linear
    var prevSpeed = 0;
    var nextSpeed = 0;
    var val = prop.keyValue( key );
    var currentTime = prop.keyTime( key );
    if ( key > 1 ) {
        var valBefore = prop.keyValue( key - 1 );
        var timeBefore = prop.keyTime( key - 1 );
        prevSpeed = DuMath.getLength( val, valBefore ) / ( currentTime - timeBefore );
    }

    if ( key < prop.numKeys ) {
        var valAfter = prop.keyValue( key + 1 );
        var timeAfter = prop.keyTime( key + 1 );
        nextSpeed = DuMath.getLength( val, valBefore ) / ( timeAfter - currentTime );
    }

    //get average speed
    var speed = ( prevSpeed + nextSpeed ) / 2;

    //compare to the original speeds 
    var speedInAsPercent = speedIn / speed * 100;
    var speedOutAsPercent = speedOut / speed * 100;

    return [ speedInAsPercent, speedOutAsPercent ];
}

/**
 * Changes the ease influences of the selected keys
 * @param {PropertyBase[]|DuAEProperty[]} props - The properties
 * @param {int[]|int} [easeInValue] - The in interpolation ease value. Will be ignored if undefined.
 * @param {int[]|int} [easeOutValue] - The out interpolation ease value. Will be ignored if undefined.
 * @param {int[]|int} [velocityInValue] - The out interpolation ease value. Will be ignored if undefined.
 * @param {int[]|int} [velocityOutValue] - The out interpolation ease value. Will be ignored if undefined.
 * @param {boolean} [velocityAsPercent=false] - Use a percent instead of a value to set velocities.<br />
 * In this case, the proper velocity value will be deduced by multiplying the max speed of the property by the percent.
 */
DuAEProperty.setEase = function ( props, easeInValue, easeOutValue, velocityInValue, velocityOutValue, velocityAsPercent ) {
    if ( isNaN( easeInValue ) && typeof easeInValue !== 'undefined' ) easeInValue = 33;
    if ( isNaN( easeOutValue ) && typeof easeOutValue !== 'undefined' ) easeOutValue = 33;
    if ( isNaN( velocityInValue ) && typeof velocityInValue !== 'undefined' ) velocityInValue = 0;
    if ( isNaN( velocityOutValue ) && typeof velocityOutValue !== 'undefined' ) velocityOutValue = 0;

    for ( var i = 0; i < props.length; i++ ) {
        var propInfo = new DuAEProperty( props[ i ] );
        var prop = propInfo.getProperty();

        var comp = propInfo.comp;

        if ( prop.canVaryOverTime ) {

            var vInValue = velocityInValue;
            var vOutValue = velocityOutValue;

            for ( var k = 0; k < prop.selectedKeys.length; k++ ) {
                var key = prop.selectedKeys[ k ];

                if ( typeof easeInValue !== 'undefined' ) {
                    if ( typeof velocityInValue === 'undefined' && prop.keyInInterpolationType( key ) == KeyframeInterpolationType.LINEAR ) {
                        vInValue = 0;
                    }
                }

                if ( typeof easeOutValue !== 'undefined' ) {
                    if ( typeof velocityOutValue === 'undefined' && prop.keyOutInterpolationType( key ) == KeyframeInterpolationType.LINEAR ) {
                        vOutValue = 0;
                    }
                }

                //compute the velocity
                if ( velocityAsPercent ) {
                    //get speed just before and after as if it was linear
                    var prevSpeed;
                    var nextSpeed;
                    var val = prop.keyValue( key );
                    var currentTime = prop.keyTime( key );
                    var valBefore = val;
                    var valAfter = val;
                    if ( key > 1 ) {
                        var valBefore = prop.keyValue( key - 1 );
                        var timeBefore = prop.keyTime( key - 1 );
                        prevSpeed = DuMath.getLength( val, valBefore ) / ( currentTime - timeBefore );
                    }

                    if ( key < prop.numKeys ) {
                        var valAfter = prop.keyValue( key + 1 );
                        var timeAfter = prop.keyTime( key + 1 );
                        nextSpeed = DuMath.getLength( val, valBefore ) / ( timeAfter - currentTime );
                    }

                    if ( typeof prevSpeed === 'undefined' && typeof nextSpeed === 'undefined' ) {
                        prevSpeed = 0;
                        nextSpeed = 0;
                    } else if ( typeof prevSpeed === 'undefined' ) {
                        prevSpeed = nextSpeed;
                    } else if ( typeof nextSpeed === 'undefined' ) {
                        nextSpeed = prevSpeed;
                    }

                    //detect sign
                    var signBefore = 1;
                    var signAfter = 1;
                    if ( propInfo.dimensions == 1 ) {
                        if ( val - valBefore < 1 ) signBefore = -1;
                        if ( valAfter - val < 1 ) signAfter = -1;
                    }

                    if ( velocityInValue == velocityOutValue ) {
                        //select average speed
                        var speed = ( prevSpeed + nextSpeed ) / 2;

                        vInValue = velocityInValue * speed / 100 * signBefore;
                        vOutValue = velocityOutValue * speed / 100 * signBefore;
                    } else {

                        vInValue = velocityInValue * prevSpeed / 100 * signBefore;
                        vOutValue = velocityOutValue * nextSpeed / 100 * signAfter;
                    }

                }


                //set interpolation 
                var easeIn = [ new KeyframeEase(
                    def( vInValue, prop.keyInTemporalEase( key )[ 0 ].speed ),
                    def( easeInValue, prop.keyInTemporalEase( key )[ 0 ].influence )
                ) ];
                var easeOut = [ new KeyframeEase(
                    def( vOutValue, prop.keyOutTemporalEase( key )[ 0 ].speed ),
                    def( easeOutValue, prop.keyOutTemporalEase( key )[ 0 ].influence )
                ) ];

                if ( !prop.isSpatial ) {
                    for ( var j = 1; j < prop.keyInTemporalEase( prop.selectedKeys[ k ] ).length; j++ ) {
                        easeIn.push( new KeyframeEase(
                            def( vInValue, prop.keyInTemporalEase( key )[ j ].speed ),
                            def( easeInValue, prop.keyInTemporalEase( key )[ j ].influence )
                        ) );
                        easeOut.push( new KeyframeEase(
                            def( vOutValue, prop.keyOutTemporalEase( key )[ j ].speed ),
                            def( easeOutValue, prop.keyOutTemporalEase( key )[ j ].influence )
                        ) );
                    }
                }

                //adjust interpolation types
                var inType = KeyframeInterpolationType.BEZIER;
                var outType = KeyframeInterpolationType.BEZIER;

                if ( typeof easeInValue === 'undefined' && typeof velocityInValue === 'undefined' ) {
                    inType = prop.keyInInterpolationType( key );
                }
                if ( typeof easeOutValue === 'undefined' && typeof velocityOutValue === 'undefined' ) {
                    outType = prop.keyOutInterpolationType( key );
                }

                prop.setInterpolationTypeAtKey( key, inType, outType );

                prop.setTemporalEaseAtKey( key, easeIn, easeOut );
            }
        }
    }
}

/**
 * Checks if the property has some selected keyframes.<br />
 * The property can be either a Property or a PropertyGroup.
 * @param {PropertyBase} prop - The property
 * @return {boolean} true if the property have at least one selected keyframe
 */
DuAEProperty.hasSelectedKeys = function ( prop ) {
    var yes = false;

    if ( prop.propertyType == PropertyType.PROPERTY ) {
        if ( prop.selectedKeys.length > 0 ) {
            yes = true;
        }
    } else if ( prop.numProperties > 0 ) {
        for ( var propIndex = 1; propIndex <= prop.numProperties; propIndex++ ) {
            yes = DuAEProperty.hasSelectedKeys( prop.property( propIndex ) );
            if ( yes ) break;
        }
    }
    return yes;
}

/**
 * Sets the spatial interpolation of the selected keyframes on the property
 * @param {Property|DuAEProperty} prop - The property
 * @param {KeyframeInterpolationType} typeIn - The in interpolation type (see AE API)
 * @param {KeyframeInterpolationType} [typeOut=typeIn] - The in interpolation type (see AE API)
 */
DuAEProperty.setSpatialInterpolation = function ( prop, typeIn, typeOut ) {
    if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
    if ( typeOut == undefined ) typeOut = typeIn;
    if ( !prop.isSpatial ) return;
    if ( prop.selectedKeys.length == 0 ) return;
    for ( var k = 0; k < prop.selectedKeys.length; k++ ) {
        if ( typeIn == KeyframeInterpolationType.BEZIER && typeOut == KeyframeInterpolationType.BEZIER ) {
            prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], true );
        } else if ( typeIn == KeyframeInterpolationType.LINEAR && typeOut == KeyframeInterpolationType.LINEAR ) {
            prop.setSpatialContinuousAtKey( prop.selectedKeys[ k ], false );
            prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], false );
            if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL ) {
                prop.setSpatialTangentsAtKey( prop.selectedKeys[ k ], [ 0, 0, 0 ], [ 0, 0, 0 ] );
            } else if ( prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) {
                prop.setSpatialTangentsAtKey( prop.selectedKeys[ k ], [ 0, 0 ], [ 0, 0 ] );
            }
        } else if ( typeIn == KeyframeInterpolationType.BEZIER ) {
            prop.setSpatialContinuousAtKey( prop.selectedKeys[ k ], false );
            prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], false );
            var keyIndex = prop.selectedKeys[ k ];
            if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL ) {
                if ( prop.keyInSpatialTangent( keyIndex )[ 0 ] == 0 && prop.keyInSpatialTangent( keyIndex )[ 1 ] == 0 && prop.keyInSpatialTangent( keyIndex )[ 2 ] == 0 ) {
                    prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], true );
                }
                prop.setSpatialTangentsAtKey( keyIndex, prop.keyInSpatialTangent( keyIndex ), [ 0, 0, 0 ] );
            } else if ( prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) {
                if ( prop.keyInSpatialTangent( keyIndex )[ 0 ] == 0 && prop.keyInSpatialTangent( keyIndex )[ 1 ] == 0 ) {
                    prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], true );
                }
                prop.setSpatialTangentsAtKey( keyIndex, prop.keyInSpatialTangent( keyIndex ), [ 0, 0 ] );
            }
        } else if ( typeIn == KeyframeInterpolationType.LINEAR ) {
            prop.setSpatialContinuousAtKey( prop.selectedKeys[ k ], false );
            prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], false );
            var keyIndex = prop.selectedKeys[ k ];
            if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL ) {
                if ( prop.keyOutSpatialTangent( keyIndex )[ 0 ] == 0 && prop.keyOutSpatialTangent( keyIndex )[ 1 ] == 0 && prop.keyOutSpatialTangent( keyIndex )[ 2 ] == 0 ) {
                    prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], true );
                }
                prop.setSpatialTangentsAtKey( keyIndex, [ 0, 0, 0 ], prop.keyOutSpatialTangent( keyIndex ) );
            } else if ( prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) {
                if ( prop.keyOutSpatialTangent( keyIndex )[ 0 ] == 0 && prop.keyOutSpatialTangent( keyIndex )[ 1 ] == 0 ) {
                    prop.setSpatialAutoBezierAtKey( prop.selectedKeys[ k ], true );
                }
                prop.setSpatialTangentsAtKey( keyIndex, [ 0, 0 ], prop.keyOutSpatialTangent( keyIndex ) );
            }
        }
    }
}

/**
 * Fixes the spatial interpolation of the selected keys.<br />
 * Sets the interpolation to linear when the property does not move between keyframes
 * @param {Property|DuAEProperty} prop - The property
 */
DuAEProperty.fixSpatialInterpolation = function ( prop ) {
    if ( prop instanceof DuAEProperty ) prop = prop.getProperty();

    if ( !prop.isSpatial ) return;
    if ( !prop.canVaryOverTime ) return;

    var keyIndices = prop.selectedKeys;
    if ( keyIndices.length < 2 ) return;

    for ( var k = 0; k < keyIndices.length - 1; k++ ) {
        var key = keyIndices[ k ];
        var nextKey = keyIndices[ k + 1 ]
        //get this key value
        var keyValue = prop.valueAtTime( prop.keyTime( key ), true );
        //get next key value
        var nextKeyValue = prop.valueAtTime( prop.keyTime( key + 1 ), true );

        //compare and set
        if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL ) {
            if ( keyValue[ 0 ] == nextKeyValue[ 0 ] && keyValue[ 1 ] == nextKeyValue[ 1 ] && keyValue[ 2 ] == nextKeyValue[ 2 ] ) {
                prop.setSpatialTangentsAtKey( key, prop.keyInSpatialTangent( key ), [ 0, 0, 0 ] );
                prop.setSpatialTangentsAtKey( nextKey, [ 0, 0, 0 ], prop.keyOutSpatialTangent( nextKey ) );
            }
        } else if ( prop.propertyValueType == PropertyValueType.TwoD_SPATIAL ) {
            if ( keyValue[ 0 ] == nextKeyValue[ 0 ] && keyValue[ 1 ] == nextKeyValue[ 1 ] ) {
                prop.setSpatialTangentsAtKey( key, prop.keyInSpatialTangent( key ), [ 0, 0 ] );
                prop.setSpatialTangentsAtKey( nextKey, [ 0, 0 ], prop.keyOutSpatialTangent( nextKey ) );
            }
        }
    }
}

/**
 * Removes all unneeded keyframes from the property.< br/>
 * Also checks the interpolation values to reset the correct display as linear/smooth.
 * @param {Property|DuAEProperty} property - The property
 */
DuAEProperty.cleanKeyframes = function ( property ) {
    var prop = property;
    if ( prop instanceof DuAEProperty ) prop = property.getProperty();

    var numKeys = prop.numKeys;
    if ( numKeys == 0 ) return;
    if ( numKeys == 1 ) {
        prop.removeKey( 1 );
        return;
    }

    for ( var i = numKeys; i > 0; i-- ) {
        var currentKey = DuAEProperty.getKeyFrameAtIndex( prop, i );

        if ( i > 1 ) var prevKey = DuAEProperty.getKeyFrameAtIndex( prop, i - 1 );
        if ( i < prop.numKeys ) var nextKey = DuAEProperty.getKeyFrameAtIndex( prop, i + 1 );

        //check values
        var currentValue = new DuList( currentKey.value );
        if ( i > 1 && !currentValue.equals( prevKey.value, 3 ) ) continue;
        if ( i < prop.numKeys && !currentValue.equals( nextKey.value, 3 ) ) continue;
        //check velocities
        var remove = false;
        for ( var j = 0; j < currentKey.inEase.length; j++ ) {
            remove = false
            if ( i > 1 && !DuMath.equals( prevKey.outEase[ j ].speed, 0, 4 ) ) break;
            if ( i > 1 && !DuMath.equals( currentKey.inEase[ j ].speed, 0, 4 ) ) break;
            if ( i < prop.numKeys && !DuMath.equals( currentKey.outEase[ j ].speed, 0, 4 ) ) break;
            if ( i < prop.numKeys && !DuMath.equals( nextKey.inEase[ j ].speed, 0, 4 ) ) break;
            remove = true;
        }
        //remove key
        if ( remove ) prop.removeKey( i );
    }
}

/**
 * Gets the maximum speed of the animated propreties
 * @param {Property[]|DuAEProperty[]} props - The Properties
 * @param {bool}	 [preExpression=true]	- True to get the velocity from keyframes instead of the result of the exression
 * @return {float} The average speed
 */
DuAEProperty.getMaximumSpeed = function ( props ) {
    var maxSpeed = 0;

    for ( var i = 0; i < props.length; i++ ) {
        var speed = DuAEProperty.getMaxVelocity( props[ i ], false );
        if ( speed > maxSpeed ) maxSpeed = speed;
    }

    return maxSpeed;
}

/**
 * Gets the speed of a property at a given time
 * @param {Property|DuAEProperty} prop - The property
 * @param {float} [time=composition.time] - The time.
 * @param {boolean} [preExpression=true] - true to get the pre-expression speed.
 * @return {float} The speed
 */
DuAEProperty.getSpeed = function ( prop, time, preExpression ) {
    preExpression = def (preExpression, true);
    if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
    if ( prop.propertyType != PropertyType.PROPERTY ) return 0;
    if ( prop.numKeys == 0 && preExpression ) return 0;
    var comp = DuAEProperty.getComp( prop );
    if ( time == undefined ) time = comp.time;

    var speed = DuMath.getLength( prop.valueAtTime( time + comp.frameDuration / 2, preExpression ), prop.valueAtTime( time - comp.frameDuration / 2, preExpression ) );
    return speed / comp.frameDuration;
}

/**
 * Sets an expression to a property.<br />
 * With the ability to keep the initial value.
 * @param {Property|DuAEProperty} property - The property
 * @param {string} expr - The expression
 * @param {bool} [keepValue=true] - When true, the method will try to keep the same resulting value as before applying the expression.
 */
DuAEProperty.setExpression = function ( property, expr, keepValue ) {
    keepValue = def( keepValue, true );

    var propInfo = new DuAEProperty( property );
    if ( !propInfo.riggable ) return;

    property = propInfo.getProperty();

    var originalValue = property.valueAtTime( propInfo.comp.time, false );

    //remove current expression
    if ( keepValue ) DuAEProperty.removeExpression( property );
    else try {
        property.expression = ""
    } catch ( e ) {
        if ( DuESF.debug ) alert( e.description );
        return;
    }
    //set new expression
    try {
        property.expression = expr;
    } catch ( e ) {
        if ( DuESF.debug ) alert( e.description );
    }

    //restore value
    if ( propInfo.editable && keepValue && propInfo.dimensions > 0 ) DuAEProperty.setValue( property, 2 * originalValue - property.valueAtTime( propInfo.comp.time, false ) );
}

/**
 * Replaces text in Expressions
 * @param {PropertyBase|DuAEProperty} prop - The property (can be a group)
 * @param {string} oldString - The string to replace
 * @param {string} newString - The new string
 * @param {boolean} [caseSensitive=true] - Wether the search has to be case sensitive
 */
DuAEProperty.replaceInExpressions = function ( prop, oldString, newString, caseSensitive ) {
    caseSensitive = def (caseSensitive, true);

    if ( prop.propertyType == PropertyType.PROPERTY ) {
        if ( prop.canSetExpression ) {
            if ( prop.expression = '' ) return;
            if ( prop.expression.length < oldString.length ) return;
            try {
                prop.expression = DuString.replace( prop.expression, oldString, newString, caseSensitive );
            } catch ( e ) {};
        }
    } else if ( prop.numProperties > 0 ) {
        for ( var propertyIndex = 1; propertyIndex <= prop.numProperties; propertyIndex++ ) {
            DuAEProperty.replaceInExpressions( prop.property( propertyIndex ), oldString, newString, caseSensitive );
        }
    }
}

/**
 * Adds an expression to the child property, linking it to the parent property
 * @memberof DuAEProperty
 * @param {Property} childProp - The child property (the one which gets an expression).
 * @param {Property} parentProp - The parent property.
 * @param {bool} useThisComp - Wether to begin the expression by 'thisComp' or 'comp("name")', default: will detect if the properties are in the same comp
 */
DuAEProperty.pickWhip = function ( childProp, parentProp, useThisComp ) {
    if (childProp instanceof DuAEProperty) childProp = childProp.getProperty();
    if (parentProp instanceof DuAEProperty) parentProp = parentProp.getProperty();
    if ( !childProp.canSetExpression ) return;
    if ( typeof useThisComp === 'undefined' ) {
        var parentComp = DuAEProperty.getComp( parentProp );
        var childComp = DuAEProperty.getComp( childProp );
        if ( parentComp.id == childComp.id ) useThisComp = true;
        else useThisComp = false;
    }
    var exp = DuAEProperty.getExpressionLink( parentProp, useThisComp );
    DuAEProperty.setExpression( childProp, exp, false );
}

/**
 * Link all the properties found in childProp to all the same properties of parentProp (this is a recursive method)<br />
 * Note: any Property or PropertyGroup (and its subproperties) named "Data" will be linked the opposite way (from parentProp to childProp).
 * @memberof DuAEProperty
 * @param {PropertyBase} childProp - The child property
 * @param {PropertyBase} parentProp - The parent property
 * @param {bool} [useThisComp] - Wether to begin the expression by 'thisComp' or 'comp("name")', default: will detect if the properties are in the same comp
 * @param {LayerItem} [timeLayer=null] - A layer used to offset the time (typically, in case of link between precompositions, the precomposition layer).<br />
 * When not null, the start time of this layer will be taken into account to get the values and synchronize them.
 */
DuAEProperty.linkProperties = function ( childProp, parentProp, useThisComp, timeLayer ) {
    if ( parentProp.name.toLowerCase() == 'data' ) return;

    if ( childProp.propertyType == PropertyType.PROPERTY && !childProp.elided && childProp.propertyValueType != PropertyValueType.NO_VALUE ) {
        if ( typeof timeLayer === 'undefined' ) timeLayer = null;

        if ( typeof useThisComp === 'undefined' ) {
            var parentComp = DuAEProperty.getComp( parentProp );
            var childComp = DuAEProperty.getComp( childProp );

            useThisComp = parentComp.id == childComp.id;
        }

        //copy paste the animation / value
        var anim = DuAEProperty.getAnim( parentProp, false );
        if ( anim != null ) DuAEProperty.setAnim( childProp, anim, 0, true, true, false );      
        
        // Expression
        var exp = [DuAEF.Duik.expressionIds.LINK,
            'var link = ' + DuAEProperty.getExpressionLink( parentProp, useThisComp ) + ';'
            ].join('\n');
        if ( timeLayer != null ) {
            exp += [ '\nvar timeLayer = ' + DuAEProperty.getExpressionLink( timeLayer ) + ';',
                'var timeOffset = timeLayer.startTime;',
                'link.valueAtTime(time + timeOffset);'
                ].join('\n');
        }
        else {
            exp += '\nlink.value;';
        }

        //set the link
        DuAEProperty.setExpression( childProp, exp, false );

    } else {
        if ( parentProp.isEffect ) {
            var insideData = 0;
            for ( var p = 1, num = childProp.numProperties; p <= num; p++ ) {
                
                var subProp = parentProp( p );
                if ( subProp.propertyValueType == PropertyValueType.NO_VALUE ) {
                    if ( subProp.name.toLowerCase() == 'data' ) {
                        insideData++;
                        continue;
                    }

                    if ( insideData > 0 ) {
                        if ( subProp.name == parentProp.name || subProp.name == "" ) insideData--;
                        else insideData++;
                        continue;
                    }
                }
                
                if ( insideData == 0 ) DuAEProperty.linkProperties( childProp( p ), subProp, useThisComp, timeLayer );
                else DuAEProperty.linkProperties( subProp, childProp( p ), useThisComp, timeLayer );
            }
        } else {
            for ( var p = 1, num = childProp.numProperties; p <= num; p++ ) {

                try { DuAEProperty.linkProperties( childProp( p ), parentProp( p ), useThisComp, timeLayer ); }
                catch(e) { if (DuESF.debug) alert (childProp.name + ' could not be linked.\nError at line: ' + e.line + " in " + e.fileName + "\n" + e.description)};
            }
        }
    }
}

/**
 * Removes all expressions found in groups or sections named "Data" in the property.
 * @memberof DuAEProperty
 * @param {PropertyBase} prop - The property
 */
DuAEProperty.removeDataExpressions = function ( prop ) {
    if ( prop.propertyType == PropertyType.PROPERTY && prop.name.toLowerCase() == 'data' ) {
        DuAEProperty.removeExpression( prop );
    } else if ( prop.isEffect ) {
        var insideData = 0;
        for ( var p = 1, num = prop.numProperties; p <= num; p++ ) {
            var subProp = prop( p );
            if ( subProp.propertyValueType == PropertyValueType.NO_VALUE ) {
                if ( subProp.name.toLowerCase() == 'data' ) {
                    insideData++;
                    continue;
                }

                if ( insideData > 0 ) {
                    if ( subProp.name == "" || subProp.name == prop.name ) insideData--;
                    else insideData++;
                    continue;
                }
            }
            if ( insideData > 0 ) DuAEProperty.removeExpression( subProp );
        }
    } else {
        if ( prop.name.toLowerCase() == 'data' ) DuAEProperty.removeExpressions( prop );
        for ( var p = 1, num = prop.numProperties; p <= num; p++ ) {
            DuAEProperty.removeDataExpressions( prop( p ) );
        }
    }
}

/**
 * Removes all expressions found in the property.
 * @memberof DuAEProperty
 * @param {PropertyBase} prop - The property
 * @param {function} filter - A function which takes a string as a parameter (the expression). Returns true if the expression has to be removed.
 * @param {bool} [keepPostExpressionValue=true] Set to false to just remove the expressions and get back the pre expression value
 */
DuAEProperty.removeExpressions = function ( prop, filter, keepPostExpressionValue ) {
    if ( prop.propertyType == PropertyType.PROPERTY ) {
        DuAEProperty.removeExpression( prop, filter, keepPostExpressionValue );
    } else {
        for ( var p = 1, num = prop.numProperties; p <= num; p++ ) {
            DuAEProperty.removeExpressions( prop( p ), filter, keepPostExpressionValue );
        }
    }
}

/**
 * Adds all the (supported) properties found in a property to the essential graphics panel<br />
 * Note: any Property or PropertyGroup (and its subproperties) named "data" will be ignored.
 * @memberof DuAEProperty
 * @param {PropertyBase} prop - The property
 * @return {int} The number of properties added
 */
DuAEProperty.addToEGP = function ( prop ) {
    var numProps = 0;
    if ( prop.name.toLowerCase() == 'data' ) return numProps;
    if ( prop.propertyType == PropertyType.PROPERTY && prop.propertyValueType != PropertyValueType.NO_VALUE ) {
        var comp = DuAEProperty.getComp( prop );
        var layer = DuAEProperty.getLayer( prop );
        //set the link
        if ( prop.canAddToMotionGraphicsTemplate( comp ) && !prop.elided && prop.canSetExpression ) {
            //get the name 
            var mPropName = layer.name + ' / ' + DuAEProperty.getExpressionLink( prop, true, false );
            //add with name
            if ( DuAE.version.version >= 16.1 ) {
                prop.addToMotionGraphicsTemplateAs( comp, mPropName);
            }
            else {
                prop.addToMotionGraphicsTemplate( comp );
            }

            //rename the master property if >=15.1 and < 16.1
            if ( DuAE.version.version >= 15.1 && DuAE.version.version < 16.1 ) {
                var it = new DuList( comp.usedIn );
                it.do( function ( mainComp ) {
                    //search the layer of the precomp
                    for ( var i = 1, num = mainComp.numLayers; i <= num; i++ ) {
                        var l = mainComp.layer( i );
                        if ( l.source )
                            if ( l.source.id == comp.id ) {
                                l( 'ADBE Layer Overrides' )( 1 ).name = mPropName;
                            }
                    }
                } );
            }
            numProps++;
        }
    } else {
        if ( prop.isEffect ) {
            var insideData = 0;
            for ( var p = 1, num = prop.numProperties; p <= num; p++ ) {
                var subProp = prop( p );
                if ( subProp.propertyValueType == PropertyValueType.NO_VALUE ) {
                    if ( subProp.name.toLowerCase() == 'data' ) {
                        insideData++;
                        continue;
                    }

                    if ( insideData > 0 ) {
                        if ( subProp.name == prop.name ) insideData--;
                        else insideData++;
                        continue;
                    }
                }
                if ( insideData == 0 ) numProps += DuAEProperty.addToEGP( subProp );
            }
        } else {
            for ( var p = 1; p <= prop.numProperties; p++ ) {
                numProps += DuAEProperty.addToEGP( prop( p ) );
            }
        }
    }
    return numProps;
}

/**
 * Locks the property with an expression so its value cannot be changed
 * @memberof DuAEProperty
 * @param {PropertyBase|DuAEProperty|PropertyBase[]|DuAEProperty[]} properties - The property or properties
 */
DuAEProperty.lock = function ( properties ) {
    var it = new DuList( properties );
    it.do( function ( property ) {
        var p = property;
        var riggable = false;
        var dimensions = 0;
        if ( property instanceof DuAEProperty ) {
            p = property.getProperty();
            riggable = property.riggable;
            dimensions = property.dimensions;
        } else {
            riggable = DuAEProperty.isRiggable( p );
            dimensions = DuAEProperty.getDimensions( p );
        }

        if ( riggable ) {
            var exp = "";
            if ( dimensions == 0 ) exp = "value";
            else if ( dimensions == 1 ) exp = p.value.toString();
            else exp = p.value.toSource();
            DuAEProperty.setExpression( property, exp );
        }
    } );
}

/**
 * Removes the expression from the property, keeping the post-expression value.
 * @memberof DuAEProperty
 * @param {Property|DuAEProperty} prop - The property
 * @param {function} filter - A function which takes a string as a parameter (the expression). Returns true if the expression has to be removed.
 * @param {bool} [keepPostExpressionValue=true] Set to false to just remove the expressions and get back the pre expression value
 */
DuAEProperty.removeExpression = function ( prop, filter, keepPostExpressionValue ) {
    if ( typeof ( prop ) === 'undefined' ) return;
    keepPostExpressionValue = def (keepPostExpressionValue, true);

    var propInfo = new DuAEProperty( prop );
    prop = propInfo.getProperty();

    var expression = prop.expression;

    if ( expression == '' ) return;
    if (typeof filter === 'function') {
        if (!filter(expression )) return;
    }
    if ( propInfo.riggable ) {
        if (keepPostExpressionValue) DuAEProperty.setValue( prop, prop.value );
        prop.expression = '';
    }
}

/**
 * Checks if the property has an animation (keyframes)
 * @param {Property} prop - The property
 * @return {boolean} True if the property is animated
 */
DuAEProperty.isAnimated = function ( prop ) {
    if ( prop.canVaryOverTime ) {
        if ( prop.numKeys > 0 ) return true;
    }
    return false;
}

/**
 * Gets the After Effects animated (with keyframes) properties in the propertyGroup
 * @param {PropertyGroup}	 prop	- The parent propertyGroup where to search for animations
 * @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
 * A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
 * @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
 * @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
 * @return {DuAEProperty[]} The selected properties, an empty Array if nothing active or selected
 */
DuAEProperty.getAnimatedProps = function ( prop, filter, strict, caseSensitive ) {
    if ( strict == undefined ) strict = false;
    if ( caseSensitive == undefined ) caseSensitive = true;

    var props = [];

    if ( !caseSensitive && typeof filter === "string" ) filter = filter.toLowerCase();

    if ( prop.propertyType == PropertyType.PROPERTY && prop.matchName != 'ADBE Marker') {
        if ( DuAEProperty.isAnimated( prop ) ) {
            if ( typeof filter === 'undefined' ) {
                props.push( prop );
            } else {
                var name = prop.name;
                var matchName = prop.matchName;
                if ( !caseSensitive ) {
                    name = name.toLowerCase();
                    matchName = matchName.toLowerCase();
                }

                if ( strict && name === filter ) props.push( prop );
                else if ( strict && matchName === filter ) props.push( prop );
                else if ( typeof filter === 'string' ) {
                    if ( name.indexOf( filter ) >= 0 ) props.push( prop );
                    else if ( matchName.indexOf( filter ) >= 0 ) props.push( prop );
                } else if ( prop.propertyValueType == filter ) props.push( prop );
                else if ( typeof filter === 'function' ) {
                    if ( filter( prop ) ) props.push( prop );
                }
            }
        }
    } else {
        for ( var i = 0, num = prop.numProperties; i < num; i++ ) {
            props = props.concat( DuAEProperty.getAnimatedProps( prop.property( i + 1 ), filter, strict, caseSensitive ) );
        }
    }


    return DuAE.getDuAEProperty( props );
}


/**
 * Gets the value range of the animated property.<br >
 * The property type must be one of: one D, two D, three D (spatial or not), Color.
 * If the property is not one of these types, returns an empty Array.
 * @param {Property|DuAEProperty}	 prop	- The property
 * @param {int}	 [axis=0]	- The axis (or the color channel) to get the range
 * @param {bool}	 [preExpression=true]	- True to get the range from keyframes instead of the result of the exression
 * @param {bool}	 [fastMode=true]	- True to check the range with values only at keyframe times. False to check the range with all values, at each frame of the comp.
 * @return {float[]} The minimum and maximum value.<br />
 * The first item in the Array is not necesarily the lowest value, it is the first in time.
 */
DuAEProperty.getRange = function ( prop, axis, preExpression, fastMode ) {
    axis = def(axis, 0);
    preExpression = def(preExpression, true);
    fastMode = def(fastMode, true);

    var propInfo = new DuAEProperty( prop );
    prop = propInfo.getProperty();

    if ( !propInfo.numerical ) return [];

    if ( prop.expression == '' || !prop.expressionEnabled ) preExpression = true;

    var comp = propInfo.comp;
    var frames = comp.duration / comp.frameDuration;
    var min = prop.valueAtTime( 0, preExpression );
    var minTime = 0;
    var max = prop.valueAtTime( 0, preExpression );
    var maxTime = 0;

    if ( propInfo.dimensions > 1 ) {
        max = max[ axis ];
        min = min[ axis ];
    }

    var count = frames-1;
    if ( fastMode && prop.numKeys > 1 ) count = prop.numKeys;
    else count = comp.duration/4;

    if (count == 0) return [min, max];
    if (prop.numKeys < 2 && preExpression) return [min,max];

    for ( var i = 0; i < count; i++ ) {
        var iTime = i*0.25;
        if (fastMode && prop.numKeys > 1) iTime = prop.keyTime(i+1);
        var val = prop.valueAtTime( iTime, preExpression );
        if ( propInfo.dimensions > 1 ) val = val[ axis ];
        if ( val < min ) {
            min = val;
            minTime = i;
        }
        if ( val > max ) {
            max = val;
            maxTime = i;
        }
    }

    if ( minTime < maxTime ) return [ min, max ];
    else return [ max, min ];
}

/**
 * Gets the maximum velocity of the animated property.<br >
 * The property type must be one of: one D, two D, three D (spatial or not), Color.
 * If the property is not one of these types, returns 0.
 * @param {Property|DuAEProperty}	 prop	- The property
 * @param {bool}	 [preExpression=true]	- True to get the velocity from keyframes instead of the result of the exression
 * @param {bool}	 [fastMode=true]	- True to limit the number of samples used to compute the velocity and make the process faster.<br />
 * The number of samples is automatically adapted from the duration of the composition.<br />
 * When true and if there are more than one keyframe, the velocity is sampled only between keyframes.
 * @return {float} The velocity.
 */
DuAEProperty.getMaxVelocity = function ( prop, preExpression, fastMode ) {
    preExpression = def(preExpression, true);
    fastMode = def(fastMode, true);

    var propInfo = prop;
    if ( !( prop instanceof DuAEProperty ) ) {
        propInfo = new DuAEProperty( prop );
    } else {
        prop = propInfo.getProperty();
    }

    var velocity = 0;
    if ( !propInfo.numerical ) return velocity;

    if ( prop.expression == '' ) preExpression = true;

    var comp = propInfo.comp;
    var frames = comp.duration / comp.frameDuration;

    var startFrame = 0;
    var endFrame = frames;
    var step = 1;
    if (fastMode) {

        if (prop.numKeys > 1) {
            startFrame = prop.keyTime(1) / comp.frameDuration;
            endFrame = prop.keyTime(prop.numKeys) / comp.frameDuration;
        }
    }

    var numFrames = endFrame - startFrame;

    if (numFrames > 1000 && fastMode) {
        step = Math.floor( numFrames/500 );
    }

    for ( var i = startFrame; i < endFrame; i = i+step ) {
        var vel = DuAEProperty.getSpeed( prop, i * comp.frameDuration, preExpression );
        if ( vel > velocity ) velocity = vel;
    }

    return velocity;

}

/**
 * Gets the average speed of the animated propreties
 * @param {Property[]|DuAEProperty[]} props - The Properties
 * @param {bool}	 [preExpression=true]	- True to get the velocity from keyframes instead of the result of the exression
 * @param {bool}	 [fastMode=true]	- True to limit the number of samples used to compute the velocity and make the process faster.
 * @return {float} The average speed in unit per second
 */
DuAEProperty.getAverageSpeed = function ( props, preExpression, fastMode ) {
    preExpression = def(preExpression, true);
    fastMode = def(fastMode, true);

    var averageSpeed = 0;
    var count = 0;

    for ( var i = 0; i < props.length; i++ ) {
        var prop = props[ i ];
        if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
        if ( prop.propertyType != PropertyType.PROPERTY ) continue;
        if ( !prop.canVaryOverTime ) continue;
        if ( prop.numKeys < 1 && !preExpression ) continue;

        var comp = DuAEProperty.getComp( prop );
        var frames = comp.duration / comp.frameDuration;
        var lastTime = comp.duration;
        var firstTime = 0;
        if ( preExpression || (fastMode && prop.numKeys > 1) ) {
            lastTime = prop.keyTime( prop.numKeys );
            firstTime = prop.keyTime( 1 );
        }
        var lastFrame = lastTime / comp.frameDuration;
        var firstFrame = firstTime / comp.frameDuration;
        if ( lastFrame > frames ) lastFrames = frames;
        if ( firstFrame < 1 ) firstFrame = 1;

        var step = 1;
        if (fastMode) {
            var numFrames = lastFrame - firstFrame;
            if (numFrames > 1000) {
                step = Math.floor( numFrames/500 );
            }
        }
        
        var sum = 0;
        for ( var frame = firstFrame; frame < lastFrame; frame = frame + step ) {
            var time = frame * comp.frameDuration;
            sum += DuAEProperty.getSpeed( prop, time, preExpression );
        }
        var speed = sum / ( lastFrame - firstFrame );

        if ( speed > 0 ) {
            averageSpeed += speed;
            count++;
        }
    }

    averageSpeed = averageSpeed / count;
    return averageSpeed;
}


/**
 * Converts the expression as a string which can be copy/pasted and included in a script.
 * @param {Property|DuAEProperty|string} prop - The property containing the expression or the expression itself.
 * @param {string} [varName] - A name for the variable
 * @return {string} The stringified expression.
 */
DuAEProperty.scriptifyExpression = function ( prop, varName ) {
    varName = def( varName, '' );

    function line(str)
    {
        return "'" + str.replace( "\r", "" ).replace(/'/g , "\\'") + "'";
    }

    var propType = jstype( prop );
    var exp = '';
    if ( propType.toLowerCase() === 'string' ) exp = prop;
    else {
        if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
        var exp = prop.expression;
    }

    var expArray = exp.split( '\n' );
    var expString = "";
    if ( varName != '' ) expString += "var " + varName + " = ";

    expString += "[" + line( expArray[0] );

    for ( var i = 1; i < expArray.length; i++ ) {
        expString += ",\n\t" + line( expArray[i] );
    }
    expString += "\n\t].join('\\n');";

    return expString;
}

/**
 * Puppet tool methods
 * @namespace
 * @memberof DuAEProperty
 */
DuAEProperty.PuppetTool = {};

/**
 * Checks if a pin can be rigged or not.\nFor now, the only pins which can not be rigged are starch pins.
 * @param {PropertyGroup} pin - The pin to test
 * @return {boolean} True if this pin has either a position, rotation or scale property
 */
DuAEProperty.PuppetTool.isRiggable = function ( pin ) {
    if ( pin.position.canSetExpression ) return true;
    if ( pin.rotation.canSetExpression ) return true;
    if ( pin.scale.canSetExpression ) return true;
    return false;
}

/**
 * Bezier Path methods
 * @namespace
 * @memberof DuAEProperty
 */
DuAEProperty.Bezier = {};

/**
 * Scriptifies the given shape property.<br/>
 * @param {Property}	 [shapeProp]	- The path property to export
 * @param {boolean}	[offsetToCenter=false]	- If true, offset the path to the center
 * @param {string}	[varName=shape]	- A name for the variable storing the shape
 * @return {string} The scriptified shape
 */
DuAEProperty.Bezier.scriptify = function ( pathProperty, offsetToCenter, varName ) {
    if ( pathProperty instanceof DuAEProperty ) pathProperty = pathProperty.getProperty();
    offsetToCenter = def( offsetToCenter, false );
    varName = def( varName, 'shape' );

    if ( pathProperty.propertyType !== PropertyType.PROPERTY ) throw "Expected a shape property, got a group.";
    if ( pathProperty.propertyValueType !== PropertyValueType.SHAPE ) throw "Expected a shape property, got another type of value.";
    offsetToCenter = def( offsetToCenter, false );

    var shape = pathProperty.value;
    var vertices = shape.vertices;

    if ( offsetToCenter ) {
        //get center and offset
        var sum = [ 0, 0 ];
        for ( var i = 0; i < vertices.length; i++ ) {
            sum[ 0 ] += vertices[ i ][ 0 ];
            sum[ 1 ] += vertices[ i ][ 1 ];
        }
        var center = sum / vertices.length;
        //adjust values
        for ( var i = 0; i < vertices.length; i++ ) {
            vertices[ i ][ 0 ] -= center[ 0 ];
            vertices[ i ][ 1 ] -= center[ 1 ];
        }
    }

    var verticesStr = vertices.toSource();
    var inTangentsStr = shape.inTangents.toSource();
    var outTangentsStr = shape.outTangents.toSource();
    var closedStr = shape.closed ? 'true' : 'false';

    var scriptified = [
        'var ' + varName + ' = new Shape();',
        varName + '.vertices = ' + verticesStr + ';',
        varName + '.inTangents = ' + inTangentsStr + ';',
        varName + '.outTangents = ' + outTangentsStr + ';',
        varName + '.closed = ' + closedStr + ';'
    ].join( '\n' );

    return scriptified;
}

/**
 * Export the given shape property to the given file <br/>
 * The file name in the given path will be used to name the shape in the jsx code
 * @example
 * var props = DuAEComp.getSelectedProps(PropertyValueType.SHAPE);
 * var prop = props[0].getProperty();
 * var out = DuAEProperty.Shape.exportToJsxinc(prop, "D:/shape.test");
 * @param {Property}	 [shapeProp]	- The path property to export
 * @param {String}	[file]	- The path or File where the jsxinc shape will be written
 * @param {boolean}	[offsetToCenter=false]	- If true, offset the path to the center
 * @param {boolean}	[append=false]	- If true, appends the shape at the end of the file instead of overwriting it.
 * @param {string}	[varName=shape]	- A name for the variable storing the shape
 * @return {int} A status code. [0: success, ...]
 */
DuAEProperty.Bezier.exportToJsxinc = function ( pathProperty, file, offsetToCenter, append, varName ) {
    append = def( append, false );

    if ( !( file instanceof File ) ) file = new File( file );

    var mode = 'w';
    if ( append ) mode = 'a';

    if ( !file.open( mode ) ) return 3;

    if ( append ) file.write( '\n' );
    file.write( DuAEProperty.Bezier.scriptify( pathProperty, offsetToCenter, varName ) );

    file.close();
    return 0;
}

/**
 * Makes a horizontal symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
 * @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
 */
DuAEProperty.Bezier.horizontalSymetry = function ( pathProperties ) {
    if ( !( pathProperties instanceof Array ) ) pathProperties = [ pathProperties ];

    var shapes = [];
    //get shapes and center
    var center = 0;
    var verticesCount = 0;
    for ( var i = 0; i < pathProperties.length; i++ ) {
        var prop = pathProperties[ i ];
        if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
        var shape = prop.value;
        shapes.push( shape );
        for ( var j = 0; j < shape.vertices.length; j++ ) {
            verticesCount++;
            center += shape.vertices[ j ][ 0 ];
        }
    }
    center = center / verticesCount;
    center = center * 2;

    //compute
    for ( var i = 0; i < shapes.length; i++ ) {
        var prop = pathProperties[ i ];
        if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
        var shape = shapes[ i ];
        var vertices = shape.vertices;
        var inTangents = shape.inTangents;
        var outTangents = shape.outTangents;
        for ( var j = 0; j < shape.vertices.length; j++ ) {
            vertices[ j ][ 0 ] = center - vertices[ j ][ 0 ];
            inTangents[ j ][ 0 ] = -inTangents[ j ][ 0 ];
            outTangents[ j ][ 0 ] = -outTangents[ j ][ 0 ];
        }
        shape.vertices = vertices;
        shape.inTangents = inTangents;
        shape.outTangents = outTangents;
        if ( prop.numKeys > 0 ) {
            prop.setValueAtTime( DuAEProperty.getComp( prop ).time, shape );
        } else {
            prop.setValue( shape );
        }
    }
}

/**
 * Makes a vertical symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
 * @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
 */
DuAEProperty.Bezier.verticalSymetry = function ( pathProperties ) {
    if ( !( pathProperties instanceof Array ) ) pathProperties = [ pathProperties ];

    var shapes = [];
    //get shapes and center
    var center = 0;
    var verticesCount = 0;
    for ( var i = 0; i < pathProperties.length; i++ ) {
        var prop = pathProperties[ i ];
        if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
        var shape = prop.value;
        shapes.push( shape );
        for ( var j = 0; j < shape.vertices.length; j++ ) {
            verticesCount++;
            center += shape.vertices[ j ][ 1 ];
        }
    }
    center = center / verticesCount;
    center = center * 2;

    //compute
    for ( var i = 0; i < shapes.length; i++ ) {
        var prop = pathProperties[ i ];
        if ( prop instanceof DuAEProperty ) prop = prop.getProperty();
        var shape = shapes[ i ];
        var vertices = shape.vertices;
        var inTangents = shape.inTangents;
        var outTangents = shape.outTangents;
        for ( var j = 0; j < shape.vertices.length; j++ ) {
            vertices[ j ][ 1 ] = center - vertices[ j ][ 1 ];
            inTangents[ j ][ 1 ] = -inTangents[ j ][ 1 ];
            outTangents[ j ][ 1 ] = -outTangents[ j ][ 1 ];
        }
        shape.vertices = vertices;
        shape.inTangents = inTangents;
        shape.outTangents = outTangents;
        if ( prop.numKeys > 0 ) {
            prop.setValueAtTime( DuAEProperty.getComp( prop ).time, shape );
        } else {
            prop.setValue( shape );
        }
    }
}

/**
 * Gets the vertices array in comp coordinates.
 * @param {Property|DuAEProperty} prop - The property, a bezier path.
 * @return {float[][]} The vertices in comp coordinates.
 */
DuAEProperty.Bezier.verticesToComp = function ( pathProperty ) {
    var propInfo = DuAEProperty.Bezier.checkProperty( pathProperty );
    if ( !propInfo ) throw "Expected a shape property, got another type of value.";
    var pathProperty = propInfo.getProperty();

    //get the layer matrix
    var matrix = DuAE.Shape.getTransformMatrix( propInfo );

    //apply transform
    var vertices = [];
    var origin = pathProperty.value.vertices;
    for ( var i = 0, num = origin.length; i < num; i++ ) {
        vertices.push( matrix.applyToPoint( origin[ i ] ) );
    }

    return vertices;
}

/**
 * Checks if the property is a bezier property, or return the child bezier property if this is a shape or a mask
 * @param {Property|DuAEProperty} prop - The property
 * @return {DuAEProperty|null} the bezier property or null if it is not.
 */
DuAEProperty.Bezier.checkProperty = function ( prop ) {
    propInfo = new DuAEProperty( prop );
    prop = propInfo.getProperty();

    //get the path property in case it was a mask or a shape path selected
    if ( prop.matchName == "ADBE Vector Shape - Group" ) {
        prop = prop.property( "ADBE Vector Shape" );
        return new DuAEProperty( prop );
    } else if ( prop.matchName == "ADBE Mask Atom" ) {
        prop = prop.property( "ADBE Mask Shape" );
        return new DuAEProperty( prop );
    } else if ( prop.propertyType !== PropertyType.PROPERTY ) return null;
    if ( prop.propertyValueType !== PropertyValueType.SHAPE ) return null;

    return propInfo;
}

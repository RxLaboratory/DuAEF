/* License
	DuAEF_DuExpressionLib

	Copyright (c) 2020 Nicolas Dufresne, Rainbox Laboratory

	This file is part of DuExpression - The Duduf Expression Library.

		DuExpression is free software: you can redistribute it and/or modify
		it under the terms of the GNU General Public License as published by
		the Free Software Foundation, either version 3 of the License, or
		(at your option) any later version.

		DuExpression is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		GNU General Public License for more details.

		You should have received a copy of the GNU General Public License
		along with DuExpression. If not, see <http://www.gnu.org/licenses/>.
*/

/*
    This script can be included in any other script and can be used to easily include Functions from the Duduf Expression Library into your own expressions.
    It is also available in DuAEF, along with some useful functions to help you include requirements when adding a function to your expressions.
*/

if (typeof DuAEF === "undefined") DuAEF = {};
if (typeof DuAEF.DuExpression === "undefined") DuAEF.DuExpression = {};

/**
* Expression Library
* @namespace
* @memberof DuAEF.DuExpression
*/
DuAEF.DuExpression.Library = [];

/**
  * Fuzzy Logics for expressions. See {@link https://github.com/Nico-Duduf/DuFuzzyLogic} for more explanations
  * @class
  * @classdesc Fuzzy Logics for expressions. See {@link https://github.com/Nico-Duduf/DuFuzzyLogic} for more explanations
  * @author Duduf
  * @license GPL-v3
  * @copyright Duduf 2020
  * @requires logistic
  * @requires inverseLogistic
  * @requires gaussian
  * @requires inverseGaussian
*/
DuAEF.DuExpression.Library["FuzzyLogic"] = {};
DuAEF.DuExpression.Library["FuzzyLogic"].expression = ['function FuzzySet( name, valueNot, valueIS, shape, shapeAbove, plateauMin, plateauMax)',
	'{',
	'var min;',
	'var max;',
	'if (valueNot > valueIS){',
	'max = valueNot;',
	'min = valueNot - (valueNot - valueIS) * 2;',
	'}',
	'else',
	'{',
	'min = valueNot;',
	'max = valueNot + (valueIS - valueNot) * 2;',
	'}',
	'if (typeof shape === "undefined") shape = "linear";',
	'if (typeof shapeAbove === "undefined") shapeAbove = shape;',
	'if (typeof plateauMin === "undefined") plateauMin = mean([min, max]);',
	'if (typeof plateauMax === "undefined") plateauMax = mean([min, max]);',
	'this.min = min;',
	'this.max = max;',
	'this.shapeIn = shape;',
	'this.shapeOut = shapeAbove;',
	'this.plateauMin = plateauMin;',
	'this.plateauMax = plateauMax;',
	'this.name = name;',
	'}',
	'FuzzySet.prototype = {',
	'contains: function ( v, quantifier )',
	'{',
	'var val;',
	'if (v instanceof FuzzyValue) val = v.crispify(false);',
	'else val = v;',
	'quantifier = getQuantifier(quantifier);',
	'if (val >= this.plateauMin && val <= this.plateauMax)',
	'{',
	'return quantifier(1);',
	'}',
	'else if (val < this.plateauMin)',
	'{',
	'if (this.shapeIn === "constant")',
	'{',
	'return quantifier(1);',
	'}',
	'else if (this.shapeIn === "square")',
	'{',
	'var min = mean(this.plateauMin, this.min);',
	'if (val >= min) return quantifier(1);',
	'else return quantifier(0);',
	'}',
	'else if (this.shapeIn === "linear")',
	'{',
	'if (val < this.min) return quantifier(0);',
	'else return quantifier( (val-this.min) / (this.plateauMin - this.min) );',
	'}',
	'else if (this.shapeIn === "sigmoid")',
	'{',
	'var mid = (this.plateauMin + this.min) / 2;',
	'var rate = 6 / (this.plateauMin - this.min);',
	'return quantifier(logistic(val, mid, 0, 1, rate));',
	'}',
	'else if (this.shapeIn === "gaussian")',
	'{',
	'var width = this.plateauMin - this.min;',
	'return quantifier( gaussian( val, 0, 1, this.plateauMin, width));',
	'}',
	'else return quantifier(0);',
	'}',
	'else',
	'{',
	'if (this.shapeOut === "constant")',
	'{',
	'return quantifier(1);',
	'}',
	'else if (this.shapeOut === "square")',
	'{',
	'var max = mean(this.plateauMax, this.max);',
	'if (val <= max) return quantifier(1);',
	'else return quantifier(0);',
	'}',
	'else if (this.shapeOut === "linear")',
	'{',
	'if (val > this.max) return quantifier(0);',
	'else return quantifier (1 - ((val - this.plateauMax ) / (this.max - this.plateauMax) ));',
	'}',
	'else if (this.shapeOut === "sigmoid")',
	'{',
	'var mid = (this.plateauMax + this.max) / 2;',
	'var rate = 6 / (this.max - this.plateauMax);',
	'return quantifier( 1 - logistic(val, mid, 0, 1, rate));',
	'}',
	'else if (this.shapeOut === "gaussian")',
	'{',
	'var width = this.max - this.plateauMax;',
	'return quantifier( gaussian( val, 0, 1, this.plateauMax, width) );',
	'}',
	'else return quantifier(0);',
	'}',
	'},',
	'getValues: function ( veracity )',
	'{',
	'if (typeof veracity === "undefined") veracity = 0.5;',
	'if (veracity instanceof FuzzyVeracity) veracity = veracity.veracity;',
	'var defaultValue = mean( [this.plateauMin, this.plateauMax] );',
	'if ( this.shapeIn === "constant" && this.shapeOut === "constant" ) return [ this.min, this.plateauMin, defaultValue, this.plateauMax, this.max];',
	'var crisp = [];',
	'if (veracity >= 1) crisp = [this.plateauMin, defaultValue, this.plateauMax];',
	'if (this.shapeIn === "constant" && veracity == 1)',
	'{',
	'crisp.push(this.min);',
	'}',
	'else if (this.shapeIn === "square")',
	'{',
	'if (veracity >= 0.5) crisp.push( this.plateauMin );',
	'else crisp.push( this.min );',
	'}',
	'else if (this.shapeIn === "linear")',
	'{',
	'range = this.plateauMin - this.min;',
	'crisp.push( this.min + range * veracity );',
	'}',
	'else if (this.shapeIn === "sigmoid")',
	'{',
	'mid = (this.plateauMin + this.min) / 2;',
	'crisp.push( inverseLogistic(veracity, mid) );',
	'}',
	'else if (this.shapeIn === "gaussian")',
	'{',
	'var width = this.plateauMin - this.min;',
	'var g = inverseGaussian( veracity, 0, 1, this.plateauMin, width);',
	'crisp.push( g[0] );',
	'}',
	'if (this.shapeOut === "constant" && veracity == 1)',
	'{',
	'crisp.push(this.max);',
	'}',
	'if (this.shapeOut === "square")',
	'{',
	'if (veracity >= 0.5) crisp.push( this.plateauMax );',
	'else crisp.push( this.max );',
	'}',
	'else if (this.shapeOut === "linear")',
	'{',
	'range = this.max - this.plateauMax;',
	'crisp.push( this.max + 1 - (range * veracity) );',
	'}',
	'else if (this.shapeOut === "sigmoid")',
	'{',
	'mid = (this.plateauMax + this.max) / 2;',
	'crisp.push( inverseLogistic( 1-veracity, mid, 0, 1 ) );',
	'}',
	'else if (this.shapeOut === "gaussian")',
	'{',
	'width = this.max - this.plateauMax;',
	'var g = inverseGaussian( 1-veracity, 0, 1, this.plateauMax, width);',
	'crisp.push( g[1] );',
	'}',
	'for(var i = 0, num = crisp.length; i < num; i++)',
	'{',
	'if ( crisp[i] > this.max ) crisp[i] = this.max;',
	'if ( crisp[i] < this.min ) crisp[i] = this.min;',
	'}',
	'return crisp.sort();',
	'},',
	'crispify: function ( quantifier, veracity )',
	'{',
	'quantifier = getQuantifier(quantifier);',
	'var v;',
	'if (typeof veracity === "undefined") v = quantifier();',
	'else if (veracity instanceof FuzzyVeracity) v = veracity.veracity;',
	'else v = veracity;',
	'v = quantifier(v, true).veracity;',
	'return this.getValues( v );',
	'}',
	'};',
	'function FuzzyValue( val )',
	'{',
	'if (typeof unit === "undefined") unit = "";',
	'if (typeof val === "undefined") val = 0;',
	'this.val = val;',
	'this.sets = [];',
	'this.report = [];',
	'this.reportEnabled = false;',
	'this.numRules = 0;',
	'}',
	'FuzzyValue.prototype = {',
	'IS: function(fuzzyset, quantifier)',
	'{',
	'var v = fuzzyset.contains( this, quantifier );',
	'return v;',
	'},',
	'IS_NOT: function (fuzzyset, quantifier)',
	'{',
	'var x = fuzzyset.contains( this.val, quantifier );',
	'return x.NEGATE();',
	'},',
	'SET: function ( fuzzyset,  quantifier, v )',
	'{',
	'if (typeof v === "undefined") v = new FuzzyVeracity(1);',
	'quantifier = getQuantifier(quantifier);',
	'this.numRules++;',
	'v.ruleNum = this.numRules;',
	'for (var i = 0, num = this.sets.length; i < num; i++)',
	'{',
	'if (fuzzyset.name == this.sets[i].name)',
	'{',
	'this.sets[i].quantifiers.push(quantifier);',
	'this.sets[i].veracities.push(v);',
	'return;',
	'}',
	'}',
	'fuzzyset.quantifiers = [quantifier];',
	'fuzzyset.veracities = [v];',
	'this.sets.push( fuzzyset );',
	'},',
	'crispify: function ( clearSets )',
	'{',
	'if (typeof clearSets === "undefined") clearSets = true;',
	'if (this.sets.length == 0) return this.val;',
	'var crisp = 0;',
	'this.report = [];',
	'function ruleSorter(a, b)',
	'{',
	'return a.number - b.number;',
	'}',
	'var sumWeights = 0;',
	'for (var i = 0, num = this.sets.length; i < num; i++)',
	'{',
	'var fuzzyset = this.sets[i];',
	'for( var j = 0, numV = fuzzyset.veracities.length; j < numV; j++)',
	'{',
	'var v = fuzzyset.veracities[j];',
	'var q = fuzzyset.quantifiers[j];',
	'var vals = fuzzyset.crispify( q, v );',
	'var val;',
	'var ver;',
	'val = mean(vals);',
	'crisp += val * v.veracity;',
	'ver = v.veracity;',
	'sumWeights += ver;',
	'if (this.reportEnabled)',
	'{',
	'for (var iVals = 0, numVals = vals.length; iVals < numVals; iVals++)',
	'{',
	'vals[iVals] = Math.round(vals[iVals]*1000)/1000;',
	'}',
	'var reportRule = [];',
	'reportRule.push( "Rule #" + v.ruleNum +": Set " + fuzzyset.toString() + " (" + q.toString() + ")" );',
	'reportRule.push( "Gives val: " + Math.round(val*1000)/1000 + " from these values: [ " + vals.join(", ") + " ]");',
	'reportRule.push( "With a veracity of: " + Math.round(ver*1000)/1000 );',
	'reportRule.number = v.ruleNum;',
	'this.report.push( reportRule );',
	'}',
	'}',
	'}',
	'if (sumWeights != 0) crisp = crisp / sumWeights;',
	'if (this.reportEnabled) this.report.sort(ruleSorter);',
	'if (clearSets)',
	'{',
	'this.val = crisp;',
	'this.sets = [];',
	'}',
	'return crisp;',
	'},',
	'toNumber: this.crispify,',
	'toFloat: this.crispify,',
	'defuzzify: this.crispify',
	'};',
	'function FuzzyVeracity( veracity )',
	'{',
	'if (typeof above === "undefined") above = false;',
	'this.veracity = veracity;',
	'}',
	'FuzzyVeracity.prototype = {',
	'NEGATE: function()',
	'{',
	'return new FuzzyVeracity( 1 - this.veracity );',
	'},',
	'AND: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = Math.min(x, y);',
	'return new FuzzyVeracity( v );',
	'},',
	'OR: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = Math.max(x, y);',
	'return new FuzzyVeracity( v );',
	'},',
	'XOR: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = x+y - 2*Math.min(x,y);',
	'return new FuzzyVeracity( v );',
	'},',
	'IS_NOT: this.XOR,',
	'DIFFERENT: this.XOR,',
	'NXR: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = 1-x-y + 2*Math.min(x,y);',
	'return new FuzzyVeracity( v );',
	'},',
	'IS: this.NXR,',
	'EQUALS: this.NXR,',
	'IMPLIES: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = 1-Math.min(x, 1-y);',
	'return new FuzzyVeracity( v );',
	'},',
	'WITH: this.IMPLIES,',
	'HAS: this.IMPLIES,',
	'DOES_NOT_IMPLY: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = Math.min(x, 1-y);',
	'return new FuzzyVeracity( v );',
	'},',
	'WITHOUT: this.DOES_NOT_IMPLY,',
	'DOES_NOT_HAVE: this.DOES_NOT_IMPLY,',
	'NAND: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = 1 - Math.min(x, y);',
	'return new FuzzyVeracity( v );',
	'},',
	'NOT_BOTH: this.NAND,',
	'NOR: function( other )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = 0;',
	'v = 1 - Math.max(x, y);',
	'return new FuzzyVeracity( v );',
	'},',
	'NONE: this.NOR,',
	'WEIGHTED: function( other, weight )',
	'{',
	'var x = this.veracity;',
	'var y = other.veracity;',
	'var v = (1-w)*x +  w*y;',
	'return new FuzzyVeracity( v );',
	'}',
	'};',
	'function FuzzyLogic( )',
	'{',
	'this.veracity = new FuzzyVeracity(0);',
	'}',
	'FuzzyLogic.prototype = {',
	'newValue: function (val, unit)',
	'{',
	'return new FuzzyValue( val, unit );',
	'},',
	'newVeracity: function (veracity)',
	'{',
	'return new FuzzyVeracity(veracity);',
	'},',
	'newSet: function ( name, extremeValue, referenceValue, shape, shapeAbove, plateauMin, plateauMax)',
	'{',
	'return new FuzzySet(name, extremeValue, referenceValue, shape, shapeAbove, plateauMin, plateauMax);',
	'},',
	'IF: function ( veracity )',
	'{',
	'this.veracity = veracity;',
	'return veracity;',
	'},',
	'THEN: function ( val, fuzzyset, quantifier )',
	'{',
	'val.SET(fuzzyset, quantifier, this.veracity);',
	'}',
	'};',
	'function getQuantifier( name )',
	'{',
	'if (typeof name === "undefined") name = "moderately";',
	'if (name == "not" || name == "less") {',
	'function qObj (v, inverse) {',
	'if (typeof v === "undefined") return 0;',
	'var p = inverse ? 0 : 1;',
	'return new FuzzyVeracity( p );',
	'}',
	'return qObj;',
	'}',
	'if (name == "slightly") return createQuantifier( 1/3 );',
	'if (name == "somewhat") return createQuantifier( 0.5 );',
	'if (name == "moderately") return createQuantifier( 1 );',
	'if (name == "very") return createQuantifier( 2 );',
	'if (name == "extremely") return createQuantifier( 3 );',
	'function qObj (v, inverse) {',
	'if (typeof v === "undefined") return 1;',
	'var p = inverse ? 1 : 0;',
	'return new FuzzyVeracity( p );',
	'}',
	'return qObj;',
	'}',
	'function createQuantifier( q )',
	'{',
	'function qObj (v, inverse) {',
	'if (typeof v === "undefined") return Math.pow( 0.5, 1/q);',
	'var p = inverse ? 1/q : q;',
	'return new FuzzyVeracity( Math.pow(v, p) );',
	'}',
	'return qObj;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["FuzzyLogic"].requirements = ["logistic","inverseLogistic","gaussian","inverseGaussian"];

/**
 * Interpolates a value with a bezier curve.<br />
 * This method can replace <code>linear()</code> and <code>ease()</code> with a custom b�zier interpolation.
 * @function
 * @param {number} t The value to interpolate
 * @param {number} [tMin=0] The minimum value of the initial range
 * @param {number} [tMax=1] The maximum value of the initial range
 * @param {number} [value1=0] The minimum value of the interpolated result
 * @param {number} [value2=1] The maximum value of the interpolated result
 * @param {number[]} [bezierPoints=[0.33,0.0,0.66,1.0]] an Array of 4 coordinates wihtin the [0.0, 1.0] range which describes the B�zier interpolation. The default mimics the native ease() function<br />
 * [ outTangentX, outTangentY, inTangentX, inTangentY ]
 * @return {number} the value.
 */
DuAEF.DuExpression.Library["bezierInterpolation"] = {};
DuAEF.DuExpression.Library["bezierInterpolation"].expression = ['function bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {',
	'if (arguments.length !== 5 && arguments.length !== 6) return t;',
	'var a = value2 - value1;',
	'var b = tMax - tMin;',
	'if (b == 0) return t;',
	'var c = clamp((t - tMin) / b, 0, 1);',
	'if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4) bezierPoints = [0.33,0.0,0.66,1];',
	'return a * h(c, bezierPoints) + value1;',
	'function h(f, g) {',
	'var x = 3 * g[0];',
	'var j = 3 * (g[2] - g[0]) - x;',
	'var k = 1 - x - j;',
	'var l = 3 * g[1];',
	'var m = 3 * (g[3] - g[1]) - l;',
	'var n = 1 - l - m;',
	'var d = f;',
	'for (var i = 0; i < 5; i++) {',
	'var z = d * (x + d * (j + d * k)) - f;',
	'if (Math.abs(z) < 1e-3) break;',
	'd -= z / (x + d * (2 * j + 3 * k * d));',
	'}',
	'return d * (l + d * (m + d * n));',
	'}',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["bezierInterpolation"].requirements = [];

/**
 * Interpolates a value with a gaussian function.<br />
 * This method can replace <code>linear()</code> and <code>ease()</code> with a gaussian interpolation.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} t The value to interpolate
 * @param {number} [tMin=0] The minimum value of the initial range
 * @param {number} [tMax=1] The maximum value of the initial range
 * @param {number} [value1=0] The minimum value of the interpolated result
 * @param {number} [value2=1] The maximum value of the interpolated result
 * @param {number} [rate=0] The raising speed in the range [-1.0, 1.0].
 * @return {number} the value.
 */
DuAEF.DuExpression.Library["gaussianInterpolation"] = {};
DuAEF.DuExpression.Library["gaussianInterpolation"].expression = ['function gaussianInterpolation( t, tMin, tMax, value1, value2, rate )',
	'{',
	'if (t != tMin)',
	'{',
	'var newValue1 = gaussianInterpolation( tMin, tMin, tMax, value1, value2, rate );',
	'var offset = newValue1 - value1;',
	'value1 = value1 - offset;',
	'}',
	'if (rate < 0) rate = rate*10;',
	'rate = linear(t, tMin, tMax, 0.25, rate);',
	'var r = ( 1 - rate );',
	'var fwhm = (tMax-tMin) * r;',
	'var center = tMax;',
	'if (t >= tMax) return value2;',
	'if (fwhm === 0 && t == center) return value2;',
	'else if (fwhm === 0) return value1;',
	'var exp = -4 * Math.LN2;',
	'exp *= Math.pow((t - center),2);',
	'exp *= 1/ Math.pow(fwhm, 2);',
	'var result = Math.pow(Math.E, exp);',
	'result = result * (value2-value1) + value1;',
	'return result;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["gaussianInterpolation"].requirements = [];

/**
 * Gets the key immediately after the given time<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] Time at which to get the key
 * @return {Key|null} The key, or null if there's no key before.
 */
DuAEF.DuExpression.Library["getNextKey"] = {};
DuAEF.DuExpression.Library["getNextKey"].expression = ['function getNextKey(t) {',
	'if (numKeys == 0) return null;',
	'var nKey = nearestKey(t);',
	'if (nKey.time >= t) return nKey;',
	'if (nKey.index < numKeys) return key(nKey.index + 1);',
	'return null;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getNextKey"].requirements = [];

/**
 * Gets the key immediately before the given time<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] Time at which to get the key
 * @return {Key|null} The key, or null if there's no key before.
 */
DuAEF.DuExpression.Library["getPrevKey"] = {};
DuAEF.DuExpression.Library["getPrevKey"].expression = ['function getPrevKey(t) {',
	'if (numKeys == 0) return null;',
	'var nKey = nearestKey(t);',
	'if (nKey.time <= t) return nKey;',
	'if (nKey.index > 1) return key(nKey.index - 1);',
	'return null;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getPrevKey"].requirements = [];

/**
 * Checks if current time is after the time of the last key in the property
 * @function
 * @return {boolean} true if time is > lastkey.time
 */
DuAEF.DuExpression.Library["isAfterLastKey"] = {};
DuAEF.DuExpression.Library["isAfterLastKey"].expression = ['function isAfterLastKey() {',
	'if (numKeys == 0) return false;',
	'var nKey = nearestKey(time);',
	'return nKey.time <= time && nKey.index == numKeys;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["isAfterLastKey"].requirements = [];

/**
    * The gaussian function<br />
    * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
    * @function
    * @param {Number} value The variable
    * @param {Number} [min=0] The minimum return value
    * @param {Number} [max=1] The maximum return value
    * @param {Number} [center=0] The center of the peak
    * @param {Number} [fwhm=1] The full width at half maximum of the curve
    * @return {Number} The result
    */
DuAEF.DuExpression.Library["gaussian"] = {};
DuAEF.DuExpression.Library["gaussian"].expression = ['function gaussian( value, min, max, center, fwhm)',
	'{',
	'if (fwhm === 0 && value == center) return max;',
	'else if (fwhm === 0) return 0;',
	'var exp = -4 * Math.LN2;',
	'exp *= Math.pow((value - center),2);',
	'exp *= 1/ Math.pow(fwhm, 2);',
	'var result = Math.pow(Math.E, exp);',
	'return result * (max-min) + min;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["gaussian"].requirements = [];

/**
    * The inverse gaussian function<br />
    * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
    * @function
    * @param {Number} v The variable
    * @param {Number} [min=0] The minimum return value of the corresponding gaussian function
    * @param {Number} [max=1] The maximum return value of the corresponding gaussian function
    * @param {Number} [center=0] The center of the peak of the corresponding gaussian function
    * @param {Number} [fwhm=1] The full width at half maximum of the curve of the corresponding gaussian function
    * @return {Number[]} The two possible results, the lower is the first in the list. If both are the same, it is the maximum
    */
DuAEF.DuExpression.Library["inverseGaussian"] = {};
DuAEF.DuExpression.Library["inverseGaussian"].expression = ['function inverseGaussian ( v, min, max, center, fwhm)',
	'{',
	'if (v == 1) return [center, center];',
	'if (v === 0) return [center + fwhm/2, center - fwhm/2];',
	'if (fwhm === 0) return [center, center];',
	'var result = (v-min)/(max-min);',
	'result = Math.log( result ) * Math.pow(fwhm,2);',
	'result = result / ( -4 * Math.LN2 );',
	'result = Math.sqrt( result );',
	'return [ result + center, -result + center ];',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["inverseGaussian"].requirements = [];

/**
    * The inverse logistic function (inverse sigmoid)<br />
    * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.    * @function
    * @param {Number} v The variable
    * @param {Number} [midValue=0] The midpoint value, at which the function returns max/2 in the original logistic function
    * @param {Number} [min=0] The minimum return value of the original logistic function
    * @param {Number} [max=1] The maximum return value of the original logistic function
    * @param {Number} [rate=1] The logistic growth rate or steepness of the original logistic function
    * @return {Number} The result
    */
DuAEF.DuExpression.Library["inverseLogisitic"] = {};
DuAEF.DuExpression.Library["inverseLogisitic"].expression = ['function inverseLogistic ( v, midValue, min, max, rate)',
	'{',
	'if (v == min) return 0;',
	'return midValue - Math.log( (max-min)/(v-min) - 1) / rate;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["inverseLogisitic"].requirements = [];

/**
    * The logistic function (sigmoid)<br />
    * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
    * @function
    * @param {Number} value The value
    * @param {Number} [midValue=0] The midpoint value, at which the function returns max/2
    * @param {Number} [min=0] The minimum return value
    * @param {Number} [max=1] The maximum return value
    * @param {Number} [rate=1] The logistic growth rate or steepness of the function
    * @return {Number} The result in the range [min, max] (excluding min and max)
    */
DuAEF.DuExpression.Library["logisitic"] = {};
DuAEF.DuExpression.Library["logisitic"].expression = ['function logistic( value, midValue, min, max, rate)',
	'{',
	'var exp = -rate*(value - midValue);',
	'var result = 1 / (1 + Math.pow(Math.E, exp));',
	'return result * (max-min) + min;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["logisitic"].requirements = [];

/**
    * Returns the mean of a set of values
    * @function
    * @param {Number[]} values The values
    * @return {Number} The mean
    */
DuAEF.DuExpression.Library["mean"] = {};
DuAEF.DuExpression.Library["mean"].expression = ['function mean( values )',
	'{',
	'var num = values.length;',
	'var result = 0;',
	'for (var i = 0; i < num; i++)',
	'{',
	'result += values[i];',
	'}',
	'return result / num;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["mean"].requirements = [];

/**
    * Fix for the ExtendScript engine, implements the Math.sign function.
    * @function
    * @name Math.sign
    * @param {Number} x The value
    * @return {Number} The sign, 1, -1 or 0.
    */
DuAEF.DuExpression.Library["sign"] = {};
DuAEF.DuExpression.Library["sign"].expression = ['if (typeof Math.sign === \'undefined\') Math.sign = function(x) { return ((x > 0) - (x < 0)) || +x; };'
	].join('\n');
DuAEF.DuExpression.Library["sign"].requirements = [];

/**
 * Checks the type of a pseudo-effect used by Duik.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * Pseudo-Effects used by Duik start with a hidden property which name is the same as the matchName of the effect itself (without the 'Pseudo/' part).
 * @function
 * @example
 * if ( checkEffect(thisLayer.effect(1), "DUIK parentConstraint2") ) { "This is the second version of the parent constraint by Duik" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {string} duikMatchName The matchName of a pseudo-effect used by Duik (without the 'Pseudo/' part)
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.DuExpression.Library["checkDuikEffect"] = {};
DuAEF.DuExpression.Library["checkDuikEffect"].expression = ['function checkDuikEffect(fx, duikMatchName) {',
	'if (fx.numProperties  < 3) return false;',
	'if (!!$.engineName) {',
	'if ( fx(2).name != duikMatchName ) return false;',
	'}',
	'else {',
	'try { if (fx(2).name != duikMatchName) return false; }',
	'catch (e) { return false; }',
	'}',
	'return true;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["checkDuikEffect"].requirements = [];

/**
 * Checks the type of an effect.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * It checks if the given effect has a specific property at a specific index.
 * @function
 * @example
 * if ( checkEffect(thisLayer.effect(1), 1, "Blur") ) { "The first effect is a blur!" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {int} propIndex The index of the property
 * @param {string} propName The expected name of the property. Be careful with the internationalization of After Effects...
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.DuExpression.Library["checkEffect"] = {};
DuAEF.DuExpression.Library["checkEffect"].expression = ['function checkEffect(fx, propIndex, propName) {',
	'if (fx.numProperties  < propIndex) return false;',
	'if (!!$.engineName) {',
	'if ( fx(propIndex).name != propName ) return false;',
	'}',
	'else {',
	'try { if (fx(propIndex).name != propName) return false; }',
	'catch (e) { return false; }',
	'}',
	'return true;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["checkEffect"].requirements = [];

/**
 * Gets a layer from a layer property in an effect, without generating an error if "None" is selected with the Legacy expression engine.
 * @function
 * @param {Property} fx The effect
 * @param {int|string} ind The index or the name of the property
 * @return {Layer|null} The layer, or null if set to "None"
 */
DuAEF.DuExpression.Library["getEffectLayer"] = {};
DuAEF.DuExpression.Library["getEffectLayer"].expression = ['function getEffectLayer( fx, ind ) {',
	'try { var l = fx( ind ); return l; }',
	'catch ( e ) { return null; }',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getEffectLayer"].requirements = [];

/**
 * Checks if a property is a layer. Useful when traversing up the property tree to stop when getting the layer.
 * @function
 * @param {Property} prop - The property to test
 * @return {boolean} true if the prop is a layer
 */
DuAEF.DuExpression.Library["isLayer"] = {};
DuAEF.DuExpression.Library["isLayer"].expression = ['function isLayer( prop ) {',
	'try { if ( prop.index ) return true; }',
	'catch (e) { return false; }',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["isLayer"].requirements = [];

/**
 * Checks if a property is a transform.position property.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {Property} [prop=thisProperty] The property
 * @return {boolean} true if the property is the transform.position property.
 */
DuAEF.DuExpression.Library["isPosition"] = {};
DuAEF.DuExpression.Library["isPosition"].expression = ['function isPosition(prop) {',
	'return  prop === position;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["isPosition"].requirements = [];

/**
 * Checks if a property is spatial
 * @param {Property} prop The property to check
 * @return {boolean} true if the property is spatial.
 */
DuAEF.DuExpression.Library["isSpatial"] = {};
DuAEF.DuExpression.Library["isSpatial"].expression = ['function isSpatial(prop) {',
	'if (!(prop.value instanceof Array)) return false;',
	'if (prop.value.length != 2 && prop.value.length != 3) return false;',
	'try { if (typeof prop.speed !== "undefined") return true; }',
	'catch (e) { return false; }',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["isSpatial"].requirements = [];

/**
 * Checks if the current property is animated at a given time.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] The time
 * @param {number} [threshold=0.1] The speed under which the property is considered still.
 * @return {boolean} true if the property does not vary.
 */
DuAEF.DuExpression.Library["isStill"] = {};
DuAEF.DuExpression.Library["isStill"].expression = ['function isStill(t, threshold) {',
	'var d = valueAtTime(t) - valueAtTime(t + framesToTime(1));',
	'if (d instanceof Array) {',
	'for (var i = 0; i < d.length; i++) {',
	'd[i] = Math.abs(d[i]);',
	'if (d[i] >= threshold) {',
	'return false;',
	'}',
	'}',
	'return true;',
	'} else {',
	'd = Math.abs(d);',
	'return d < threshold;',
	'}',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["isStill"].requirements = [];

/**
 * Adds some noise to a value.<br />
 * You may use seedRandom() before using this function as it will influence the generated noise.
 * A timeless noise can be achieved with <code>seedRandom(index,true)</code> for example.
 * @function
 * @param {number|number[]} val The value to add noise to.
 * @param {float} quantity The quantity of noise. A percentage. 100 means the value can range from (val * 0) to (val * 2).
 * @example
 * seedRandom(index, true) // a timeless noise
 * addNoise(value, 50 ); // the property value will have noise between (value * 0.5) and (value * 1.5) which won't vary through time.
 * @example
 * seedRandom(index, false);
 * addNoise(value, 33 ); // the noise will change at each frame, varying between (value * .66) and (value * 1.33)
 */
DuAEF.DuExpression.Library["addNoise"] = {};
DuAEF.DuExpression.Library["addNoise"].expression = ['function addNoise( val, quantity ) {',
	'var randomValue = random(0.9,1.1);',
	'var noiseValue = noise(valueAtTime(0) * randomValue);',
	'noiseValue = noiseValue * (quantity / 100);',
	'return val * ( noiseValue + 1 );',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["addNoise"].requirements = [];

/**
 * Removes the ancestors rotation from the rotation of a layer.
 * This is very useful to make a layer keep its orientation without being influenced by its parents.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @example
 * //in a rotation property, just include the function and use:
 * dishineritRotation();
 * //the layer will now keep its own orientation.
 * @example
 * //you can also combine the result with something else
 * var result = dishineritRotation();
 * result + wiggle(5,20);
 * @function
 * @param {Layer} [l=thisLayer] The layer
 * @return {float} The new rotation value, in degrees.
 * @requires sign
 */
DuAEF.DuExpression.Library["dishineritRotation"] = {};
DuAEF.DuExpression.Library["dishineritRotation"].expression = ['function dishineritRotation( l ) {',
	'var r = l.rotation.value;',
	'while ( l.hasParent ) {',
	'l = l.parent;',
	'var s = l.scale.value;',
	'r -= l.rotation.value * Math.sign(s[0]*s[1]);',
	'}',
	'return r;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["dishineritRotation"].requirements = ["sign"];

/**
 * Removes the ancestors scale from the scale of a layer.
 * This is very useful to make a layer keep its scale without being influenced by its parents.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @example
 * //in a rotation property, just include the function and use:
 * dishineritScale();
 * //the layer will now keep its own scale.
 * @example
 * //you can also combine the result with something else
 * var result = dishineritScale();
 * result + wiggle(5,20);
 * @function
 * @param {Layer} [l=thisLayer] The layer
 * @return {float[]} The new scale value, in percent.
 */
DuAEF.DuExpression.Library["dishineritScale"] = {};
DuAEF.DuExpression.Library["dishineritScale"].expression = ['function dishineritScale( l ) {',
	'var s = l.scale.value;',
	'var threeD = s.length == 3;',
	'while ( l.hasParent ) {',
	'l = l.parent;',
	'var ps = l.scale.value / 100;',
	'if (threeD && ps.length == 3) {',
	's = [ s[0]/ps[0], s[1]/ps[1], s[2]/ps[2] ];',
	'}',
	'else if (threeD) {',
	's = [ s[0]/ps[0], s[1]/ps[1], s[2] ];',
	'}',
	'else {',
	's = [ s[0]/ps[0], s[1]/ps[1] ];',
	'}',
	'}',
	'return s;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["dishineritScale"].requirements = [];

/**
 * Converts the point coordinates from the current group in the shape layer to the Layer.<br />
 * Use toWorld and toComp with the result if you need te coordinates in the world or the comp.
 * @function
 * @param {number[]} point The 2D coordinates of the point in the current group.
 * @return {number[]} The 2D coordinates of the point in the Layer.
 * @requires Matrix
 * @requires getGroupTransformMatrix
 */
DuAEF.DuExpression.Library["fromGroupToLayer"] = {};
DuAEF.DuExpression.Library["fromGroupToLayer"].expression = ['function fromGroupToLayer( point ) {',
	'var matrix = getGroupTransformMatrix();',
	'return matrix.applyToPoint( point );',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["fromGroupToLayer"].requirements = ["Matrix","getGroupTransformMatrix"];

/**
 * Converts the point coordinates from Layer to the current group in the shape layer.<br />
 * Use fromWorld or fromComp first if you need to convert from the world or composition coordinates, and pass the result to this function.
 * @function
 * @param {number[]} point The 2D coordinates of the point in the Layer.
 * @return {number[]} The 2D coordinates of the point in the current group.
 * @requires Matrix
 * @requires getGroupTransformMatrix
 */
DuAEF.DuExpression.Library["fromLayerToGroup"] = {};
DuAEF.DuExpression.Library["fromLayerToGroup"].expression = ['function fromLayerToGroup( point ) {',
	'var matrix = getGroupTransformMatrix().inverse();',
	'return matrix.applyToPoint( point );',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["fromLayerToGroup"].requirements = ["Matrix","getGroupTransformMatrix"];

/**
 * Gets the "real" scale of a layer, resulting to its scale property, the scale of its parents, and it's location in Z-space if it's 3D.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {Layer} [l=thisLayer] The layer 
 * @param {number} [t=time] The time when to get the scale
 * @return {number} The scale ratio. This is not a percent, 1.0 is 100%.
 */
DuAEF.DuExpression.Library["getCompScale"] = {};
DuAEF.DuExpression.Library["getCompScale"].expression = ['function getCompScale( l, t ) {',
	'var originalWidth = length( l.anchorPoint, [ l.width, 0 ] );',
	'var anchorInComp = l.toComp( l.anchorPoint, t );',
	'var widthInComp = l.toComp( [ l.width, 0 ], t );',
	'var newWidth = length(anchorInComp, widthInComp);',
	'return newWidth / originalWidth;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getCompScale"].requirements = [];

/**
 * Gets the transformation Matrix for the current group in a shape layer, including the transformation from the ancestor groups<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {Property} [prop=thisProperty] The property from which to get the matrix
 * @return {Matrix} The 2D Transform Matrix.
 * @requires isLayer
 * @requires Matrix
 */
DuAEF.DuExpression.Library["getGroupTransformMatrix"] = {};
DuAEF.DuExpression.Library["getGroupTransformMatrix"].expression = ['function getGroupTransformMatrix( prop ) {',
	'var matrix = new Matrix();',
	'var shapeGroups = [];',
	'var parentProp = prop.propertyGroup(1);',
	'while( parentProp && !isLayer(parentProp) )',
	'{',
	'try { if ( parentProp.transform ) shapeGroups.push( parentProp.transform ); }',
	'catch (e) {}',
	'parentProp = parentProp.propertyGroup(1);',
	'}',
	'for (var i = shapeGroups.length - 1; i >= 0; i--)',
	'{',
	'var group = shapeGroups[i];',
	'matrix.translate( group.position.value );',
	'matrix.rotate( group.rotation.value );',
	'var aPX = -( group.anchorPoint.value[ 0 ] * group.scale.value[ 0 ] / 100 );',
	'var aPY = -( group.anchorPoint.value[ 1 ] * group.scale.value[ 1 ] / 100 );',
	'matrix.translate( [ aPX, aPY ] );',
	'matrix.scale( group.scale.value / 100 );',
	'}',
	'return matrix;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getGroupTransformMatrix"].requirements = ["isLayer","Matrix"];

/**
 * Gets the comp position (2D Projection in the comp) of a layer.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [l=thisLayer] The layer
 * @return {number[]} The comp position
 */
DuAEF.DuExpression.Library["getLayerCompPos"] = {};
DuAEF.DuExpression.Library["getLayerCompPos"].expression = ['function getLayerCompPos( t, l ) {',
	'return l.toComp( l.anchorPoint, t );',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getLayerCompPos"].requirements = [];

/**
 * Gets the world position of a layer.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [l=thisLayer] The layer
 * @return {number[]} The world position
 */
DuAEF.DuExpression.Library["getLayerWorldPos"] = {};
DuAEF.DuExpression.Library["getLayerWorldPos"].expression = ['function getLayerWorldPos(t, l) {',
	'return l.toWorld(l.anchorPoint, t);',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getLayerWorldPos"].requirements = [];

/**
 * Gets the world instant speed of a layer.
 * @function
 * @param {number} [t=time] The time when to get the velocity
 * @param {Layer} [l=thisLayer] The layer
 * @return {number} A positive number. The speed.
 * @requires getLayerWorldVelocity
 */
DuAEF.DuExpression.Library["getLayerWorldSpeed"] = {};
DuAEF.DuExpression.Library["getLayerWorldSpeed"].expression = ['function getLayerWorldSpeed(t, l) {',
	'return length(getWorldVelocity(t, l));',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getLayerWorldSpeed"].requirements = ["getLayerWorldVelocity"];

/**
 * Gets the world instant velocity of a layer.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] The time when to get the velocity
 * @param {Layer} [l=thisLayer] The layer
 * @return {number[]} The velocity.
 * @requires getLayerWorldPos
 */
DuAEF.DuExpression.Library["getLayerWorldVelocity"] = {};
DuAEF.DuExpression.Library["getLayerWorldVelocity"].expression = ['function getLayerWorldVelocity(t, l) {',
	'return (getLayerWorldPos(t, l) - getLayerWorldPos(t - 0.01, l)) * 100;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getLayerWorldVelocity"].requirements = ["getLayerWorldPos"];

/**
 * Gets the world orientation of a (2D) layer.
 * @function
 * @param {Layer} l The layer to get the orientation from
 * @return {float} The orientation, in degrees.
 */
DuAEF.DuExpression.Library["getOrientation"] = {};
DuAEF.DuExpression.Library["getOrientation"].expression = ['function getOrientation( l ) {',
	'var sign = getScaleMirror( l );',
	'var uTurn = getScaleUTurn( l )',
	'var r = l.rotation.value * sign + uTurn;',
	'while ( l.hasParent ) {',
	'l = l.parent;',
	'var lr = l.rotation.value;',
	'if (l.hasParent) {',
	'var s = l.parent.scale.value;',
	'lr *= Math.sign(s[0]*s[1]);',
	'}',
	'r += lr;',
	'}',
	'return r;',
	'}',
	'function getScaleMirror( l ) {',
	'var sign = 1;',
	'while (l.hasParent) {',
	'l = l.parent;',
	'var s = l.scale.value;',
	'sign *= Math.sign(s[0]*s[1]);',
	'}',
	'return sign;',
	'}',
	'function getScaleUTurn( l ) {',
	'var u = 1;',
	'while (l.hasParent) {',
	'l = l.parent;',
	'var s = l.scale.value;',
	'u = u*s[1];',
	'}',
	'if (u < 0) return 180;',
	'else return 0;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getOrientation"].requirements = [];

/**
 * Gets the world orientation of a (2D) layer at a specific time.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {Layer} l The layer to get the orientation from
 * @param {float} [t=time] The time at which to get the orientation
 * @return {float} The orientation, in degrees.
 */
DuAEF.DuExpression.Library["getOrientationAtTime"] = {};
DuAEF.DuExpression.Library["getOrientationAtTime"].expression = ['function getOrientationAtTime( l, t ) {',
	'var r = 0;',
	'r += l.rotation.valueAtTime( t );',
	'while ( l.hasParent ) {',
	'l = l.parent;',
	'r += l.rotation.valueAtTime( t );',
	'}',
	'return r;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getOrientationAtTime"].requirements = [];

/**
 * Gets the world speed of a property.
 * @function
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [prop=thisProperty] The property
 * @return {number[]} The world speed
 * @requires getPropWorldVelocity
 */
DuAEF.DuExpression.Library["getPropWorldSpeed"] = {};
DuAEF.DuExpression.Library["getPropWorldSpeed"].expression = ['function getPropWorldSpeed(t, prop) {',
	'return length(getPropWorldVelocity(t, prop));',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getPropWorldSpeed"].requirements = ["getPropWorldVelocity"];

/**
 * Gets the world coordinates of a property.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [prop=thisProperty] The property
 * @return {number[]} The world coordinates
 * @requires getLayerWorldPos
 * @requires isPosition
 */
DuAEF.DuExpression.Library["getPropWorldValue"] = {};
DuAEF.DuExpression.Library["getPropWorldValue"].expression = ['function getPropWorldValue(t, prop) {',
	'if (isPosition(prop)) return getLayerWorldPos(t, thisLayer);',
	'return thisLayer.toWorld(prop.valueAtTime(t), t);',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getPropWorldValue"].requirements = ["getLayerWorldPos","isPosition"];

/**
 * Gets the world velocity of a property.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [prop=thisProperty] The property
 * @return {number[]} The world velocity
 * @requires getPropWorldValue
 */
DuAEF.DuExpression.Library["getPropWorldVelocity"] = {};
DuAEF.DuExpression.Library["getPropWorldVelocity"].expression = ['function getPropWorldVelocity(t, prop) {',
	'return (getPropWorldValue(t + 0.005, prop) - getPropWorldValue(t - 0.005, prop)) * 100;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getPropWorldVelocity"].requirements = ["getPropWorldValue"];

/**
 * Gets the world scale of a layer.
 * @function
 * @param {Layer} l The layer to get the scale from
 * @return {float[]} The scale, in percent.
 */
DuAEF.DuExpression.Library["getScale"] = {};
DuAEF.DuExpression.Library["getScale"].expression = ['function getScale( l ) {',
	'var s = l.scale.value;',
	'var threeD = s.length == 3;',
	'while ( l.hasParent ) {',
	'l = l.parent;',
	'var ps = l.scale.value / 100;',
	'if (threeD && ps.length == 3) {',
	's = [ s[0]*ps[0], s[1]*ps[1], s[2]*ps[2] ];',
	'}',
	'else if (threeD) {',
	's = [ s[0]*ps[0], s[1]*ps[1], s[2] ];',
	'}',
	'else {',
	's = [ s[0]*ps[0], s[1]*ps[1] ];',
	'}',
	'}',
	'return s;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["getScale"].requirements = [];

/**
  * 2D transformation matrix object initialized with identity matrix. See the source code for more documentation.
  * @class
  * @classdesc 2D Transformation Matrix. Simplified for use in After Effects Expressions by Nicolas "Duduf" Dufresne
  * @prop {number} a - scale x
  * @prop {number} b - shear y
  * @prop {number} c - shear x
  * @prop {number} d - scale y
  * @prop {number} e - translate x
  * @prop {number} f - translate y
  * @author Epistemex
  * @version 2.7.5
  * @license MIT license (header required)
  * @copyright Epistemex.com 2014-2018
*/
DuAEF.DuExpression.Library["Matrix"] = {};
DuAEF.DuExpression.Library["Matrix"].expression = ['function Matrix() {',
	'/*!',
	'2D Transformation Matrix v2.7.5 LT',
	'(c) Epistemex.com 2014-2018',
	'License: MIT',
	'*/',
	'var me = this, _el;',
	'me._t = me.transform;',
	'me.a = me.d = 1;',
	'me.b = me.c = me.e = me.f = 0;',
	'}',
	'Matrix.prototype = {',
	'rotate: function(angle) {',
	'angle = degreesToRadians(angle);',
	'var',
	'cos = Math.cos(angle),',
	'sin = Math.sin(angle);',
	'return this._t(cos, sin, -sin, cos, 0, 0)',
	'},',
	'rotateFromVector: function(x, y) {',
	'return this.rotate(typeof x === "number" ? Math.atan2(y, x) : Math.atan2(x.y, x.x))',
	'},',
	'scale: function(s) {',
	'return this._t(s[0], 0, 0, s[1], 0, 0);',
	'},',
	'shear: function(sx, sy) {',
	'return this._t(1, sy, sx, 1, 0, 0)',
	'},',
	'skew: function(ax, ay) {',
	'return this.shear(Math.tan(ax), Math.tan(ay))',
	'},',
	'setTransform: function(a, b, c, d, e, f) {',
	'var me = this;',
	'me.a = a;',
	'me.b = b;',
	'me.c = c;',
	'me.d = d;',
	'me.e = e;',
	'me.f = f;',
	'return me._x()',
	'},',
	'translate: function(t) {',
	'return this._t(1, 0, 0, 1, t[0], t[1]);',
	'},',
	'transform: function(a2, b2, c2, d2, e2, f2) {',
	'var',
	'me = this,',
	'a1 = me.a,',
	'b1 = me.b,',
	'c1 = me.c,',
	'd1 = me.d,',
	'e1 = me.e,',
	'f1 = me.f;',
	'/* matrix column order is:',
	'*	a c e',
	'*	b d f',
	'*	0 0 1',
	'*/',
	'me.a = a1 * a2 + c1 * b2;',
	'me.b = b1 * a2 + d1 * b2;',
	'me.c = a1 * c2 + c1 * d2;',
	'me.d = b1 * c2 + d1 * d2;',
	'me.e = a1 * e2 + c1 * f2 + e1;',
	'me.f = b1 * e2 + d1 * f2 + f1;',
	'return me._x()',
	'},',
	'multiply: function(m) {',
	'return this._t(m.a, m.b, m.c, m.d, m.e, m.f)',
	'},',
	'inverse: function(cloneContext) {',
	'var',
	'me = this,',
	'm  = new Matrix(cloneContext ? me.context : null),',
	'dt = me.determinant();',
	'if (dt === 0) throw "Matrix not invertible.";',
	'm.a = me.d / dt;',
	'm.b = -me.b / dt;',
	'm.c = -me.c / dt;',
	'm.d = me.a / dt;',
	'm.e = (me.c * me.f - me.d * me.e) / dt;',
	'm.f = -(me.a * me.f - me.b * me.e) / dt;',
	'return m',
	'},',
	'decompose: function() {',
	'var',
	'me		= this,',
	'a		 = me.a,',
	'b		 = me.b,',
	'c		 = me.c,',
	'd		 = me.d,',
	'acos	  = Math.acos,',
	'atan	  = Math.atan,',
	'sqrt	  = Math.sqrt,',
	'pi		= Math.PI,',
	'translate = {x: me.e, y: me.f},',
	'rotation  = 0,',
	'scale	 = {x: 1, y: 1},',
	'skew	  = {x: 0, y: 0},',
	'determ	= a * d - b * c,',
	'r, s;',
	'if (a || b) {',
	'r = sqrt(a * a + b * b);',
	'rotation = b > 0 ? acos(a / r) : -acos(a / r);',
	'scale = {x: r, y: determ / r};',
	'skew.x = atan((a * c + b * d) / (r * r));',
	'}',
	'else if (c || d) {',
	's = sqrt(c * c + d * d);',
	'rotation = pi * 0.5 - (d > 0 ? acos(-c / s) : -acos(c / s));',
	'scale = {x: determ / s, y: s};',
	'skew.y = atan((a * c + b * d) / (s * s));',
	'}',
	'else {',
	'scale = {x: 0, y: 0};',
	'}',
	'return {',
	'translate: translate,',
	'rotation : rotation,',
	'scale	: scale,',
	'skew	 : skew',
	'}',
	'},',
	'determinant: function() {',
	'return this.a * this.d - this.b * this.c',
	'},',
	'applyToPoint: function(pt) {',
	'var me = this;',
	'var x = pt[0] * me.a + pt[1] * me.c + me.e;',
	'var y = pt[0] * me.b + pt[1] * me.d + me.f;',
	'var result = [x,y];',
	'if (pt.length == 3) result.push(pt[2]);',
	'return result;',
	'},',
	'isIdentity: function() {',
	'var me = this;',
	'return me.a === 1 && !me.b && !me.c && me.d === 1 && !me.e && !me.f',
	'},',
	'isInvertible: function() {',
	'return !this._q(this.determinant(), 0)',
	'},',
	'isValid: function() {',
	'return !(this.a * this.d)',
	'},',
	'isEqual: function(m) {',
	'var',
	'me = this,',
	'q = me._q;',
	'return  q(me.a, m.a) &&',
	'q(me.b, m.b) &&',
	'q(me.c, m.c) &&',
	'q(me.d, m.d) &&',
	'q(me.e, m.e) &&',
	'q(me.f, m.f)',
	'},',
	'clone: function(noContext) {',
	'return new Matrix(noContext ? null : this.context).multiply(this)',
	'},',
	'_q: function(f1, f2) {',
	'return Math.abs(f1 - f2) < 1e-14',
	'},',
	'_x: function() {',
	'var me = this;',
	'try { if (me.context)',
	'me.context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);',
	'} catch(e) {}',
	'return me',
	'}',
	'};'
	].join('\n');
DuAEF.DuExpression.Library["Matrix"].requirements = [];

/**
 * Translates a point with a layer, as if it was parented to it.<br />
 * Note that for performance reasons with expressions, even if the parameters of the function are documented with optional/default values, you MUST provide ALL the arguments when using them.
 * @function
 * @param {Layer} l The layer to get the translation from.
 * @param {float[]} [point=[0,0]] The [X,Y] point to translate (using world coordinates).
 * @param {float} [startT=0] The start time of the translation
 * @param {float} [endT=time] The end time of the translation
 * @return {float[]} The coordinates of the translated point.
 */
DuAEF.DuExpression.Library["translatePointWithLayer"] = {};
DuAEF.DuExpression.Library["translatePointWithLayer"].expression = ['function translatePointWithLayer( l, point, startT, endT ) {',
	'try {',
	'var pos = l.fromWorld( point, startT );',
	'} catch ( e ) {',
	'var pos = [ 0, 0 ];',
	'}',
	'var prevPos = l.toWorld( pos, startT );',
	'var newPos = l.toWorld( pos, endT );',
	'return newPos - prevPos;',
	'}'
	].join('\n');
DuAEF.DuExpression.Library["translatePointWithLayer"].requirements = [];


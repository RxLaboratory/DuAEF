/**
* Expression Library
* @namespace
* @memberof DuAEF.Expressions
*/
DuAEF.Expression.Library = {};

/**
 * Checks the type of a pseudo-effect used by Duik.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * Pseudo-Effects used by Duik start with a hidden property which name is the same as the matchName of the effect itself (without the 'Pseudo/' part).
 * @function
 * @name checkDuikEffect
 * @example
 * if ( checkEffect(thisLayer.effect(1), "DUIK parentConstraint2") ) { "This is the second version of the parent constraint by Duik" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {string} duikMatchName The matchName of a pseudo-effect used by Duik (without the 'Pseudo/' part)
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.Expression.Library.checkDuikEffect = ['',
	'function checkDuikEffect(fx, duikMatchName) {',
	'    if (fx.numProperties  < 3) return false;',
	'    if (!!$.engineName) {',
	'        if ( fx(2).name != duikMatchName ) return false;',
	'    }',
	'    else {',
	'        try { if (fx(2).name != duikMatchName) return false; }',
	'        catch (e) { return false; }',
	'    }',
	'    return true;',
	'}'
	].join('\n');

/**
 * Checks the type of an effect.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * It checks if the given effect has a specific property at a specific index.
 * @function
 * @name checkEffect
 * @example
 * if ( checkEffect(thisLayer.effect(1), 1, "Blur") ) { "The first effect is a blur!" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {int} propIndex The index of the property
 * @param {string} propName The expected name of the property. Be careful with the internationalization of After Effects...
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.Expression.Library.checkEffect = ['',
	'function checkEffect(fx, propIndex, propName) {',
	'    if (fx.numProperties  < propIndex) return false;',
	'    //Check when this is a javascript engine (without try/catch for better performance)',
	'    if (!!$.engineName) {',
	'        if ( fx(propIndex).name != propName ) return false;',
	'    }',
	'    //Check with the extendscript engine',
	'    else {',
	'        try { if (fx(propIndex).name != propName) return false; }',
	'        catch (e) { return false; }',
	'    }',
	'    return true;',
	'}'
	].join('\n');

/**
 * Gets the world orientation of a (2D) layer at a specific time.
 * @function
 * @name getOrientationAtTime
 * @param {Layer} l The layer to get the orientation from
 * @param {float} [t=time] The time at which to get the orientation
 * @return {float} The orientation, in degrees.
 */
DuAEF.Expression.Library.getOrientationAtTime = ['',
	'function getOrientationAtTime( l, t ) {',
	'    if (typeof t === "undefined" ) t = time;',
	'    var r = 0;',
	'    r += l.rotation.valueAtTime( t );',
	'    while ( l.hasParent ) {',
	'        l = l.parent;',
	'        r += l.rotation.valueAtTime( t );',
	'    }',
	'    return r;',
	'}'
	].join('\n');

/**
 * Translates a point with a layer, as if it was parented to it.
 * @function
 * @name translatePointWithLayer
 * @param {Layer} l The layer to get the translation from.
 * @param {float[]} [point=[0,0]] The [X,Y] point to translate (using world coordinates).
 * @param {float} [startFrame=0] The start frame of the translation
 * @param {float} [endFrame=timeToFrames()] The end frame of the translation
 * @return {float[]} The coordinates of the translated point.
 */
DuAEF.Expression.Library.translatePointWithLayer = ['',
	'function translatePointWithLayer( l, point, startFrame, endFrame ) {',
	'    if (typeof startFrame === "undefined") startFrame = 0;',
	'    if (typeof endFrame === "undefined") endFrame = timeToFrames();',
	'    var sT = framesToTime( startFrame );',
	'    var eT = framesToTime( endFrame );',
	'    try {',
	'        var pos = l.fromWorld( point, sT );',
	'    } catch ( e ) {',
	'        var pos = [ 0, 0 ];',
	'    }',
	'    var prevPos = l.toWorld( pos, sT );',
	'    var newPos = l.toWorld( pos, eT );',
	'    return newPos - prevPos;',
	'}'
	].join('\n');


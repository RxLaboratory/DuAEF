/**
 * Duik Rigging Tools
 * @author Nicolas Dufresne, Kevin Masson and contributors
 * @copyright 2017,2018 Nicolas Dufresne, Rainbox Productions<br />
 * {@link https://rainboxprod.coop}
 * @namespace
 * @memberof DuAEF.Duik
 * @license GPL-3.0 <br />
 * DuAEF is free software: you can redistribute it and/or modify<br />
 * it under the terms of the GNU General Public License as published by<br />
 * the Free Software Foundation, either version 3 of the License, or<br />
 * (at your option) any later version.<br />
 *<br />
 * DuAEF is distributed in the hope that it will be useful,<br />
 * but WITHOUT ANY WARRANTY; without even the implied warranty of<br />
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br />
 * GNU General Public License for more details.<br />
 *<br />
 * You should have received a copy of the GNU General Public License<br />
 * along with DuAEF. If not, see {@link http://www.gnu.org/licenses/}.
 */
DuAEF.Duik.Rigging = {};

/**
 * Chain Rig types
 * @enum {int}
 * @readonly
 */
DuAEF.Duik.Rigging.chainTypes = {
    IK: 0,
    FK: 1,
    BEZIER: 2
}

/**
 * Separates the dimensions of the properties into an effect.<br />
 * Works with 2D, 3D, and colors
 * @param {Property|PropertyInfo} prop - The property
 * @return {PropertyInfo[]} The seperated properties (or the original one if it could not be separated)
 */
DuAEF.Duik.Rigging.separateDimensions = function( prop )
{
    var propInfo = new PropertyInfo( prop );
    prop = propInfo.getProperty();

    var layer = propInfo.layer;
    var dim = propInfo.dimensions;

    if ( dim < 2 || dim > 4 ) return [propInfo];

    if (prop.isSeparationLeader)
    {
        prop.dimensionsSeparated = true;
        var newProps = [];
        for (var i = 1; i <= dim; i++)
        {
            var newProp = prop.parentProperty(prop.propertyIndex + i);
            newProp = new PropertyInfo(newProp);
            newProps.push( newProp );
        }
        return newProps;
    }

    if ( dim == 2 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = DuAEF.Duik.PseudoEffects.TWO_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = DuAEF.Duik.PseudoEffects.TWO_DIMENSIONS_ANGLE;
        else pseudo = DuAEF.Duik.PseudoEffects.TWO_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XY" );

        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( pseudo.xSlider ).setValue( prop.value[ 0 ] );
            effect( pseudo.ySlider ).setValue( prop.value[ 1 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( pseudo.xSlider ).setValueAtTime( time, value[ 0 ] );
                effect( pseudo.ySlider ).setValueAtTime( time, value[ 1 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = '//Duik.separateDimensions\n' +
            'var fx = thisLayer.effect("' + effect.name + '");\n' +
            '[fx(' + pseudo.xSlider + ').value,fx(' + pseudo.ySlider + ').value];';

        //return the new props
        var xProp = new PropertyInfo(effect( pseudo.xSlider ));
        var yProp = new PropertyInfo(effect( pseudo.ySlider ));
        return [xProp,yProp];
    }
    
    if ( dim == 3 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = DuAEF.Duik.PseudoEffects.THREE_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = DuAEF.Duik.PseudoEffects.THREE_DIMENSIONS_ANGLE;
        else pseudo = DuAEF.Duik.PseudoEffects.THREE_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XYZ" );

        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( pseudo.xSlider ).setValue( prop.value[ 0 ] );
            effect( pseudo.ySlider ).setValue( prop.value[ 1 ] );
            effect( pseudo.zSlider ).setValue( prop.value[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( pseudo.xSlider ).setValueAtTime( time, value[ 0 ] );
                effect( pseudo.ySlider ).setValueAtTime( time, value[ 1 ] );
                effect( pseudo.zSlider ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = '//Duik.separateDimensions\n' +
            'var fx = thisLayer.effect("' + effect.name + '");\n' +
            '[fx(' + pseudo.xSlider + ').value,fx(' + pseudo.ySlider + ').value, fx(' + pseudo.zSlider + ').value];';

        //return the new props
        var xProp = new PropertyInfo(effect( pseudo.xSlider ));
        var yProp = new PropertyInfo(effect( pseudo.ySlider ));
        var zProp = new PropertyInfo(effect( pseudo.zSlider ));
        return [xProp,yProp,zProp];
    }
    
    if ( dim == 4 )
    {
        var pseudo = DuAEF.Duik.PseudoEffects.COLOR;
        var effect = pseudo.apply( layer, propInfo.name + " RGB/HSL" );
        effect( pseudo.channelsPopup ).setValue( 2 );
        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            var color = prop.value;
            color = DuAEF.DuJS.Color.rgbToHsl( color );
            effect( pseudo.xSlider ).setValue( color[ 0 ] );
            effect( pseudo.ySlider ).setValue( color[ 1 ] );
            effect( pseudo.zSlider ).setValue( color[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                value = DuAEF.DuJS.Color.rgbToHsl( value );
                effect( pseudo.xSlider ).setValueAtTime( time, value[ 0 ] );
                effect( pseudo.ySlider ).setValueAtTime( time, value[ 1 ] );
                effect( pseudo.zSlider ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = '//Duik.separateDimensions\n' +
            'var fx = thisLayer.effect("' + effect.name + '");\n' +
            'var color = [fx(' + pseudo.xSlider + ').value,fx(' + pseudo.ySlider + ').value, fx(' + pseudo.zSlider + ').value, 1];\n' +
            'if (fx(' + pseudo.channelsPopup + ').value == 2) hslToRgb(color);\n' +
            'else color;\n';

        //return the new props
        var xProp = new PropertyInfo(effect( pseudo.xSlider ));
        var yProp = new PropertyInfo(effect( pseudo.ySlider ));
        var zProp = new PropertyInfo(effect( pseudo.zSlider ));
        return [xProp,yProp,zProp];
    }
}

/**
 * Adds a zero to a layer
 * @param {Layer} layer - The layer
 * @return {AVLayer} The zero, a null
 */
DuAEF.Duik.Rigging.addZero = function( layer )
{
    //create null object
    var zero = layer.containingComp.layers.addNull();
    DuAEF.Dugr.addLayerToGroup( zero, "Zeros" );
    var layerparent = layer.parent;
    layer.parent = null;
    zero.position.setValue( layer.position.value );
    zero.rotation.setValue( layer.rotation.value );
    zero.name = "Zero | " + layer.name.slice( -24 );
    layer.parent = zero;
    zero.scale.setValue( layer.scale.value );
    layer.scale.setValue( [ 100, 100, 100 ] );

    DuAEF.Duik.setDuikMarker( zero, "Zero", DuAEF.Duik.LayerTypes.ZERO );

    //parent
    zero.parent = layerparent;

    //lock and hide
    zero.moveToEnd();
    zero.guideLayer = true;
    zero.shy = true;
    zero.enabled = false;
    zero.selected = false;
    zero.locked = true;
    return zero;
}

/**
 * Adds a locator to a layer
 * @param {Layer|CompItem} [layerOrComp=DuAEF.DuAE.Project.getActiveComp()] - The layer or the containing comp, to add a standalone locator.
 * @return {AVLayer} The locator, a null object
 */
DuAEF.Duik.Rigging.addLocator = function( layerOrComp )
{
    var layer = null;
    var comp = null;
    if ( typeof layerOrComp === 'undefined' ) comp = DuAEF.DuAE.Project.getActiveComp();
    else if ( layerOrComp instanceof CompItem ) comp = layerOrComp;
    else
    {
        layer = layerOrComp;
        comp = layer.containingComp;
    }
    if ( !comp ) return;

    //create null object
    var loc = comp.layers.addNull();
    var name = 'LOC';
    if ( layer ) name = DuAEF.Duik.generateName( 'LOC', layer.name );
    loc.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
    DuAEF.Dugr.addLayerToGroup( loc, "Locators" );

    //add layer control
    var layerfx = loc.property( 'ADBE Effect Parade' ).addProperty( 'ADBE Layer Control' );
    layerfx.name = "Locator";
    if ( layer ) layerfx( 1 ).setValue( layer.index );

    //add expressions
    loc.transform.rotation.expression = [ DuAEF.Duik.expressionIds.LOCATOR,
        DuAEF.DuExpression.get(['sign','dishineritRotation','getOrientation']),
        'var result = 0;',
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        'if (l)',
        '{',
        '    var sign = getScaleMirror( thisLayer );',
        '    var flip = getScaleUTurn( thisLayer );',
        '    result = getOrientation( l ) * sign + flip;',
        '    result += dishineritRotation( thisLayer ) - value;',
        '}',
        'result;'
        ].join('\n');

    loc.transform.position.expression = [ DuAEF.Duik.expressionIds.LOCATOR,
        'var result = [thisComp.width/2,thisComp.height/2];',
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        'if (l)',
        '{',
        '   result = l.toWorld(l.anchorPoint);',
        '}',
        'if (hasParent)',
        '{',
        '   result = parent.fromWorld(result);',
        '}',
        'result;'
        ].join('\n');

    loc.transform.anchorPoint.expression = [ DuAEF.Duik.expressionIds.LOCATOR,
        'var result = value;',
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        'if (l)',
        '{',
        '   result =l.anchorPoint.value;',
        '}',
        'result;'
        ].join('\n');

    loc.transform.scale.expression = [ DuAEF.Duik.expressionIds.LOCATOR,
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        DuAEF.DuExpression.get(['getScale','dishineritScale']),
        '',
        'var threeD = value.length == 3;',
        'var result = dishineritScale( thisLayer ) - value;',
        'if (threeD) result += [100,100,100];',
        'else result += [100,100];',
        '',
        'if (l)',
        '{',
        '    var sl = getScale( l )/100;',
        '    if (result.length == 3 && sl.length == 3) {',
        '        result = [ result[0]*sl[0], result[1]*sl[1], result[2]*sl[2] ];',
        '    }',
        '    else if (result.length == 3) {',
        '        result = [result[0]*sl[0], result[1]*sl[1], result[2] ];',
        '    }',
        '    else {',
        '        result = [result[0]*sl[0], result[1]*sl[1] ];',
        '    }',
        '}',
        '',
        'result;'
    ].join('\n');

    DuAEF.Duik.setDuikMarker( loc, "Locator", DuAEF.Duik.LayerTypes.LOCATOR );

    return loc;
}

/**
 * Extracts locators from a precomposition
 * @param {AVLayer} [preCompLayer] - The precomposition layer
 * @param {boolean} [useMasterProperties=false] - true to extract using master properties instead of expressions (only in Ae > 15.1 CC2018)
 * @return {AVLayer[]} The extracted locators
 */
DuAEF.Duik.Rigging.extractLocators = function( preCompLayer, useMasterProperties )
{
    var preComp = preCompLayer.source;
    if ( !preComp instanceof CompItem ) return;

    //get locators in precomp
    var preCompLocs = DuAEF.Duik.getLayers( DuAEF.Duik.LayerTypes.LOCATOR, false, preComp );

    var locs = [];

    var it = new Iterator( preCompLocs );
    it.do( function( preCompLoc )
    {
        locs.push( DuAEF.Duik.Rigging.extractLocator( preCompLoc, preCompLayer, useMasterProperties ) );
    } );

    return locs;
}

/**
 * Extracts one locator from a precomposition
 * @param {AVLayer} locator - The locator to extract
 * @param {AVLayer} preCompLayer - The precomposition layer
 * @param {boolean} [useMasterProperties=true] - true to extract using master properties instead of expressions (ignored in Ae < 15.1, false by default if 15.1 <= Ae < 17 and true by default in Ae >= 17)
 * @return {AVLayer} The extracted locator
 */
DuAEF.Duik.Rigging.extractLocator = function( locator, preCompLayer, useMasterProperties )
{
    if (DuAEF.DuAE.App.version.version < 15.1) useMasterProperties = false;
	if (DuAEF.DuAE.App.version.version < 17.0) useMasterProperties = def( useMasterProperties, false );
	else useMasterProperties = def( useMasterProperties, true );

    var comp = preCompLayer.containingComp;
    //comp names
    DuAEF.DuAE.Comp.setUniqueCompName( comp );
    DuAEF.DuAE.Comp.setUniqueCompName( locator.containingComp );
    //apply locator values to workaround all kind of bugs
    locator.transform.anchorPoint.setValue( locator.transform.anchorPoint.valueAtTime(0, false));
    locator.transform.position.setValue( locator.transform.position.valueAtTime(0, false));
    locator.transform.scale.setValue( locator.transform.scale.valueAtTime(0, false));
    locator.transform.rotation.setValue( locator.transform.rotation.valueAtTime(0, false));
    locator.transform.opacity.setValue( locator.transform.opacity.valueAtTime(0, false));
    //create a null in the comp
    var loc = comp.layers.addNull();
    loc.name = DuAEF.DuAE.Comp.newUniqueLayerName( locator.name, comp );
    loc.parent = preCompLayer;
    DuAEF.Dugr.addLayerToGroup( loc, "Locators" );
    DuAEF.Duik.setDuikMarker( loc, "Locator", DuAEF.Duik.LayerTypes.LOCATOR );
    if (useMasterProperties) {
        DuAEF.DuAE.Property.addToEGP(locator.transform);
        // get master properties
        var mps = DuAEF.DuAE.Property.getProps(preCompLayer('ADBE Layer Overrides'), PropertyType.PROPERTY );
        var it = new Iterator(mps);
        //links
        it.do( function(mp) {
            //get prop name
            var nameArray = mp.name.split(' / ');
            if ( nameArray.length != 2 ) return;
            var pLink = nameArray[1];
            var layerName = nameArray[0];
            if ( layerName != locator.name ) return;
            var newProp = null;
            try {
                newProp = eval('loc' + pLink);
            }
            catch (e) { return; }

            //link
            if (newProp) {
                DuAEF.DuAE.Property.pickWhip(newProp, mp, true);
            }
        });
    } else {
        DuAEF.DuAE.Property.linkProperties( loc.transform, locator.transform );
    }
    return loc;
}

/**
 * Sets the current values of the locator. This fixes some bugs when unparenting layers parented to the locators.
 * @param {AVLayer} locator - The locator layer
 * @param {boolean} [disable=true] - Wether to disable the expressions after having applied the values
 */
DuAEF.Duik.Rigging.applyLocatorValues = function ( locator, disable )
{
    disable = def(disable, true);
    var l = locator.locked;
    DuAEF.DuAE.Property.setValue(locator.transform.anchorPoint, locator.transform.anchorPoint.valueAtTime(0, false), 0);
    DuAEF.DuAE.Property.setValue(locator.transform.position, locator.transform.position.valueAtTime(0, false), 0);
    DuAEF.DuAE.Property.setValue(locator.transform.scale, locator.transform.scale.valueAtTime(0, false), 0);
    DuAEF.DuAE.Property.setValue(locator.transform.rotation, locator.transform.rotation.valueAtTime(0, false), 0);
    DuAEF.DuAE.Property.setValue(locator.transform.opacity, locator.transform.opacity.valueAtTime(0, false), 0);
    if (disable) DuAEF.Duik.Rigging.disableLocator( locator );
    locator.locked = l;
}

/**
 * Disables the locator. Disable the transform expressions
 * @param {AVLayer} locator - The locator layer
 * @param {boolean} [disable=true] - Wether to disable the expressions after having applied the values
 */
DuAEF.Duik.Rigging.disableLocator = function (locator, disable)
{
    disable = def(disable, true);
    var l = locator.locked;
    locator.transform.anchorPoint.expressionEnabled = !disable;
    locator.transform.position.expressionEnabled = !disable;
    locator.transform.scale.expressionEnabled = !disable;
    locator.transform.rotation.expressionEnabled = !disable;
    locator.transform.opacity.expressionEnabled = !disable;
    locator.locked = l;
}

/**
 * Disables the locators. Disable the transform expressions
 * @param {CompItem} [comp] - The composition containing the locators
 * @param {boolean} [disable=true] - Wether to disable the expressions after having applied the values
 */
DuAEF.Duik.Rigging.disableLocators = function (comp, disable)
{
    comp = def(comp, DuAEF.DuAE.Project.getActiveComp());
    disable = def(disable, true);
    if (!comp) return;
    var locators = DuAEF.Duik.getLayers( DuAEF.Duik.LayerTypes.LOCATOR, false, comp );
    new Iterator(locators).do(function(locator) {
        DuAEF.Duik.Rigging.disableLocator(locator, disable)
        });
}

/**
 * Sets the current values of the locators. This fixes some bugs when unparenting layers parented to the locators.
 * @param {CompItem} [comp] - The composition containing the locators
 * @param {boolean} [disable=true] - Wether to disable the expressions after having applied the values
 */
DuAEF.Duik.Rigging.applyLocatorsValues = function ( comp, disable )
{
    comp = def(comp, DuAEF.DuAE.Project.getActiveComp());
    disable = def(disable, true);
    if (!comp) return;
    var locators = DuAEF.Duik.getLayers( DuAEF.Duik.LayerTypes.LOCATOR, false, comp );
    new Iterator(locators).do(function(locator) {
        DuAEF.Duik.Rigging.applyLocatorValues(locator, disable)
        });
}

/**
 * Parents two layers even if the parent is in the parent comp or a precomp.
 * @param {Layer[]} children - The child layer(s)
 * @param {Layer} parent - The parent layer
 * @param {boolean} [useMasterProperties=true] - Only when the parent is in the precomposition (and not a "parent" composition), true to use master properties instead of expressions (ignored in Ae < 15.1, false by default if 15.1 <= Ae < 17 and true by default in Ae >= 17)
 */
DuAEF.Duik.Rigging.parent = function( children, parent, useMasterProperties )
{
    if ( typeof children === 'undefined' ) throw "You must provide children to parent.";
    if ( typeof children.length === 'undefined' ) children = [ children ];

    var parentComp = parent.containingComp;

    //create the parent locator
    var locator = DuAEF.Duik.Rigging.addLocator( parent );
    //the children locators
    var childLocators = [];

    new Iterator( children ).do( function( child )
    {
        var childComp = child.containingComp;

        //check if there already is a child locator
        var childLocator = null;
        for ( var i = 0, num = childLocators.length; i < num; i++ )
        {
            if ( childLocators[ i ].containingComp.id == childComp.id )
            {
                childLocator = childLocators[ i ];
                break;
            }
        }

        //if precomp
        var precomps = DuAEF.DuAE.Comp.getPrecomps( childComp );

        if ( DuAEF.DuJS.Array.indexOf( precomps, parentComp ) >= 0 )
        {
            //select the first precomp layer
            var precompLayer;
            for ( var i = 1, num = childComp.numLayers; i <= num; i++ )
            {
                var l = childComp.layer( i );
                if ( l.source )
                {
                    if ( l.source.id == parentComp.id )
                    {
                        precompLayer = l;
                        break;
                    }
                }
            }

            //create the child Locator
            if ( !childLocator )
            {
                //create a locator and extract it
                var childLocator = DuAEF.Duik.Rigging.extractLocator( locator, precompLayer, useMasterProperties );
                childLocator.selected = false;
                childLocator.enabled = false;
                childLocator.shy = true;
                childLocator.locked = true;
                childLocators.push( childLocator );
            }
            var locked = child.locked;
            child.locked = false;
            child.parent = childLocator;
            child.locked = locked;
            child.selected = true;
            return;
        }

        //if parent comp
        var parentComps = DuAEF.DuAE.Comp.getParentComps( childComp );
        if ( DuAEF.DuJS.Array.indexOf( parentComps, parentComp ) >= 0 )
        {
            //select the first precomp layer
            var precompLayer;
            for ( var i = 1, num = parentComp.numLayers; i <= num; i++ )
            {
                var l = parentComp.layer( i );
                if ( l.source == childComp )
                {
                    precompLayer = l;
                    break;
                }
            }

            //create a locator and extract it
            locator.parent = precompLayer;

            //create the child Locator
            if ( !childLocator )
            {
                //create a null in the comp
                var childLocator = childComp.layers.addNull();
                childLocator.name = DuAEF.DuAE.Comp.newUniqueLayerName( locator.name, childComp );
                DuAEF.Duik.setDuikMarker( childLocator, "Locator", DuAEF.Duik.LayerTypes.LOCATOR );
                DuAEF.DuAE.Property.linkProperties( childLocator.transform, locator.transform, undefined, precompLayer );
                //lock and hide
                childLocator.selected = false;
                childLocator.enabled = false;
                childLocator.shy = true;
                childLocator.locked = true;
                childLocators.push( childLocator );
            }

            child.parent = childLocator;
            child.selected = true;

            return;
        }

    } );

    //lock and hide
    locator.selected = false;
    locator.enabled = false;
    locator.locked = true;
    locator.shy = true;
    parent.selected = true;

}

/**
 * Adds an orientation constraint to a layer
 * @param {Layer} layer - The layer
 */
DuAEF.Duik.Rigging.orientationConstraint = function( layer )
{
    var effect = DuAEF.Duik.PseudoEffects.ORIENTATION.apply( layer );
    var index = DuAEF.Duik.PseudoEffects.ORIENTATION.index;

    layer.rotation.expression = [DuAEF.Duik.expressionIds.ORIENTATION,
        DuAEF.DuExpression.get(['sign','getOrientation','dishineritRotation','checkDuikEffect']),
        'var result = dishineritRotation( thisLayer );',
        'for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
        '    var fx = effect( i );',
        '    if ( !checkDuikEffect(fx, "' + effect.matchName.replace('Pseudo/','') + '") ) continue;',
        '    var l = null;',
        '    try {',
        '        l = fx(' + index['Constraint to_Layer'] + ');',
        '    } catch ( e ) {}',
        '    if ( l ) result += getOrientation( l ) * ( fx(' + index['Weight_Slider'] + ').value / 100 );',
        '}',
        'result;',
        ''
        ].join('\n');

}

/**
 * Adds a position constraint to a layer
 * @param {Layer} layer - The layer
 */
DuAEF.Duik.Rigging.positionConstraint = function( layer )
{
    var effect = DuAEF.Duik.PseudoEffects.POSITION.apply( layer );
    var index = DuAEF.Duik.PseudoEffects.POSITION.index;
    effect( index['Weight_Slider'] ).setValue( 0 );

    layer.position.expression = [DuAEF.Duik.expressionIds.POSITION,
        DuAEF.DuExpression.get(['checkDuikEffect']),
        'var result = value;',
        'for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
        '    var fx = effect( i );',
        '    if ( !checkDuikEffect(fx, "' + effect.matchName.replace('Pseudo/','') + '") ) continue;',
        '    var l = null;',
        '    try {',
        '        l = fx( ' + index['Constraint to_Layer'] + ' );',
        '    } catch ( e ) {}',
        '    if ( l ) {',
        '        var cp = l.toWorld( l.anchorPoint );',
        '        if ( thisLayer.hasParent ) cp = thisLayer.parent.fromWorld( cp );',
        '        cp0 = l.toWorld( l.anchorPoint, 0 );',
        '        if ( thisLayer.hasParent ) cp0 = thisLayer.parent.fromWorld( cp0 );',
        '        cp -= cp0;',
        '        result += cp * ( fx( ' + index['Weight_Slider'] + ' ).value / 100 );',
        '    }',
        '}',
        'result;',
        ''
        ].join('\n');
}

/**
 * Adds a path constraint to a layer
 * @param {Layer} layer - The layer
 * @param {Property|PropertyInfo} path - The path property
 */
DuAEF.Duik.Rigging.pathConstraint = function( layer, path )
{
    if ( path instanceof PropertyInfo ) path = path.getProperty();

    var effect = DuAEF.Duik.PseudoEffects.PATH.apply( layer );

    var l = DuAEF.DuAE.Property.getLayer( path );
    var pathExpr = DuAEF.DuAE.Property.getExpressionLink( path, true );

    var expr = [ DuAEF.Duik.expressionIds.PATH,
        'var fx = effect("' + effect.name + '");',
        'var l = thisComp.layer("' + l.name + '");',
        'var p = ' + pathExpr + ';',
        'var percent = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['Percent along path_Slider'] + ').value % 100 / 100;',
        'if (percent == 0) percent = 0.0001;',
        'var pathOffset = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['Path Offset_Slider']  + ').value;',
        '// path value',
        'var result = l.toWorld( p.pointOnPath(percent, time ) +  p.normalOnPath(percent, time) * pathOffset );',
        'if (hasParent) result = parent.fromWorld(result);',
        '//layer position',
        'result += value;'
        ].join('\n');

    DuAEF.DuAE.Property.setExpression( layer.position, expr );

    expr = [ DuAEF.Duik.expressionIds.PATH,
        'var fx = effect("' + effect.name + '");\n' +
        'var autoOrient = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['Orientation_Checkbox'] + ').value;\n' +
        'var result = value;\n' +
        'if (autoOrient)\n' +
        '{',
        'var l = thisComp.layer("' + l.name + '");',
        'var p = ' + pathExpr + ';\n' +
        'var percent = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['Percent along path_Slider'] + ').value % 100 / 100;\n' +
        'var C = p.tangentOnPath(percent, time);',
        'var angle = Math.atan2(C[1], C[0]);',
        'angle = radiansToDegrees(angle);',
        'angle += l.rotation.value;',
        'result += angle;',
        '}',
        'result;'
        ].join('\n');
    
    DuAEF.DuAE.Property.setExpression( layer.rotation, expr );
}

/**
 * Adds a parent constraint to a layer
 * @param {Layer} layer - The layer
 */
DuAEF.Duik.Rigging.parentConstraint = function( layer )
{
	var effect = DuAEF.Duik.PseudoEffects.PARENT.apply(layer);
    var index = DuAEF.Duik.PseudoEffects.PARENT.index;

    var posExpr = [DuAEF.Duik.expressionIds.PARENT,
        DuAEF.DuExpression.get(['translatePointWithLayer','checkDuikEffect']),
        'var result = thisLayer.position.valueAtTime( 0 );',
        'var mbPrecision = 1;',
        'var step = framesToTime(1);',
        'var cT = 0;',
        'while ( cT < time ) {',
        '    cT += step;',
        '    var roundedFrame = Math.round( timeToFrames(cT) );',
        '    var roundedTime = roundedFrame * thisComp.frameDuration;',
        '    if (cT - roundedTime < 0.0001) cT = roundedTime;',
        '',
        '	for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
        '		var fx = effect( i );',
        '		if ( !checkDuikEffect(fx, "' + effect.matchName.replace('Pseudo/','') + '") ) continue;',
        '		if ( !fx(' + index['Inheritance_Position_Checkbox'] + ').value ) continue;',
        '		var parentLayer = null;',
        '		try {',
        '			parentLayer = fx(' + index['Layer_Layer'] + ');',
        '		} catch ( e ) {',
        '			continue;',
        '		}',
        '',
        '		mbPrecision = fx(' + index['Motion Blur Precision_Slider'] + ').value;',
        '		step = framesToTime(1)/mbPrecision;',
        '',
        '        if ( !parentLayer ) continue;',
        '        if ( parentLayer.index == index ) continue;',
        '        var weight = fx(' + index['Weight_Slider'] + ').valueAtTime( cT ) / 100;',
        '        if ( weight == 0 ) continue;',
        '        result += translatePointWithLayer( parentLayer, result, cT - step, cT ) * weight;',
        '    }',
        '    result += valueAtTime( cT ) - valueAtTime( cT - step );',
        '}',
        'result;'
        ].join('\n');

	if (layer.position.dimensionsSeparated)
	{
		layer.transform.xPosition.expression = posExpr + '\nresult[0];';

		layer.transform.yPosition.expression = posExpr + '\nresult[1];';
        if (layer.threeDLayer) layer.transform.zPosition.expression = posExpr + '\nresult[2];';
	}
	else
	{
		layer.position.expression = posExpr;
	}

    var rotExpression = [DuAEF.Duik.expressionIds.PARENT,
        DuAEF.DuExpression.get(['getOrientationAtTime','checkDuikEffect']),
        'var result = value;',
        'for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
        '    var fx = effect( i );',
        '    if ( !checkDuikEffect(fx, "' + effect.matchName.replace('Pseudo/','') + '") ) continue;',
        '    if ( !fx(' + index['Inheritance_Rotation_Checkbox'] + ').value ) continue;',
        '    var l = null;',
        '    try {',
        '        l = fx(' + index['Layer_Layer'] + ');',
        '    } catch ( e ) {',
        '        continue;',
        '    }',
        '    if ( !l ) continue;',
        '    if ( l.index == index ) continue;',
        '    if ( fx(' + index['Weight_Slider'] + ').numKeys < 2 ) {',
        '        var w = fx(' + index['Weight_Slider'] + ').value / 100;',
        '        if ( w == 0 ) continue;',
        '        var P = getOrientationAtTime( l, time );',
        '        var oP = getOrientationAtTime( l, 0 );',
        '        result += ( P - oP ) * w;',
        '    } else {',
        '        var cT = time ;',
		'        var step = framesToTime(1) / fx(' + index['Motion Blur Precision_Slider'] + ').value;',
        '        while (cT > 0) {',
        '            var prevT = cT - step;',
        '            var w = fx(' + index['Weight_Slider'] + ').valueAtTime( cT ) / 100;',
        '            var P = getOrientationAtTime( l, cT );',
        '            var oP = getOrientationAtTime( l, prevT );',
        '            result += ( P - oP ) * w;',
        '            cT = cT - step;',
        '        }',
        '    }',
        '}',
        'result;'
        ].join('\n');

	layer.rotation.expression = rotExpression

	if (layer.parent != null)
	{
		var comp = layer.containingComp;
		var time = comp.time;
		comp.time = 0;
		var parent = layer.parent;
		layer.parent = null;
		effect(1).setValue(parent.index);
		comp.time = time;
	}
}

/**
 * Checks if the property can be used as parent with the connector
 * @param {Property|PropertyInfo} prop - The property
 * @return {int} 0 if the prop can not be used as parent, or the number of the dimensions of the property (4 = color)
 */
DuAEF.Duik.Rigging.connectorCheckParent = function( prop )
{
    if ( !( prop instanceof PropertyInfo ) ) prop = new PropertyInfo( prop );
    if ( prop.getProperty().propertyType != PropertyType.PROPERTY ) return 0;

    //check dimensions
    var dim = DuAEF.DuAE.Property.getDimensions( prop );
    return dim;
}

/**
 * Applies connector to the property
 * @param {Property|PropertyInfo} childProp - The child property
 * @param {Property|PropertyInfo} parentProp - The parent property
 * @param {PropertyGroup|PropertyInfo|null} [parentEffect] - The effect of an already existing connector
 * @param {float} [minValue=0] - The minimum value
 * @param {float} [maxValue=100] - The maximum value
 * @param {DuAEF.DuAE.Axis} [axis=DuAEF.DuAE.Axis.X] - The axis or channel to connect
 * @param {DuAEF.DuAE.Types} [axis=DuAEF.DuAE.Types.VALUE] - The type
 * @return {PropertyGroup} The controlling effect created
 */
DuAEF.Duik.Rigging.connector = function( childProp, parentProp, parentEffect, minValue, maxValue, axis, type )
{
    minValue = def ( minValue, null );
    maxValue = def ( maxValue, null );
    axis = def ( axis, DuAEF.DuAE.Axis.X );
    type = def ( type, DuAEF.DuAE.Types.VALUE );
    parentEffect = def ( parentEffect, null );

    childProp = new PropertyInfo( childProp );
    var parentProp = new PropertyInfo( parentProp );

    DuAEF.DuAE.Comp.setUniqueCompName( parentProp.comp );
    DuAEF.DuAE.Comp.setUniqueCompName( childProp.comp );

    if ( !childProp.riggable ) return null;

    var dim = DuAEF.Duik.Rigging.connectorCheckParent( parentProp );
    if ( dim == 0 ) return null;

    var parentLayer = DuAEF.DuAE.Property.getLayer( parentProp );

    //Adjust minimum value
    if ( !isNaN( minValue ) )
    {
        if ( dim == 4 )
        {
            if ( app.project.bitsPerChannel == 8 ) minValue = minValue / 255;
            if ( app.project.bitsPerChannel == 16 ) minValue = minValue / 32768;
            if ( app.project.bitsPerChannel == 32 && minValue < 0 ) minValue = 0;
            if ( app.project.bitsPerChannel == 32 && minValue > 1 ) minValue = 1;
        }
    }
    else minValue = 0;

    //adjust maximum value
    if ( !isNaN( maxValue ) )
    {
        if ( dim == 4 )
        {
            if ( app.project.bitsPerChannel == 8 ) maxValue = maxValue / 255;
            if ( app.project.bitsPerChannel == 16 ) maxValue = maxValue / 32768;
            if ( app.project.bitsPerChannel == 32 && maxValue < 0 ) maxValue = 0;
            if ( app.project.bitsPerChannel == 32 && maxValue > 1 ) maxValue = 1;
        }
    }
    else maxValue = 100;

    //adjust type
    if ( type == DuAEF.DuAE.Types.VELOCITY ) type = 2;
    else type = 1;

    //adjust axis
    if ( axis == DuAEF.DuAE.Axis.Y ) axis = 2;
    else if ( axis == DuAEF.DuAE.Axis.Z ) axis = 3;
    else if ( axis == DuAEF.DuAE.Axis.RED ) axis = 1;
    else if ( axis == DuAEF.DuAE.Axis.GREEN ) axis = 2;
    else if ( axis == DuAEF.DuAE.Axis.BLUE ) axis = 3;
    else if ( axis == DuAEF.DuAE.Axis.ALPHA ) axis = 4;
    else if ( axis == DuAEF.DuAE.Axis.HUE ) axis = 5;
    else if ( axis == DuAEF.DuAE.Axis.SATURATION ) axis = 6;
    else if ( axis == DuAEF.DuAE.Axis.VALUE ) axis = 7;

	var connectorLayer = DuAEF.Duik.Rigging.getConnectorLayer( parentProp.comp );

    //try to find an existing effect
    if ( !parentEffect )
    {
        var connectorEffects = connectorLayer.property( 'ADBE Effect Parade' );
        var matchName = DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.matchName;
        if ( dim == 2 ) matchName = DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.matchName;
        else if ( dim == 3 ) matchName = DuAEF.Duik.PseudoEffects.THREED_CONNECTOR.matchName;
        else if ( dim == 4 ) matchName = DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.matchName;

        var effects = DuAEF.DuAE.Property.getProps( connectorEffects, matchName, true );

        //check if there is one with the same params
        for ( var i = 0, num = effects.length; i < num; i++ )
        {
            var effect = effects[ i ].getProperty();
            if ( effect.property( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.minimumSlider ).value != minValue ) continue;
            if ( effect.property( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider ).value != maxValue ) continue;
            if ( effect.property( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.connexionModePopup ).value != type ) continue;
            if ( dim > 1 )
                if ( effect.property( DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.axisPopup ).value != axis ) continue;

            //if all tests passed, this is the one!
            parentEffect = effect;
            break;
        }
    }

    //if not found, create
    if ( !parentEffect )
    {
        if ( dim == 1 ) parentEffect = DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );
        else if ( dim == 2 ) parentEffect = DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );
        else if ( dim == 3 ) parentEffect = DuAEF.Duik.PseudoEffects.THREED_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );
        else if ( dim == 4 ) parentEffect = DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );

        if ( dim != 4 ) parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider ).setValue( 100 );
        else parentEffect( DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.maximumSlider ).setValue( 1 );
    }

    parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.minimumSlider ).setValue( minValue );
    parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider ).setValue( maxValue );
    parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.connexionModePopup ).setValue( type );
    if ( dim > 1 ) parentEffect( DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.axisPopup ).setValue( axis );

    // the expression

    // check if the current comp is the same than the comp containing the masterProperty
    var parentComp = parentLayer.containingComp;
    var childComp = DuAEF.DuAE.Property.getComp( childProp );
    var comp = 'thisComp.';
    if ( parentComp !== childComp ) comp = 'comp("' + parentComp.name + '").';

    var expr = '//Duik.connector\n' +
        'var ctrlLayer = ' + comp + 'layer("' + parentLayer.name + '");\n' +
        'var connectorLayer = ' + comp + 'layer("' + connectorLayer.name + '");\n' +
        'var ctrlValue = ctrlLayer' + DuAEF.DuAE.Property.getExpressionLink( parentProp.getProperty(), false, false ) + ';\n' +
        'var ctrlEffect = connectorLayer.effect("' + parentEffect.name + '");\n' +
        'var ctrlMin = ctrlEffect(2).value;\n' +
        'var ctrlMax = ctrlEffect(3).value;\n' +
        'var result = value;\n' +
        'if (numKeys >= 2 && ctrlEffect.enabled)\n' +
        '{\n' +
        'var useVelocity = ctrlEffect(1).value == 2;\n' +
        'if (useVelocity) ctrlValue = ctrlValue.velocity;\n' +
        'else ctrlValue = ctrlValue.value;\n';
    if ( parentProp.isAngle )
    {
        expr += 'if (!useVelocity) ctrlValue = ctrlValue % 360;\n';
    }
    else if ( dim == 2 || dim == 3 )
    {
        expr += 'var axis = ctrlEffect(4).value-1;\n' +
            'ctrlValue = ctrlValue[axis];\n';
    }
    else if ( dim == 4 )
    {
        expr += 'var axis = ctrlEffect(4).value;\n' +
            'if (axis == 1) ctrlValue = ctrlValue[0];\n' +
            'else if (axis == 2) ctrlValue = ctrlValue[1];\n' +
            'else if (axis == 3) ctrlValue = ctrlValue[2];\n' +
            'else if (axis == 4) ctrlValue = ctrlValue[3];\n' +
            'else \n' +
            '{\n' +
            'ctrlValue = rgbToHsl(ctrlValue);\n' +
            'if (axis == 5) ctrlValue = ctrlValue[0];\n' +
            'else if (axis == 6) ctrlValue = ctrlValue[1];\n' +
            'else if (axis == 7) ctrlValue = ctrlValue[2];\n' +
            '}';
    }
    expr += 'var t = 0;\n' +
        'var beginTime = key(1).time;\n' +
        'var endTime = key(numKeys).time;\n' +
        'if (ctrlMin > ctrlMax)\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, endTime, beginTime);\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, beginTime, endTime);\n' +
        '}\n' +
        'result = valueAtTime(t);\n' +
        '}\n' +
        'result;';

    
    var prop = childProp.getProperty();
    prop.expression = expr;
    if ( prop.matchName == "ADBE Opacity" ) childProp.layer.enabled = true;

    return parentEffect;
}

/**
 * Gets (or create) the controller layer for the connectors of the comp
 * @param {CompItem} [comp] - The comp. The active composition by default.
 * @return {AVLayer} The connector layer
 */
DuAEF.Duik.Rigging.getConnectorLayer = function( comp )
{
	if (typeof comp === 'undefined') comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) throw "DuAEF.Duik.Rigging.getConnectorLayer()\nneeds a composition to get the connector layer";

	var connectorLayer = DuAEF.Duik.getLayer(DuAEF.Duik.LayerTypes.CONNECTOR, false, comp);
	//create
	if ( connectorLayer == null )
	{
		var connectorCtrl = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.CONNECTOR );
		connectorLayer = connectorCtrl.layer;
		DuAEF.Duik.setDuikMarker(connectorLayer,"Connector",DuAEF.Duik.LayerTypes.CONNECTOR);
	}

	return connectorLayer;
}

/**
 * Applies connector to the property, creating a controller layer (or using any existing one) with a slider in the effects
 * @param {Property[]|PropertyInfo[]} childProps - The child property
 */
DuAEF.Duik.Rigging.quickConnector = function( childProps )
{
    var childProp = childProps[ childProps.length - 1 ];
    if ( !( childProp instanceof PropertyInfo ) ) childProp = new PropertyInfo( childProp );
    //look for the connector layer in this comp, or create one
    var connectorLayer = null;
    var comp = childProp.comp;
    var ctrls = DuAEF.Duik.Controller.getControllers( comp );
    for ( var i = 0, num = ctrls.length; i < num; i++ )
    {
        var ctrl = ctrls[ i ].layer;
        if ( ctrl.property( 'ADBE Effect Parade' ).property( DuAEF.Duik.PseudoEffects.QUICK_CONNECTOR.matchName ) )
        {
            connectorLayer = ctrl;
            break;
        }
    }
    //create if needed
    if ( connectorLayer == null )
    {
        var connectorCtrl = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.CONNECTOR );
        connectorLayer = connectorCtrl.layer;
    }
    //create effect
    var prop = childProp.getProperty();
    var childLayer = childProp.layer;
    var connectorEffect = DuAEF.Duik.PseudoEffects.QUICK_CONNECTOR.apply( connectorLayer, childLayer.name + ' | ' + prop.parentProperty.name );

    var expr = '//Duik.connector\n' +
        'var ctrlLayer = thisComp.layer("' + connectorLayer.name + '");\n' +
        'var ctrlEffect = ctrlLayer.effect("' + connectorEffect.name + '");\n' +
        'var ctrlValue = ctrlEffect(' + DuAEF.Duik.PseudoEffects.QUICK_CONNECTOR.connectorSlider + ');\n' +
        'var ctrlMin = 0;\n' +
        'var ctrlMax = 100;\n' +
        'var result = value;\n' +
        'if (numKeys >= 2 && ctrlEffect.enabled)\n' +
        '{\n' +
        'ctrlValue = ctrlValue.value;\n' +
        'var t = 0;\n' +
        'var beginTime = key(1).time;\n' +
        'var endTime = key(numKeys).time;\n' +
        'if (ctrlMin > ctrlMax)\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, endTime, beginTime);\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, beginTime, endTime);\n' +
        '}\n' +
        'result = valueAtTime(t);\n' +
        '}\n' +
        'result;';


    var it = new Iterator( childProps );
    it.do( function( childProp )
    {
        if ( !( childProp instanceof PropertyInfo ) ) childProp = new PropertyInfo( childProp );
        if ( !childProp.riggable ) return;

        childProp.getProperty().expression = expr;
    } );
}

/**
 * Creates an IK and its controller on the layers/the structure.
 * @param {Layer[]|Structure} layers - The layers, already parented or ordered from goal (at index 0) to root (including the goal)
 * @param {Layer|Controller|null} [controller] - An already existing controller.
 * @param {boolean} [forceBezier=false] - force the use of a bezier IK even with two or three layers
 * @param {boolean} [threeAsOneAndTwo=true] - when rigging three layers, true to rig using a one-layer IK followed by a two-layer IK instead of a three-mayer IK
 * @return {Controller[]} The controller(s) of the IK.
 */
DuAEF.Duik.Rigging.ik = function( layers, controller, forceBezier, threeAsOneAndTwo )
{
    controller = def(controller, null);
    forceBezier = def(forceBezier, false);
    threeAsOneAndTwo = def(threeAsOneAndTwo, true);
    if ( layers instanceof Structure ) layers = layers.elements;
    if ( layers.length < 1 ) return [];

    //check if there is a controller in the selection
    if ( controller == null )
    {
        if ( layers.length < 2 ) return [];
        for ( var i = 0; i < layers.length; i++ )
        {
            var l = layers[ i ];
            if ( DuAEF.Duik.isLayerType( l, DuAEF.Duik.LayerTypes.CONTROLLER ) )
            {
                controller = l;
                layers.splice( i, 1 );
                break;
            }
        }
    }

    //sort layers and parent them
    layers = DuAEF.DuAE.Layer.sortByParent( layers );
    //reset rotation and scale if structures
    var it = new Iterator( layers );
    it.do( DuAEF.Duik.Structure.resetTransform );
    DuAEF.DuAE.Layer.parentChain( layers );

    //check if the last one is a goal
    var withGoal = true;
    if ( typeof controller !== 'undefined' && controller != null )
    {
        var l = layers[ layers.length - 1 ];
        //check position
        var cL = controller;
        if ( controller instanceof Controller ) cL = controller.layer;
        else controller = new Controller( controller );
        var distance = DuAEF.DuAE.Layer.getDistance( cL, l );
        if ( distance > 10 ) withGoal = false;
    }
    var goal = null;
    if ( withGoal ) goal = layers.pop();

    if ( layers.length == 1 && !forceBezier ) controller = [ DuAEF.Duik.Rigging.oneLayerIK( layers[ 0 ], goal, controller ) ];
    else if ( layers.length == 2 && !forceBezier ) controller = [ DuAEF.Duik.Rigging.twoLayerIK( layers[ 0 ], layers[ 1 ], goal, controller ) ];
    else if ( layers.length == 3 && !forceBezier )
    {
        if ( threeAsOneAndTwo )
        {
            controller = DuAEF.Duik.Rigging.twoLayerIK( layers[ 1 ], layers[ 2 ], goal, controller );
            DuAEF.Duik.Rigging.oneLayerIK( layers[ 0 ], goal, controller );
            controller.layer.effect( DuAEF.Duik.PseudoEffects.ONELAYER_IK.matchName )( DuAEF.Duik.PseudoEffects.ONELAYER_IK.weightSlider ).setValue( 50 );
            controller = [ controller ];
        }
        else controller = [ DuAEF.Duik.Rigging.threeLayerIK( layers[ 0 ], layers[ 1 ], layers[ 2 ], goal, controller ) ];
    }
    else controller = DuAEF.Duik.Rigging.bezierIK( layers, goal, controller );

    return controller;
}

/**
 * Creates a one-layer-ik on the layer
 * @param {Layer} layer - The layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @return {Controller} The controller created
 */
DuAEF.Duik.Rigging.oneLayerIK = function( layer, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";
    var comp = layer.containingComp;

    var drawGuides = true;

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
    }
    if ( !( controller instanceof Controller ) )
    {
        drawGuides = false;
        controller = new Controller( controller );
    }

    //is right ?
    var ctrlPos = DuAEF.DuAE.Layer.getWorldPos( controller.layer );
    var layerPos = DuAEF.DuAE.Layer.getWorldPos( layer );

    var right = ( ctrlPos[ 0 ] - layerPos[ 0 ] ) < 0;

    //Add Effect
    var name = layer.name;
    if ( goal != null ) name = goal.name;
    var ikEffect = DuAEF.Duik.PseudoEffects.ONELAYER_IK.apply( controller.layer, DuAEF.Duik.generateName( 'IK', name ) );
    if ( right ) ikEffect( 6 ).setValue( 1 );
    ikEffect( 9 ).setValue( layer.index );

    if ( DuAEF.DuAE.App.version.version >= 15 && controller.layer instanceof ShapeLayer && drawGuides )
    {
        var lineGroup = controller.layer( "ADBE Root Vectors Group" ).property( 'IK Line' );
        if ( !lineGroup )
        {
            lineGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
            lineGroup.name = 'IK Line';
        }
        var lineContent = lineGroup.property( "ADBE Vectors Group" );
        var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
        shape( 'ADBE Vector Shape' ).expression = 'if (active){\n' +
            'var fx = effect("' + ikEffect.name + '");\n' +
            'var layer1 = null;\n' +
            'var result = [[0,0]];\n' +
            'if (fx(1).value && fx(12).value)\n' +
            '{\n' +
            'try{layer1 = fx(9);}catch(e){}\n' +
            'if (layer1!=null)\n' +
            '{\n' +
            'var l = layer1.toWorld(layer1.anchorPoint);\n' +
            'l = fromWorld(l);\n' +
            'result = [l,[0,0]];\n' +
            '}\n' +
            '}\n' +
            'createPath(result,[],[],false);\n' +
            '} else value;';
        var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
        var ctrlEffect = controller.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName );
        if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
    }

    //Add Data
    var layerData = DuAEF.DuAE.Layer.addPseudoEffect( layer, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layerData( 1 ).setValue( controller.layer.index );
    //Expression
    var expr = '//Duik.oneLayerIK\n' +
        'var ctrl = null;\n' +
        'var result = value;\n' +
        'try { ctrl = effect("' + layerData.name + '")(1); } catch (e){ value };\n' +
        'if (ctrl != null)\n' +
        '{\n' +
        'var C = ctrl.toWorld( ctrl.anchorPoint );\n' +
        'var O =  thisLayer.toWorld( thisLayer.anchorPoint );\n' +
        'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
        'W = fx(2).value/100;\n' +
        'FK = fx(3).value;\n' +
        'R = fx(6).value;\n' +
        'var useIK = fx(1).value;\n' +
        'var parentRot = fx(5).value;\n' +
        'result = value+FK;\n' +
        'if (useIK)\n' +
        '{\n' +
        'var vec = R == 1 ? O-C : C-O;\n' +
        'var layer = thisLayer;\n' +
        'if (layer.hasParent && parentRot) result += layer.parent.rotation.value;\n' +
        'while (layer.hasParent)\n' +
        '{\n' +
        'layer = layer.parent;\n' +
        'result = result - layer.rotation;\n' +
        '}\n' +
        'var angle = Math.atan2(vec[1], vec[0]);\n' +
        'angle = radiansToDegrees(angle);\n' +
        'angle = angle*W;\n' +
        'result += angle;\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    DuAEF.DuAE.Property.setExpression( layer.transform.rotation, expr );

    if ( goal != null )
    {
        var goalData = DuAEF.DuAE.Layer.addPseudoEffect( goal, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
        goalData( 1 ).setValue( controller.layer.index );
        expr = '//Duik.oneLayerIK.goal\n' +
            'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'var goal = ctrl.effect("' + ikEffect.name + '")(1).value;\n' +
            'result += ctrl.rotation.value;\n' +
            'if (goal)\n' +
            '{\n' +
            'var layer = thisLayer;\n' +
            'while (layer.hasParent)\n' +
            '{\n' +
            'layer = layer.parent;\n' +
            'result = result - layer.rotation;\n' +
            '}\n' +
            '}\n' +
            '}\n' +
            'result;';
        DuAEF.DuAE.Property.setExpression( goal.transform.rotation, expr );
    }

    return controller;
}

/**
 * Creates a two-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @return {Controller} The controller created
 */
DuAEF.Duik.Rigging.twoLayerIK = function( layer1, layer2, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";

    var comp = layer1.containingComp;

    var drawGuides = true;

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
        goal.parent = null;
        controller.layer.transform.rotation.setValue( goal.transform.rotation.value );
        goal.parent = layer2;
    }
    if ( !( controller instanceof Controller ) )
    {
        drawGuides = false;
        controller = new Controller( controller );
    }

    //Check if clockwise and lengths

    //unparent
    var rootParent = layer1.parent;
    layer1.parent = null;
    var middleParent = layer2.parent;
    layer2.parent = null;
    var endParent = controller.layer.parent;
    controller.layer.parent = null;

    var clockwise = false;

    var upperLength = DuAEF.DuJS.Math.getLength( layer1.transform.position.value, layer2.transform.position.value );
    var lowerLength = DuAEF.DuJS.Math.getLength( layer2.transform.position.value, controller.layer.transform.position.value );
    var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
    var middlePos = layer2.transform.position.value - layer1.transform.position.value;
    if ( endPos[ 0 ] == 0 && endPos[ 1 ] > 0 && middlePos[ 0 ] > 0 ) clockwise = true;
    else if ( endPos[ 0 ] == 0 && endPos[ 1 ] < 0 && middlePos[ 0 ] < 0 ) clockwise = true;
    else
    {
        var coef = endPos[ 1 ] / endPos[ 0 ];
        if ( middlePos[ 1 ] < middlePos[ 0 ] * coef && endPos[ 0 ] > 0 ) clockwise = true;
        if ( middlePos[ 1 ] > middlePos[ 0 ] * coef && endPos[ 0 ] < 0 ) clockwise = true;
    }

    //reparent
    layer1.parent = rootParent;
    layer2.parent = middleParent;
    controller.layer.parent = endParent;


    //add effect
    var name = layer2.name;
    if ( goal != undefined ) name = goal.name;
    var ikEffect = DuAEF.Duik.PseudoEffects.TWOLAYER_IK.apply( controller.layer, DuAEF.Duik.generateName( 'IK', name ) );
    if ( clockwise ) ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox ).setValue( 1 );

    //set layers
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer ).setValue( layer1.index );
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer ).setValue( layer2.index );
    if ( goal != undefined ) ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalLayer ).setValue( goal.index );

    //set lengths
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider ).setValue( upperLength );
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider ).setValue( lowerLength );

    //rotation limit
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fullRotationLimitAngle ).setValue( -180 );

    //inherit parent rotation
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox ).setValue( 1 );

    //get some useful coordinates
    var goalPos = [ 0, 0 ];
    if ( goal != null )
    {
        goalPos = goal.transform.position.value;
    }
    else
    {
        ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).expression = "thisComp.layer(" + layer2.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
        goalPos = ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).value;
        ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).expression = "";
    }
    DuAEF.DuAE.Property.setValue( ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ), goalPos );
    var rootAp = layer1.transform.anchorPoint.value.toSource();
    var middleAp = layer2.transform.anchorPoint.value.toSource();
    var middlePos = layer2.transform.position.value.toSource();

    //add expressions
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var result = 0;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperScaleSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value > 0)(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperStretchSlider + ').value+fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value)/fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value*100; else 100;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer2 = null;\n' +
        'var result = 0;\n' +
        'try{layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer2!=null)\n' +
        '{\n' +
        'newLength = length(layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value),layer2.toWorld(layer2.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerScaleSlider ).expression = 'var fx = effect("' + ikEffect.name + '"); if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value > 0)(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerStretchSlider + ').value+fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value)/fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value*100; else 100;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).expression = 'var result = value;\n' +
        'fx = effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.stretchSlider + ');\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'dist1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
        'dist2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        'IKLength = dist1+dist2;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist2/(IKLength);\n' +
        'posC = toWorld(anchorPoint);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
        'result = (' + goalPos.toSource() + ' -' + middleAp + ')*coef+' + middleAp + ';\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalWorldPositionPoint ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer2 = null;\n' +
        'var result = [0,0];\n' +
        'try{layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ')}catch(e){}\n' +
        'if (layer2!=null)\n' +
        '{\n' +
        'result = layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikLengthSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var result = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        'var goalPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalWorldPositionPoint + ').value;\n' +
        'var layer1 = null;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + '); } catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'result = length(layer1.toWorld(layer1.anchorPoint), goalPos);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.straightCheckbox ).expression = 'fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var result = false;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'var a = layer1.toWorld(layer1.anchorPoint);\n' +
        'var b = layer2.toWorld(layer2.anchorPoint);\n' +
        'var c = layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value);\n' +
        'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 1000;\n' +
        '}\n' +
        'result;';

    //add controller visual feedback
    if ( ( controller.layer instanceof ShapeLayer ) && drawGuides )
    {
        var ikGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        ikGroup.name = 'IK';
        var ikContent = ikGroup.property( "ADBE Vectors Group" );
        var shape = ikContent.addProperty( "ADBE Vector Shape - Group" );
        var ikShape = new Shape();
        ikShape.vertices = [
            [ -8, 16 ],
            [ 8, 16 ]
        ];
        ikShape.inTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.outTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.closed = false;

        var ctrlEffect = controller.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName );

        shape( 'ADBE Vector Shape' ).setValue( ikShape );
        var stroke = ikContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Opacity" ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
            'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.drawGuidesCheckbox + ').value) fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.straightCheckbox + ').value*100; else 0;';

        if (ctrlEffect) ikGroup.transform.scale.expression = '[effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + ')*2,effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + ')*2]';
        if (ctrlEffect) ikGroup.transform.position.expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Position_Point'] + ')';
        if (ctrlEffect) ikGroup.transform.opacity.expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Opacity_Slider'] + ')';

        if ( DuAEF.DuAE.App.version.version >= 15 )
        {
            var lineGroup = controller.layer( "ADBE Root Vectors Group" ).property( 'IK Line' );
            if ( !lineGroup )
            {
                lineGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
                lineGroup.name = 'IK Line';
            }
            var lineContent = lineGroup.property( "ADBE Vectors Group" );
            var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = 'if (active){\n' +
                'var fx = effect("' + ikEffect.name + '");\n' +
                'var layer1 = null;\n' +
                'var result = [[0,0]];\n' +
                'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value && fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.drawGuidesCheckbox + ').value)\n' +
                '{\n' +
                'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');}catch(e){}\n' +
                'if (layer1!=null)\n' +
                '{\n' +
                'var l = layer1.toWorld(layer1.anchorPoint);\n' +
                'l = fromWorld(l);\n' +
                'result = [l,[0,0]];\n' +
                '}\n' +
                '}\n' +
                'createPath(result,[],[],false);\n' +
                '} else value;';
            var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
            if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
            if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]';
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
        }
    }


    //setup layers
    var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect( layer1, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer1Data( 1 ).setValue( controller.layer.index );

    layer1.transform.rotation.expression = '//Duik.twoLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'function ik() \n' +
        '{\n' +
        'layer1 = thisLayer;\n' +
        'layer2 = null;\n' +
        'try{ layer2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + '); }  catch (e){return value;}\n' +
        'if (layer2 != null)\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
        'limit = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fullRotationLimitAngle + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'A = getWorldPos(layer1);\n' +
        'C = layer2.toWorld(endPos);\n' +
        'B = getWorldPos(layer2);\n' +
        'E = getWorldPos(controller);\n' +
        'a = length(B,C);\n' +
        'b = length(E,A);\n' +
        'c = length(A,B);\n' +
        'x = (b*b + c*c - a*a )/(2*b);\n' +
        'alpha = Math.acos(clamp(x/c,-1,1));\n' +
        'D = E - A;\n' +
        'delta = Math.atan2(D[1],D[0]);\n' +
        'result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n' +
        'V = B - A;\n' +
        'adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n' +
        'IK = result - adj1 + value;\n' +
        'if (IK < limit) IK+=360;\n' +
        'return IK;\n' +
        '}\n' +
        '}\n' +
        'function fk() {\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var FK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperAngle + ').value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fkAngle + ').value;\n' +
        'var p = thisLayer;\n' +
        'if (!follow)\n' +
        '{\n' +
        'while(p.hasParent)\n' +
        '{\n' +
        'p = p.parent;\n' +
        'FK -= p.rotation.value;\n' +
        '}\n' +
        '}\n' +
        'return FK;\n' +
        '}\n' +
        'result = IKFK ? ik() : fk();\n' +
        '}\n' +
        'result;';


    var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect( layer2, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer2Data( 1 ).setValue( controller.layer.index );


    layer2.transform.rotation.expression = '//Duik.twoLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = null;\n' +
        'layer2 = thisLayer;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(L)\n' +
        '{\n' +
        '	return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'A = getWorldPos(layer1);\n' +
        'B = getWorldPos(layer2);\n' +
        'C = layer2.toWorld(endPos);\n' +
        'E = getWorldPos(controller);\n' +
        'a = length(B,C);\n' +
        'b = length(E,A);\n' +
        'c = length(A,B);\n' +
        'x = (b*b + c*c - a*a )/(2*b);\n' +
        'alpha = Math.acos(clamp(x/c,-1,1));\n' +
        'y = b - x;\n' +
        'gamma = Math.acos(clamp(y/a,-1,1));\n' +
        'result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);  V1 = B - A;\n' +
        'adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n' +
        'V2 = C - B;\n' +
        'adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n' +
        'IK = result +  adj1 - adj2 + value;\n' +
        'return IK % 360;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fkAngle + ');\n' +
        'var delay = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.resistanceSlider + ').value ;\n' +
        'var amp = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.flexibilitySlider + ').value ;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.followThroughCheckbox + ').value;\n' +
        'if (!ftEnabled)\n' +
        '{\n' +
        'amp = 0;\n' +
        'delay = 0;\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        'delay = delay / 100;\n' +
        'amp = amp / 100 ;\n' +
        '}\n' +
        'FK = ctrlRot.valueAtTime(time-delay);\n' +
        'if (follow && hasParent)\n' +
        '{\n' +
        'var cP = layer1;\n' +
        'while(cP.hasParent)\n' +
        '{\n' +
        'cP = cP.parent;\n' +
        'FK -= cP.rotation.value - cP.rotation.valueAtTime(time-delay);\n' +
        '}\n' +
        '}\n' +
        'FK = FK - ctrlRot.value ;\n' +
        'FK = FK * amp;\n' +
        'FK = FK - ctrlRot.velocity*(delay/5);\n' +
        'FK += fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerAngle + ').value;\n' +
        'return FK;\n' +
        '}\n' +
        'result = IKFK ? ik() : fk();\n' +
        '}\n' +
        '}\n' +
        'result;';

    layer2.transform.position.expression = '//Duik.twoLayerIK.stretch\n' +
        'var ctrl = null;\n' +
        'var result = value;\n' +
        'try { ctrl = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
        'if (ctrl != null)\n' +
        '{\n' +
        'fx = ctrl.effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'result = [211, 25];\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'dist1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
        'dist2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        'IKLength = dist1+dist2;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist1/(IKLength);\n' +
        'posC = getWorldPos(ctrl);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
        'result = (' + middlePos + ' -' + rootAp + ')*coef+' + rootAp + ';\n' +
        '}\n' +
        '}\n' +
        'result;';

    if ( goal != null )
    {
        var goalData = DuAEF.DuAE.Layer.addPseudoEffect( goal, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
        goalData( 1 ).setValue( controller.layer.index );

        var rotExpr = [DuAEF.Duik.expressionIds.IK_GOAL,
            'var ctrl = null;',
            'try {',
            '    ctrl = effect( "' + goalData.name + '" )( 1 );',
            '} catch ( e ) {};',
            'if ( ctrl != null ) {',
            '    var fx = ctrl.effect( "' + ikEffect.name + '" );',
            '    var ikfk = fx( ' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ' ).value;',
            '',
            '    function ik() {',
            '        var IK = ctrl.rotation.value;',
            '        var layer = thisLayer;',
            '        while ( layer.hasParent ) {',
            '            layer = layer.parent;',
            '            IK = IK - layer.rotation;',
            '        }',
            '        return IK;',
            '    }',
            '',
            '    function fk() {',
            '        var FK = value;',
            '        var parentRot = parent.transform.rotation;',
            '        var delay = fx( ' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.resistanceSlider + ' ).value;',
            '        var amp = fx( ' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.flexibilitySlider + ' ).value;',
            '        var ftEnabled = fx( ' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.followThroughCheckbox + ' ).value;',
            '',
            '        delay = delay / 100;',
            '        amp = amp / 100;',
            '',
            '        if (ftEnabled)',
            '        {',
            '            FK = parentRot.valueAtTime( time - delay );',
            '            FK = FK * amp;',
            '        }',
            '        ',
            '        FK = FK + value + fx( ' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalAngle + ' );',
            '',
            '        if (ftEnabled)',
            '        {',
            '            FK = FK - parentRot.valueAtTime( 0 )',
            '        }',
            '        ',
            '        return FK;',
            '    }',
            '    ikfk ? ik() : fk();',
            '} else value;'
            ].join('\n');


        DuAEF.DuAE.Property.setExpression( goal.transform.rotation, rotExpr );

        goal.transform.position.expression = 'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'result = ctrl.effect("' + ikEffect.name + '")(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
            '}\n' +
            'result;';
    }

    return controller;
}

/**
 * Creates a three-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The middle layer
 * @param {Layer} layer3 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @return {Controller} The controller created
 */
DuAEF.Duik.Rigging.threeLayerIK = function( layer1, layer2, layer3, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";

    var comp = layer1.containingComp;

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
        goal.parent = null;
        controller.layer.transform.rotation.setValue( goal.transform.rotation.value );
        goal.parent = layer3;
    }
    if ( !( controller instanceof Controller ) ) controller = new Controller( controller );

    //Check if clockwise and lengths

    //unparent
    var rootParent = layer1.parent;
    layer1.parent = null;
    var middleParent = layer2.parent;
    layer2.parent = null;
    var endParent = controller.layer.parent;
    controller.layer.parent = null;

    var upperLength = DuAEF.DuJS.Math.getLength( layer1.transform.position.value, layer2.transform.position.value );
    var lowerLength = DuAEF.DuAE.Layer.getDistance( layer3, controller.layer );
    var middleLength = DuAEF.DuAE.Layer.getDistance( layer3, layer2 );
    var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
    var middlePos = layer2.transform.position.value - layer1.transform.position.value;
    var coef = endPos[ 1 ] / endPos[ 0 ];

    var clockwise = false;
    if ( middlePos[ 1 ] < middlePos[ 0 ] * coef && endPos[ 0 ] > 0 ) clockwise = true;
    if ( middlePos[ 1 ] > middlePos[ 0 ] * coef && endPos[ 0 ] < 0 ) clockwise = true;

    //reparent
    layer1.parent = rootParent;
    layer2.parent = middleParent;
    controller.layer.parent = endParent;


    //add effect
    var name = layer3.name;
    if ( goal != undefined ) name = goal.name;
    var ikEffect = DuAEF.Duik.PseudoEffects.THREELAYER_IK.apply( controller.layer, DuAEF.Duik.generateName( 'IK', name ) );
    if ( clockwise ) ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox ).setValue( 1 );

    //set layers
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer ).setValue( layer1.index );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer ).setValue( layer2.index );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer ).setValue( layer3.index );
    if ( goal != undefined ) ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalLayer ).setValue( goal.index );

    //set lengths
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider ).setValue( upperLength );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider ).setValue( middleLength );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider ).setValue( lowerLength );

    //rotation limit
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.fullRotationLimitAngle ).setValue( -180 );

    //get some useful coordinates
    var goalPos = [ 0, 0 ];
    if ( goal != null )
    {
        goalPos = goal.transform.position.value;
    }
    else
    {
        ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).expression = "thisComp.layer(" + layer3.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
        goalPos = ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).value;
        ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).expression = "";
    }
    DuAEF.DuAE.Property.setValue( ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ), goalPos );
    var rootAp = layer1.transform.anchorPoint.value.toSource();
    var middleAp = layer2.transform.anchorPoint.value.toSource();
    var lowerAp = layer3.transform.anchorPoint.value.toSource();
    var middlePos = layer2.transform.position.value.toSource();
    var lowerPos = layer3.transform.position.value.toSource();

    //add expressions
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var result = 0;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer2 = null;\n' +
        'var layer3 = null;\n' +
        'var result = 0;\n' +
        'try{layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');}catch(e){}\n' +
        'if (layer3!=null)\n' +
        '{\n' +
        'newLength = length(layer2.toWorld(layer2.anchorPoint),layer3.toWorld(layer3.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer3 = null;\n' +
        'var result = 0;\n' +
        'try{layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer3!=null)\n' +
        '{\n' +
        'newLength = length( fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value , layer3.toWorld(layer3.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchScaleSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'result = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperStretchSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleStretchSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerStretchSlider + ').value;\n' +
        'var o = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'result += o;\n' +
        'result = result / o * 100;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).expression = 'var result = value;\n' +
        'fx = effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'var upperAP = ' + rootAp + ';\n' +
        'var middlePos = ' + middlePos + ';\n' +
        'var middleAP = ' + middleAp + ';\n' +
        'var lowerPos = ' + lowerPos + ';\n' +
        'var lowerAP = ' + lowerAp + ';\n' +
        'var zeroPos = ' + goalPos.toSource() + ';\n' +
        'dist1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ');\n' +
        'dist2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ');\n' +
        'dist3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ');\n' +
        'IKLength = dist1+dist2+dist3;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist3/(IKLength);\n' +
        'posC = toWorld(anchorPoint);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist3 != 0 ? coef = (dist3+boneStretch)/dist3 : coef = 1;\n' +
        'result = (middlePos-upperAP)*coef+upperAP;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer3 = null;\n' +
        'var result = [0,0];\n' +
        'try{layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ')}catch(e){}\n' +
        'if (layer3!=null)\n' +
        '{\n' +
        'result = layer3.toWorld(fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikLengthSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var result = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var goalPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value;\n' +
        'var layer1 = null;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); } catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'result = length(layer1.toWorld(layer1.anchorPoint), goalPos);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.straightCheckbox ).expression = 'fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var layer3 = null;\n' +
        'var result = false;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'var a = layer1.toWorld(layer1.anchorPoint);\n' +
        'var b = layer2.toWorld(layer2.anchorPoint);\n' +
        'var c = layer3.toWorld(layer3.anchorPoint);\n' +
        'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 10 ;\n' +
        '}\n' +
        'result;';

    //add controller visual feedback
    if ( controller.layer instanceof ShapeLayer )
    {
        var ikGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        ikGroup.name = 'IK';
        var ikContent = ikGroup.property( "ADBE Vectors Group" );
        var shape = ikContent.addProperty( "ADBE Vector Shape - Group" );
        var ikShape = new Shape();
        ikShape.vertices = [
            [ -8, 16 ],
            [ 8, 16 ]
        ];
        ikShape.inTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.outTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.closed = false;
        shape( 'ADBE Vector Shape' ).setValue( ikShape );
        var stroke = ikContent.addProperty( "ADBE Vector Graphic - Stroke" );

        var ctrlEffect = controller.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName );

        if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Opacity" ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
            'if (fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.drawGuidesCheckbox + ').value) fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.straightCheckbox + ').value*100; else 0;';

        if (ctrlEffect) ikGroup.transform.scale.expression = '[effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + ')*2,effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + ')*2]';
        if (ctrlEffect) ikGroup.transform.position.expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Position_Point'] + ')';
        if (ctrlEffect) ikGroup.transform.opacity.expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Opacity_Slider'] + ')';

        if ( DuAEF.DuAE.App.version.version >= 15 )
        {
            var lineGroup = controller.layer( "ADBE Root Vectors Group" ).property( 'IK Line' );
            if ( !lineGroup )
            {
                lineGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
                lineGroup.name = 'IK Line';
            }
            var lineContent = lineGroup.property( "ADBE Vectors Group" );
            var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = 'if (active){\n' +
                'var fx = effect("' + ikEffect.name + '");\n' +
                'var layer1 = null;\n' +
                'var result = [[0,0]];\n' +
                'if (fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value && fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.drawGuidesCheckbox + ').value)\n' +
                '{\n' +
                'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');}catch(e){}\n' +
                'if (layer1!=null)\n' +
                '{\n' +
                'var l = layer1.toWorld(layer1.anchorPoint);\n' +
                'l = fromWorld(l);\n' +
                'result = [l,[0,0]];\n' +
                '}\n' +
                '}\n' +
                'createPath(result,[],[],false);\n' +
                '} else value;';
            var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
            if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
            if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]';
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
        }
    }

    //setup layers
    var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect( layer1, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer1Data( 1 ).setValue( controller.layer.index );

    layer1.transform.rotation.expression = '//Duik.threeLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = thisLayer;\n' +
        'layer2 = null;\n' +
        'layer3 = null;\n' +
        'try{ layer2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + '); layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
        'limit = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fullRotationLimitAngle + ').value;\n' +
        'function getWorldPos(layer)\n' +
        '{\n' +
        'return layer.toWorld(layer.anchorPoint);\n' +
        '}\n' +
        'function sq(result)\n' +
        '{\n' +
        'return result*result;\n' +
        '}\n' +
        'function getAngle(p1,p2)\n' +
        '{\n' +
        'var dist = p2-p1;\n' +
        'var angle = Math.atan2(dist[1],dist[0]);\n' +
        'return radiansToDegrees(angle);\n' +
        '}\n' +
        'var uPos = getWorldPos(layer1);\n' +
        'var mPos = getWorldPos(layer2);\n' +
        'var cPos = getWorldPos(controller);\n' +
        'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
        'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var ikLength = length(uPos,cPos);\n' +
        'if (ikLength == 0) ikLength = 1;\n' +
        'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
        'var d2 = sq(ikLength) * (uLength+lLength);\n' +
        'var d3 = -sq(ikLength) * uLength * lLength;\n' +
        'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
        'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
        'var upperA = cw ? -baseA : baseA ;\n' +
        'upperA = radiansToDegrees(upperA);\n' +
        'var uToC =getAngle(uPos,cPos);\n' +
        'var uToM =getAngle(uPos,mPos);\n' +
        'var ikResult = upperA + uToC - uToM;\n' +
        'if (ikResult < limit) ikResult +=360;\n' +
        'return ikResult;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var FK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperAngle + ').value;\n' +
        'FK += fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ').value;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var p = thisLayer;\n' +
        'if (!follow)\n' +
        '{\n' +
        'while(p.hasParent)\n' +
        '{\n' +
        'p = p.parent;\n' +
        'FK -= p.rotation.value;\n' +
        '}\n' +
        '}\n' +
        'return FK;\n' +
        '}\n' +
        'IKFK ? result += ik() : result += fk();\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect( layer2, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer2Data( 1 ).setValue( controller.layer.index );

    layer2.transform.rotation.expression = '//Duik.threeLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = null;\n' +
        'layer2 = thisLayer;\n' +
        'layer3 = null;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
        'FK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleAngle + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(layer)\n' +
        '{\n' +
        'return layer.toWorld(layer.anchorPoint);\n' +
        '}\n' +
        'function sq(result)\n' +
        '{\n' +
        'return result*result;\n' +
        '}\n' +
        'function getAngle(p1,p2)\n' +
        '{\n' +
        'var dist = p2-p1;\n' +
        'var angle = Math.atan2(dist[1],dist[0]);\n' +
        'return radiansToDegrees(angle);\n' +
        '}\n' +
        'var uPos = getWorldPos(layer1);\n' +
        'var mPos = getWorldPos(layer2);\n' +
        'var lPos = getWorldPos(layer3);\n' +
        'var cPos = getWorldPos(controller);\n' +
        'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
        'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var ikLength = length(uPos,cPos);\n' +
        'if (ikLength == 0) ikLength = 1;\n' +
        'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
        'var d2 = sq(ikLength) * (uLength+lLength);\n' +
        'var d3 = -sq(ikLength) * uLength * lLength;\n' +
        'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
        'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
        'var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));\n' +
        'var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));\n' +
        'middleA = cw ? -middleA : middleA ;\n' +
        'middleA = radiansToDegrees(middleA);\n' +
        'var uToM =getAngle(uPos,mPos);\n' +
        'var mToL =getAngle(mPos,lPos);\n' +
        'var ikResult = middleA + uToM - mToL +180;\n' +
        'return ikResult % 360;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
        'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
        'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
        'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleAngle + ').value;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
        'if (!ftEnabled)\n' +
        '{\n' +
        'amp = 0;\n' +
        'delay = 0;\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        'delay = delay / 100;\n' +
        'amp = amp / 100 ;\n' +
        '}\n' +
        'var FK = ctrlRot.valueAtTime(time-delay);\n' +
        'if (follow && hasParent)\n' +
        '{\n' +
        'var cP = parent;\n' +
        'while(cP.hasParent)\n' +
        '{\n' +
        'cP = cP.parent;\n' +
        'if (cP.index = controller.index) follow = false;\n' +
        'FK -= cP.rotation.value - cP.rotation.valueAtTime(time-delay) ;\n' +
        '}\n' +
        '}\n' +
        'FK = FK - ctrlRot.value ;\n' +
        'FK = FK * amp;\n' +
        'FK = FK - ctrlRot.velocity*(delay/5);\n' +
        'if (follow) result -= parent.transform.rotation.valueAtTime(0);\n' +
        'FK += manual;\n' +
        'return FK;\n' +
        '}\n' +
        'IKFK ? result += ik() : result += fk();\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    layer2.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try { controller = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
        'if (controller != null)\n' +
        '{\n' +
        'fx = controller.effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'var upperAP = ' + rootAp + ';\n' +
        'var middlePos = ' + middlePos + ';\n' +
        'var middleAP = ' + middleAp + ';\n' +
        'var lowerPos = ' + lowerPos + ';\n' +
        'var lowerAP = ' + lowerAp + ';\n' +
        'var zeroPos = ' + goalPos.toSource() + ';\n' +
        'dist1 = length(upperAP,middlePos);\n' +
        'dist2 = length(middleAP,lowerPos);\n' +
        'dist3 = length(lowerAP,zeroPos);\n' +
        'IKLength = dist1+dist2+dist3;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist1/(IKLength);\n' +
        'posC = getWorldPos(controller);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
        'result = (middlePos-upperAP)*coef+upperAP;\n' +
        '}\n' +
        '}\n' +
        'result;';


    var layer3Data = DuAEF.DuAE.Layer.addPseudoEffect( layer3, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer3Data( 1 ).setValue( controller.layer.index );

    layer3.transform.rotation.expression = '//Duik.threeLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer3Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = null;\n' +
        'layer2 = null;\n' +
        'layer3 = thisLayer;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); layer2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(layer)\n' +
        '{\n' +
        'return layer.toWorld(layer.anchorPoint);\n' +
        '}\n' +
        'function sq(result)\n' +
        '{\n' +
        'return result*result;\n' +
        '}\n' +
        'function getAngle(p1,p2)\n' +
        '{\n' +
        'var dist = p2-p1;\n' +
        'var angle = Math.atan2(dist[1],dist[0]);\n' +
        'return radiansToDegrees(angle);\n' +
        '}\n' +
        'var uPos = getWorldPos(layer1);\n' +
        'var mPos = getWorldPos(layer2);\n' +
        'var lPos = getWorldPos(layer3);\n' +
        'var zPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value;\n' +
        'var cPos = getWorldPos(controller);\n' +
        'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
        'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var ikLength = length(uPos,cPos);\n' +
        'if (ikLength == 0) ikLength = 1;\n' +
        'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
        'var d2 = sq(ikLength) * (uLength+lLength);\n' +
        'var d3 = -sq(ikLength) * uLength * lLength;\n' +
        'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
        'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
        'var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));\n' +
        'var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));\n' +
        'lowerA = cw ? -lowerA : lowerA;\n' +
        'lowerA = radiansToDegrees(lowerA);\n' +
        'var mToL =getAngle(mPos,lPos);\n' +
        'var lToZ =getAngle(lPos,zPos);\n' +
        'var ikResult = lowerA + mToL - lToZ +180;\n' +
        'return ikResult % 360;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var parentRot = parent.transform.rotation ;\n' +
        'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
        'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
        'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
        'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerAngle + ').value;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
        'if (!ftEnabled)\n' +
        '{\n' +
        'amp = 0;\n' +
        'delay = 0;\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        'delay = delay / 100;\n' +
        'amp = amp / 100 ;\n' +
        '}\n' +
        'var FK = parentRot.valueAtTime(time-delay);\n' +
        'FK = FK * amp;\n' +
        'FK = FK + manual - parent.transform.rotation.valueAtTime(0);\n' +
        'return FK;\n' +
        '}\n' +
        'IKFK ? result += ik() : result += fk();\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    layer3.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try { controller = effect("' + layer3Data.name + '")(1); } catch (e){ value };\n' +
        'if (controller != null)\n' +
        '{\n' +
        'fx = controller.effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'var upperAP = ' + rootAp + ';\n' +
        'var middlePos = ' + middlePos + ';\n' +
        'var middleAP = ' + middleAp + ';\n' +
        'var lowerPos = ' + lowerPos + ';\n' +
        'var lowerAP = ' + lowerAp + ';\n' +
        'var zeroPos = ' + goalPos.toSource() + ';\n' +
        'dist1 = length(upperAP,middlePos);\n' +
        'dist2 = length(middleAP,lowerPos);\n' +
        'dist3 = length(lowerAP,zeroPos);\n' +
        'IKLength = dist1+dist2+dist3;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist2/(IKLength);\n' +
        'posC = getWorldPos(controller);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
        'result = (middlePos-upperAP)*coef+upperAP;\n' +
        '}\n' +
        '}\n' +
        'result;';

    if ( goal != null )
    {
        var goalData = DuAEF.DuAE.Layer.addPseudoEffect( goal, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
        goalData( 1 ).setValue( controller.layer.index );

        var rotExpr = '//Duik.goal\n' +
            'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
            'var IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
            'function ik()\n' +
            '{\n' +
            'var layer = thisLayer;\n' +
            'var IK = 0;\n' +
            'while (layer.hasParent)\n' +
            '{\n' +
            'layer = layer.parent;\n' +
            'IK = IK - layer.rotation;\n' +
            '}\n' +
            'return IK;\n' +
            '}\n' +
            'function fk()\n' +
            '{\n' +
            'var parentRot = parent.transform.rotation ;\n' +
            'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
            'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
            'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
            'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
            'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalAngle + ').value;\n' +
            'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
            'if (!ftEnabled)\n' +
            '{\n' +
            'amp = 0;\n' +
            'delay = 0;\n' +
            '}\n' +
            'else\n' +
            '{\n' +
            'delay = delay / 100;\n' +
            'amp = amp / 100 ;\n' +
            '}\n' +
            'var FK = parentRot.valueAtTime(time-delay);\n' +
            'FK = FK * amp;\n' +
            'FK = FK + manual - parent.transform.rotation.valueAtTime(0);\n' +
            'return FK;\n' +
            '}\n' +
            'IKFK ? result += ik() : result += fk();\n' +
            '}\n' +
            'result;\n' +
            '';

        DuAEF.DuAE.Property.setExpression( goal.transform.rotation, rotExpr );

        goal.transform.position.expression = 'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'result = ctrl.effect("' + ikEffect.name + '")(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
            '}\n' +
            'result;';
    }

    return controller;
}

/**
 * Creates a bezier ik on the layers
 * @param {Layer[]|Structure} layers - The layers, ordered from root to end
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controllers] - The layer to use as controller, can be automatically created.<br />
 * Must be provided if goal is undefined.
 * @return {Controller[]} The controllers [curve,end,root]
 */
DuAEF.Duik.Rigging.bezierIK = function( layers, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";

    if ( layers instanceof Structure ) layers = layers.elements;

    var comp = layers[ 0 ].containingComp;

    //create controllers
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
        goal.parent = null;
        controller.layer.transform.rotation.setValue( goal.transform.rotation.value );
    }

    if ( goal ) goal.parent = controller.layer;

    //add effect
    var name = layers[ 0 ].name;
    var ikEffect = DuAEF.DuAE.Layer.addPseudoEffect( controller.layer, DuAEF.Duik.PseudoEffects.BEZIER_IK, DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK, DuAEF.Duik.generateName( 'IK', name ) );

    //create curve controller
    var curveController = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.POSITION, layers[ 0 ] );
    curveController.layer.transform.scale.expression = '';
    curveController.layer.name = curveController.layer.name + " | Curve";
    if ( controller.effect ) curveController.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName )( 4 ).setValue( controller.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName )( 4 ).value * 1 / 2 );

    //create root controller
    var rootController = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.POSITION, layers[ 0 ] );
    rootController.layer.name = rootController.layer.name + " | Root";
    if ( controller.effect ) rootController.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName )( 4 ).setValue( controller.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName )( 4 ).value * 1 / 2 );

    //add effect
    var curveEffect = DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.apply( curveController.layer );
    curveEffect( DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer ).setValue( rootController.layer.index );
    curveEffect( DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.curveLayer ).setValue( curveController.layer.index );
    curveEffect( DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer ).setValue( controller.layer.index );

    //useful positions
    var endPosition = DuAEF.DuAE.Layer.getWorldPos( controller.layer );
    if ( goal != null ) endPosition = DuAEF.DuAE.Layer.getWorldPos( goal );
    var rootPosition = DuAEF.DuAE.Layer.getWorldPos( layers[ 0 ] );
    curveController.layer.transform.position.setValue( ( endPosition + rootPosition ) / 2 );
    var cOutPosition = ( 2 * endPosition + rootPosition ) / 3;
    var cInPosition = ( endPosition + 2 * rootPosition ) / 3;

    //add handles
    var handleInGroup = curveController.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
    handleInGroup.name = 'Handle In';
    handleInContent = handleInGroup.property( "ADBE Vectors Group" );
    var circle = handleInContent.addProperty( "ADBE Vector Shape - Ellipse" );
    circle( "ADBE Vector Ellipse Size" ).setValue( [ 25, 25 ] );
    var fill = handleInContent.addProperty( "ADBE Vector Graphic - Fill" );

    var ctrlEffect = curveController.layer.effect( DuAEF.Duik.PseudoEffects.CONTROLLER.matchName );
    if (ctrlEffect) fill( "ADBE Vector Fill Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]\n';
    handleInGroup.transform.scale.expression = '[effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + '),effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + ')]';

    handleInGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'var root = null;\n' +
        'var curve = thisLayer;\n' +
        'var result = value;\n' +
        'try { root = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer + ') ;} catch(e){}\n' +
        'if (root != null)\n' +
        '{\n' +
        'var rootPos = root.toWorld(root.anchorPoint);\n' +
        'rootPos = fromWorld(rootPos);\n' +
        'result += rootPos/2;\n' +
        '}\n' +
        'result;';
    //Auto handle position disabled as it mess up the order of the evaluation of the expressions
    //DuAEF.DuAE.Property.removeExpression(handleInGroup.transform.position);

    handleInGroup.transform.opacity.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.showHandlesCheckbox + ').value*100';

    var handleOutGroup = curveController.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
    handleOutGroup.name = 'Handle Out';
    handleOutContent = handleOutGroup.property( "ADBE Vectors Group" );
    var circle = handleOutContent.addProperty( "ADBE Vector Shape - Ellipse" );
    circle( "ADBE Vector Ellipse Size" ).setValue( [ 25, 25 ] );
    var fill = handleOutContent.addProperty( "ADBE Vector Graphic - Fill" );
    if (ctrlEffect) fill( "ADBE Vector Fill Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]\n';
    if (ctrlEffect) handleOutGroup.transform.scale.expression = '[effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + '),effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Size_Slider'] + ')]';

    //Auto handle position disabled as it mess up the order of the evaluation of the expressions
    handleOutGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'var end = null;\n' +
        'var curve = thisLayer;\n' +
        'var result = value;\n' +
        'try { end = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer + '); } catch(e){}\n' +
        'if (end != null)\n' +
        '{\n' +
        'var endPos = end.toWorld(end.anchorPoint);\n' +
        'endPos = fromWorld(endPos);\n' +
        'result += endPos/2;\n' +
        '}\n' +
        'result;';
    //Auto handle position disabled as it mess up the order of the evaluation of the expressions
    //DuAEF.DuAE.Property.removeExpression(handleOutGroup.transform.position);

    handleOutGroup.transform.opacity.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.showHandlesCheckbox + ').value*100';

    //add line
    if ( DuAEF.DuAE.App.version.version >= 15 )
    {
        var lineGroup = curveController.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        lineGroup.name = 'IK Line';
        var lineContent = lineGroup.property( "ADBE Vectors Group" );
        var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
        shape( 'ADBE Vector Shape' ).expression = 'var fx = effect("' + curveEffect.name + '");\n' +
            'var root = null;\n' +
            'var curve = thisLayer;\n' +
            'var end = null;\n' +
            'var result = [[0,0]];\n' +
            'if (fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.drawGuidesCheckbox + ').value)\n' +
            '{\n' +
            'try { root = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer + ') ; end = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer + ') } catch(e){}\n' +
            'if (root != null)\n' +
            '{\n' +
            'var r = root.toWorld(root.anchorPoint);\n' +
            'r = fromWorld(r);\n' +
            'var e = end.toWorld(end.anchorPoint);\n' +
            'e = fromWorld(e);\n' +
            'var t1 = content("Handle In").transform.position;\n' +
            'var t2 = content("Handle Out").transform.position;\n' +
            'result = [r,t1,t2,e];\n' +
            '}\n' +
            '}\n' +
            'createPath(result,[],[],false);';
        var stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = 'effect("' + ctrlEffect.name + '")(' + DuAEF.Duik.PseudoEffects.CONTROLLER.index['Icon_Color_Color'] + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
    }

    //setup layers
    var rootIndex = rootController.layer.index;
    var endIndex = controller.layer.index;
    var curveIndex = curveController.layer.index;
    var totalLength = DuAEF.DuJS.Math.getLength( rootPosition, cInPosition ) + DuAEF.DuJS.Math.getLength( cOutPosition, cInPosition ) + DuAEF.DuJS.Math.getLength( cOutPosition, endPosition );

    //un-parent
    for ( var i = 1; i < layers.length; i++ )
    {
        layers[ i ].parent = null;
    }

    layers[ 0 ].parent = rootController.layer;

    for ( var i = 0; i < layers.length; i++ )
    {
        var layer = layers[ i ];
        //add effect
        var layerEffect = DuAEF.DuAE.Layer.addPseudoEffect( layer, DuAEF.Duik.PseudoEffects.BEZIER_IK_LAYER, DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK_LAYER, "Bezier IK" );
        layerEffect( 3 ).setValue( rootIndex );
        layerEffect( 4 ).setValue( curveIndex );
        layerEffect( 5 ).setValue( endIndex );
        if ( i < layers.length - 1 ) layerEffect( 6 ).setValue( layers[ i + 1 ].index );
        else layerEffect( 6 ).setValue( controller.layer.index );

        //expressions

        //position
        if ( i != 0 )
        {
            var index = DuAEF.DuJS.Math.getLength( endPosition, layer.transform.position.value );
            index = index / totalLength;
            var expression = '//Duik.bezierIK\n' +
                'var end = null;\n' +
                'var root = null;\n' +
                'var curve = null;\n' +
                'var result = value;\n' +
                'var thisFx = effect("' + layerEffect.name + '");\n' +
                'try{end=thisFx(5);curve=thisFx(4);root=thisFx(3);}catch(e){};\n' +
                'if(root !=null)\n' +
                '{\n' +
                'var ind = ' + index + ';\n' +
                'var fx = end.effect("' + ikEffect.name + '");\n' +
                'var offset = thisFx(1)/100;\n' +
                'var generalOffset = fx(2)/100;\n' +
                'var endPosition = end.toComp(end.anchorPoint);\n' +
                'var rootPosition = root.toComp(root.anchorPoint);\n' +
                'var curvePosition1 = curve.toComp(curve.content("Handle Out").transform.position);\n' +
                'var curvePosition2 = curve.toComp(curve.content("Handle In").transform.position);\n' +
                'var t = ind + generalOffset + offset;\n' +
                'var c = 3*(curvePosition1 - endPosition);\n' +
                'var b = 3*(curvePosition2 - curvePosition1) - c;\n' +
                'var a = rootPosition - endPosition - c - b;\n' +
                'result += ((a*t +b )*t + c)*t + endPosition ;\n' +
                'result -= ' + layer.transform.position.value.toSource() + ';\n' +
                '}\n' +
                'result;';
            DuAEF.DuAE.Property.setExpression( layer.transform.position, expression );
        }

        //rotation
        var expr = '//Duik.bezierIK\n' +
            'var c = null;\n' +
            'var result = value;\n' +
            'var thisFx = effect("' + layerEffect.name + '");\n' +
            'try{c = thisFx(5)}catch(e){}\n' +
            'if (c!=null)\n' +
            '{\n' +
            'var n = c;\n' +
            'try {n=thisFx(6); if (n.index == index) n=c}catch(e){}\n' +
            'var fx = c.effect("' + ikEffect.name + '");\n' +
            'var autoOrient = fx(1).value;\n' +
            'var C = n.toWorld(n.anchorPoint);\n' +
            'var O =  thisLayer.toWorld(thisLayer.anchorPoint);\n' +
            'var vec = O-C;\n' +
            'var angle = Math.atan2(vec[1], vec[0]);\n' +
            'var ik = radiansToDegrees(angle);\n' +
            'if (autoOrient==1) result += ik;\n';
        if ( i == 0 )
        {
            expr += 'var layer = thisLayer;\n' +
                'while(layer.hasParent)\n' +
                '{\n' +
                'layer = layer.parent;\n' +
                'result -= layer.transform.rotation;\n' +
                '}\n';
        }
        expr += '}\n' +
            'result;';

        DuAEF.DuAE.Property.setExpression( layer.transform.rotation, expr );
    }

    curveController.layer.selected = false;
    controller.layer.moveBefore( curveController.layer );

    return [ curveController, controller, rootController ];
}

DuAEF.Duik.Rigging.goal = function( layers, controller )
{
    if ( layers instanceof Array ) layers = DuAEF.DuAE.Layer.sortByParent( layers );
    else layers = [ layers ];
    var numLayers = layers.length;

    if ( controller instanceof Controller ) controller = controller.layer;
    //add checkbox and data
    var effect = controller.effect.addProperty( "ADBE Checkbox Control" );
    effect.name = layers[ 0 ].name + " Follow";
    var effectName = effect.name;


    for ( var i = 0; i < layers.length; i++ )
    {
        var goalData = layers[ i ].effect.addProperty( "ADBE Layer Control" );
        goalData.name = "Goal";
        goalData( 1 ).setValue( controller.index );

        var exp = "//Duik.goal\n" +
            "var ctrl = null;\n" +
            "var result = value;\n" +
            "try { ctrl = effect(\"Goal\")(1); } catch (e){};\n" +
            "if (ctrl != null)\n" +
            "{\n" +
            "var goal = ctrl.effect(\"" + effectName + "\")(1).value;\n" +
            "result += ctrl.rotation.value/" + ( numLayers / ( i + 1 ) ) + ";\n" +
            "if (!goal)\n" +
            "{\n" +
            "var layer = thisLayer;\n" +
            "while (layer.hasParent)\n" +
            "{\n" +
            "layer = layer.parent;\n" +
            "result = result - layer.rotation/" + ( numLayers / ( i + 1 ) ) + ";\n" +
            "}\n" +
            "}\n" +
            "}\n" +
            "result;";

        DuAEF.DuAE.Property.setExpression( layers[ i ].transform.rotation, exp );
    }
}

/**
 * Creates a FK with auto-overlapping and its controller on the layers/the structure.
 * @param {Layer[]|Structure} layers - The layers, already parented or ordered from root (at index 0) to end
 * @param {Layer|Controller|null} [controller] - An already existing controller.
 * @return {Controller} The controller of the FK.
 */
DuAEF.Duik.Rigging.fkOverlap = function( layers, controller )
{
    if ( typeof controller === 'undefined' ) controller = null;
    if ( layers instanceof Structure ) layers = layers.elements;

    var comp = layers[ 0 ].containingComp;

    //check if there is a controller in the selection
    if ( controller == null )
    {
        for ( var i = 0, num = layers.length; i < num; i++ )
        {
            var l = layers[ i ];
            if ( DuAEF.Duik.isLayerType( l, DuAEF.Duik.LayerTypes.CONTROLLER ) )
            {
                controller = l;
                layers.splice( i, 1 );
                break;
            }
        }
    }

    //sort layers and parent them
    var layers = DuAEF.DuAE.Layer.sortByParent( layers );
    //reset rotation and scale if structures
    var it = new Iterator( layers )
    it.do( DuAEF.Duik.Structure.resetTransform );
    DuAEF.DuAE.Layer.parentChain( layers );

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.ROTATION;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, layers[ 0 ] );
    }
    if ( !( controller instanceof Controller ) )
    {
        controller = new Controller( controller );
    }

    var name = layers[ 0 ].name;
    var fkEffect = DuAEF.DuAE.Layer.addPseudoEffect( controller.layer, DuAEF.Duik.PseudoEffects.FK_OVERLAP, DuAEF.Duik.PseudoEffectsMatchNames.FK_OVERLAP, DuAEF.Duik.generateName( 'FK Overlap', name ) );
    fkEffect( 7 ).setValue( -180 );
    fkEffect( 1 ).setValue( 100 );
    fkEffect( 2 ).setValue( 10 );
    var fkEffectName = fkEffect.name;

    //rig layers
    var it = new Iterator( layers );
    it.do( function( layer )
    {
        //add Data
        var layerData = DuAEF.DuAE.Layer.addPseudoEffect( layer, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "FK Overlap" );
        layerData( 1 ).setValue( controller.layer.index );

        //add FK control
        var fkControl = controller.layer( 'ADBE Effect Parade' ).addProperty( 'ADBE Angle Control' );
        fkControl.name = layer.name;

        //add expression
        if ( it.current == 0 )
        {
            layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
                'var controller = null;\n ' +
                'var result = value;\n ' +
                'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
                'if (controller !=null)\n ' +
                '{\n ' +
                'var fx = controller.effect("' + fkEffectName + '");\n ' +
                'result += controller.transform.rotation.value + fx(3).value ;\n ' +
                'var follow = fx(4).value;\n ' +
                'var p = thisLayer;\n ' +
                'if (!follow)\n ' +
                '{\n ' +
                'while(p.hasParent)\n ' +
                '{\n ' +
                'p = p.parent;\n ' +
                'result -= p.rotation.value;\n ' +
                '}\n ' +
                '}\n ' +
                'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
                '{\n ' +
                'var fk = controller("Effects")(i);\n ' +
                'if (fk.name == thisLayer.name)\n ' +
                '{\n ' +
                'result+=fk(1).value;\n ' +
                'break;\n' +
                '}	\n ' +
                '}\n ' +
                '}\n ' +
                'result;';
        }
        else if ( it.current == 1 )
        {
            layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
                'var controller = null;\n ' +
                'var result = value;\n ' +
                'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
                'if (controller !=null && hasParent)\n ' +
                '{\n ' +
                'var fx = controller.effect("' + fkEffectName + '");\n ' +
                'var ctrlRot = controller.transform.rotation;\n ' +
                'var delay = fx(2).value ;\n ' +
                'var amp = fx(1).value ;\n ' +
                'var uLimit = fx(6).value ;\n ' +
                'var lLimit = fx(7).value ;\n ' +
                'var manual = fx(3).value ;\n ' +
                'var follow = fx(4).value;\n ' +
                'delay = delay / 100;\n ' +
                'amp = amp / 100 ;\n ' +
                'result = ctrlRot.valueAtTime(time-delay) + fx(3).valueAtTime(time-delay);\n ' +
                'if (follow && hasParent)\n ' +
                '{\n ' +
                'var cP = parent;\n ' +
                'while(cP.hasParent)\n ' +
                '{\n ' +
                'cP = cP.parent;\n ' +
                'if (cP.index = controller.index) follow = false;\n ' +
                'result -= cP.rotation.value - cP.rotation.valueAtTime(time-delay) ;\n ' +
                '}\n ' +
                '}\n ' +
                'result = result - ctrlRot.value ;\n ' +
                'result = result * amp;\n ' +
                'result = result - ctrlRot.velocity*(delay/5);\n ' +
                'if (result > uLimit) result = uLimit;\n ' +
                'if (result < lLimit) result = lLimit;\n ' +
                'result = result + value + manual;\n ' +
                'if (follow) result -= parent.transform.rotation.valueAtTime(0);\n ' +
                'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
                '{\n ' +
                'var fk = controller("Effects")(i);\n ' +
                'if (fk.name == thisLayer.name)\n ' +
                '{\n ' +
                'result+=fk(1).value;\n ' +
                'break;\n' +
                '}	\n ' +
                '}\n ' +
                '}\n ' +
                'result;';
        }
        else
        {
            layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
                'var controller = null;\n ' +
                'var result = value;\n ' +
                'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
                'if (controller !=null && hasParent)\n ' +
                '{\n ' +
                'var fx = controller.effect("' + fkEffectName + '");\n ' +
                'var ctrlRot = controller.transform.rotation;\n ' +
                'var parentRot = parent.transform.rotation ;\n ' +
                'var delay = fx(2).value ;\n ' +
                'var amp = fx(1).value ;\n ' +
                'var uLimit = fx(6).value ;\n ' +
                'var lLimit = fx(7).value ;\n ' +
                'var manual = fx(3).value ;\n ' +
                'delay = delay / 100;\n ' +
                'amp = amp / 100 ;\n ' +
                'result = parentRot.valueAtTime(time-delay);\n ' +
                'result = result * amp;\n ' +
                'if (result > uLimit) result = uLimit;\n ' +
                'if (result < lLimit) result = lLimit;\n ' +
                'result = result + value + manual - parent.transform.rotation.valueAtTime(0);\n ' +
                'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
                '{\n ' +
                'var fk = controller("Effects")(i);\n ' +
                'if (fk.name == thisLayer.name)\n ' +
                '{\n ' +
                'result+=fk(1).value;\n ' +
                'break;\n' +
                '}	\n ' +
                '}\n ' +
                '}\n ' +
                'result;';
        }
    } );

    controller.layer.selected = true;

    return controller;
}

DuAEF.Duik.Rigging.exposeTransform = function( comp, layer )
{
    if (typeof comp === 'undefined')
	{
		if (typeof layer !== 'undefined')
		{
			comp = layer.containingComp;
		}
		else
		{
			comp = DuAEF.DuAE.Project.getActiveComp();
		}
	}
	if (!comp) return;

    var ctrl = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.EXPOSE_TRANSFORM, layer);
    ctrl = ctrl.layer;

    //add pseudo effect
    var pE = DuAEF.Duik.PseudoEffects.EXPOSE_TRANSFORM;
    var index = pE.index;
    var effect = pE.apply(ctrl);

    //add guides
    var guidesGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	guidesGroup.name = 'Guides';

    var refGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    refGroup.name = 'Reference';

    var refOrientationGroup = refGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    refOrientationGroup.name = 'Orientation';
    refOrientation = refOrientationGroup("ADBE Vectors Group");

    var path = refOrientation.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['Display_Guides_Checkbox'] + ').value)',
        '{',
        '	var A = [0,0];',
        '	var B = [ 0 , -thisComp.height/20 ];',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
        ].join('\n');

    path = refOrientation.addProperty("ADBE Vector Shape - Ellipse");
    path("ADBE Vector Ellipse Size").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
	    'var s = thisComp.height/40;',
	    'if (fx(' + index['Display_Guides_Checkbox'] + ').value) [s,s];',
	    'else [0,0];'
	    ].join('\n');

    var stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['Display_Reference_Color'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');
    refOrientationTransform('ADBE Vector Position').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'var P = fx(' + index['2D Position (Comp projection)_Absolute_Point'] + ');',
        'var R = fx(' + index['2D Position (Comp projection)_Absolute_Point'] + ') - fx(' + index['2D Position (Comp projection)_Relative to reference_Point'] + ');',
        'fromComp(R);'
    ].join('\n');
    refOrientationTransform('ADBE Vector Rotation').expression = 'content("Guides").content("Target").transform.rotation + content("Guides").content("Target").content("Reference Orientation").transform.rotation;'

    var targetGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetGroup.name = 'Target';

    var targetOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetOrientationGroup.name = 'Orientation';
    targetOrientation = targetOrientationGroup("ADBE Vectors Group");

    path = targetOrientation.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['Display_Guides_Checkbox'] + ').value)',
        '{',
        '	var A = [0,0];',
        '	var B = [ 0 , -thisComp.height/10 ];',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
    ].join('\n');

    path = targetOrientation.addProperty("ADBE Vector Shape - Ellipse");
    path("ADBE Vector Ellipse Size").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
	    'var s = thisComp.height/20;',
	    'if (fx(' + index['Display_Guides_Checkbox'] + ').value) [s,s];',
	    'else [0,0];'
	].join('\n');

    stroke = targetOrientation.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['Display_Target_Color'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    var refOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    refOrientationGroup.name = 'Reference Orientation';
    refOrientation = refOrientationGroup("ADBE Vectors Group");

    path = refOrientation.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['Display_Guides_Checkbox'] + ').value)',
        '{',
        '	var A = [0,0];',
        '	var B = [ 0 , -thisComp.height/20 ];',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
    ].join('\n');

    stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['Display_Reference_Color'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';
    
    refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');

    refOrientationTransform('ADBE Vector Rotation').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        '-fx(' + index['2D Orientation_Relative to reference_Angle'] + ');'
	].join('\n');

    targetTransform = targetGroup('ADBE Vector Transform Group');
    targetTransform('ADBE Vector Position').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['Display_Guides_Checkbox'] + ').value)',
        '{',
        '	fromComp(fx(' + index['2D Position (Comp projection)_Absolute_Point'] + '));',
        '}',
        'else',
        '{',
        '	value;',
        '}'
    ].join('\n');
    targetTransform('ADBE Vector Rotation').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'var result = fx(' + index['2D Orientation_Absolute_Angle'] + ');',
        'var l = thisLayer;',
        'result -= l.rotation.value;',
        'while(l.hasParent)',
        '{',
        '	l = l.parent;',
        '	result -= l.rotation.value;',
        '}',
        'result;'
	].join('\n');

    var angleGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    angleGroup.name = 'Angle';

    var angleGroup1 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    angle1 = angleGroup1("ADBE Vectors Group");

    path = angle1.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("Expose Transform");',
        'if (fx(' + index['Display_Guides_Checkbox'] + ').value)',
        '{',
        '	var A = fromComp(fx(' + index['2D Position (Comp projection)_Absolute_Point'] + '));',
        '	var B = fromComp( fx(' + index['2D Position (Comp projection)_Absolute_Point'] + ') - fx(' + index['2D Position (Comp projection)_Relative to reference_Point'] + ') );',
        '	createPath([A,[0,0],B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
	].join('\n');

    stroke = angle1.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['Display_Angle_Color'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    var angleGroup2 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    angle2 = angleGroup2("ADBE Vectors Group");

    path = angle2.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['Display_Guides_Checkbox'] + ').value)',
        '{',
        '	var A = fromComp(fx(' + index['2D Position (Comp projection)_Absolute_Point'] + '));',
        '	var B = fromComp( fx(' + index['2D Position (Comp projection)_Absolute_Point'] + ') - fx(' + index['2D Position (Comp projection)_Relative to reference_Point'] + ') );',
        '	var M = (A+B)/2;',
        '	var tA = [0,0];',
        '	var tB = [0,0];',
        '	var lB = length(B);',
        '	var lA = length(A);',
        '	if (lA > lB)',
        '	{',
        '		var q = 1;',
        '		if (lA != 0) q = lB/lA;',
        '		A = A/3*q;',
        '		B = B/3;',
        '		tA = M/6*q;',
        '		tB = M/6;',
        '	}',
        '	else',
        '	{',
        '		var q = 1;',
        '		if (lB != 0) q = lA/lB;',
        '		A = A/3;',
        '		B = B/3*q;',
        '		tA = M/6;',
        '		tB = M/6*q;',
        '	}',
        '	createPath([A,B],[ [0,0], tB ],[ tA, [0,0] ],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
	].join('\n');

    stroke = angle2.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['Display_Angle_Color'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';
    
    var distanceGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    distanceGroup.name = 'Distance';
    distance = distanceGroup("ADBE Vectors Group");

    path = distance.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['Display_Guides_Checkbox'] + ').value)',
        '{',
        '	var A = fromComp(fx(' + index['2D Position (Comp projection)_Absolute_Point'] + '));',
        '	var B = fromComp( fx(' + index['2D Position (Comp projection)_Absolute_Point'] + ') - fx(' + index['2D Position (Comp projection)_Relative to reference_Point'] + ') );',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
	].join('\n');

    stroke = distance.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['Display_Distance_Color'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    //Effect expressions

    effect(index['2D Position (Comp projection)_Absolute_Point']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var l = null;',
        'try { l = fx(' + index['Target Layer_Layer'] + '); } catch (e){ }',
        'if (!l) l = thisLayer;',
        'var result = l.toComp(l.anchorPoint);',
        'result;'
	].join('\n');

    effect(index['2D Position (Comp projection)_Relative to reference_Point']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var useParent = fx(' + index['Reference_Checkbox'] + ').value;',
        'var layerPosition = fx(' + index['2D Position (Comp projection)_Absolute_Point'] + ');',
        'var referencePosition = [0,0];',
        'var rL = null;',
        'if (useParent)',
        '{',
        '   var l = null;',
        '	try { l = fx(' + index['Target Layer_Layer'] + '); } catch (e){ }',
        '   if (!l) l = thisLayer;',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference Layer_Layer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'referencePosition = rL.toComp(rL.anchorPoint);',
        'var result = layerPosition - referencePosition;',
        'result;'
	].join('\n');

    effect(index['2D Position (Comp projection)_2D Distance_Slider']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var relativePosition = fx(' + index['2D Position (Comp projection)_Relative to reference_Point'] + ');',
        'var result = length( relativePosition );',
        'result;'
	].join('\n');

    effect(index['3D Position (World)_Absolute_Point3D']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var l = null;',
        'try { l = fx(' + index['Target Layer_Layer'] + '); } catch (e){ }',
        'if (!l) l = thisLayer;',
        'var result = l.toWorld(l.anchorPoint);',
        'result;'
	].join('\n');

    effect(index['3D Position (World)_Relative to reference_Point3D']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var layerPosition = fx(' + index['3D Position (World)_Absolute_Point3D'] + ');',
        'var useParent = fx(' + index['Reference_Checkbox'] + ').value;',
        'var rL = null;',
        'if (useParent)',
        '{',
        '   var l = null;',
        '	try { l = fx(' + index['Target Layer_Layer'] + '); } catch (e){ }',
        '   if (!l) l = thisLayer;',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference Layer_Layer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'var referencePosition = rL.toWorld(rL.anchorPoint);',
        'var result = layerPosition - referencePosition;',
        'result;'
	].join('\n');

    effect(index['3D Position (World)_3D Distance_Slider']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var relativePosition = fx(' + index['3D Position (World)_Relative to reference_Point3D'] + ');',
        'var result = length( relativePosition );',
        'result;'
	].join('\n');

    effect(index['2D Orientation_Absolute_Angle']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var l = null;',
        'try { l = fx(' + index['Target Layer_Layer'] + ') } catch (e){ }',
        'if (!l) l = thisLayer;',
        'var result = l.rotation;',
        'if (l.position.value.length == 3) result += l.orientation[2];',
        'while(l.hasParent)',
        '{',
        '	l = l.parent;',
        '	result += l.rotation;',
        '	if (l.position.value.length == 3) result += l.orientation[2];',
        '}',
        'result;'
	].join('\n');

    effect(index['2D Orientation_Relative to reference_Angle']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var useParent = fx(' + index['Reference_Checkbox'] + ').value;',
        'var rot = fx(' + index['2D Orientation_Absolute_Angle'] + ');',
        'var result = value;',
        'var rL = null;',
        'if (useParent)',
        '{',
        '   var l = null;',
        '	try { l = fx(' + index['Target Layer_Layer'] + '); } catch (e){ }',
        '   if (!l) l = thisLayer;',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference Layer_Layer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'var refRot = rL.rotation.value;',
        'if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
        'while(rL.hasParent)',
        '{',
        '	rL = rL.parent;',
        '	refRot += rL.rotation.value;',
        '	if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
        '}',
        'result = rot - refRot;',
        'result;'
	].join('\n');

    effect(index['Angle (Layer-This-Reference)_Angle']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var useParent = fx(' + index['Reference_Checkbox'] + ').value;',
        'var O = thisLayer.toComp(thisLayer.anchorPoint);',
        'var l = null;',
        'var rL = null;',
        'try { l = fx(' + index['Target Layer_Layer'] + '); } catch (e){ }',
        'if (!l) l = thisLayer;',
        'if (useParent)',
        '{',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference Layer_Layer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'var A = l.toComp(l.anchorPoint);',
        'var B = rL.toComp(rL.anchorPoint);',
        'var OA = O-A;',
        'var OB = O-B;',
        'var angleA = Math.atan2(OA[1], OA[0]);',
        'var angleB = Math.atan2(OB[1], OB[0]);',
        'var result = angleA + angleB;',
        'result = radiansToDegrees(angleB-angleA);',
        'if (result < -180) result += 360;',
        'result;'
	].join('\n');

    //set the layer as target
    if (typeof layer !== 'undefined')
    {
        effect(index['Target Layer_Layer'] ).setValue(layer.index);
    }

    return ctrl;
}
/**
 * Constructs a Structure
 * @class Structure
 * @classdesc A Structure.
 * @property {Layer[]} elements - The elements of the structure
 * @property {int} structureId - The unique Id set when this structure was created
 */
function Structure ( elements )
{
    if ( typeof elements === 'undefined' ) elements = [];
    this.elements = DuAEF.DuAE.Layer.sortByParent( elements );
    this.editModeRegExp = / \|StructureElementChildren:([\d,]*)\|/;
    this.structureId = -1;
    if ( this.elements.length > 0 )
    {
        var element = this.elements[ 0 ];
        var params = DuAEF.Duik.getDuikMarkerParameters( element );
        if ( !params ) return;
        if ( params[ DuAEF.Duik.MarkerParameters.STRUCTURE_ID ] ) this.structureId = params[ DuAEF.Duik.MarkerParameters.STRUCTURE_ID ];
    }
}

/**
 * Sets a new display size for the structure
 * @memberof Structure
 * @param {int} [size] - The element size, a percentage. By default, it will adjust automatically depending on comp size and DuAEF.Duik.Structure.sizeHint
 */
Structure.prototype.setSize = function( size )
{
    if ( this.elements.length == 0 ) return;
    var comp = this.elements[ 0 ].containingComp;
    if ( size == undefined )
    {
        size = comp.width / 2 + comp.height / 2;
        if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.SMALL ) size = Math.floor( size / 14 );
        else if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.MEDIUM ) size = Math.floor( size / 10 );
        else if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.LARGE ) size = Math.floor( size / 6 );
        else if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.CUSTOM ) size = DuAEF.Duik.Structure.size;
    }
    for ( var i = 0; i < this.elements.length; i++ )
    {
        var layer = this.elements[ i ];
        var effect = layer.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName );
        if (effect) effect( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Size_Slider'] ).setValue( size );
    }
}

/**
 * Sets a new display color for the structure
 * @memberof Structure
 * @param {float[]} [color=DuAEF.Duik.Structure.color] - The color
 */
Structure.prototype.setColor = function( color )
{
    if ( this.elements.length == 0 ) return;
    var comp = this.elements[ 0 ].containingComp;

    if ( color == undefined ) color = DuAEF.Duik.Structure.color;
    if ( color == DuColor.Color.RANDOM ) color = DuColor.randomFloatRGBA();

    for ( var i = 0; i < this.elements.length; i++ )
    {
        var layer = this.elements[ i ];
        var effect = layer.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName );
        if (effect) effect( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( color );
    }
}

/**
 * Toggles the edit mode
 * @memberof Structure
 */
Structure.prototype.toggleEditMode = function( color )
{
    if ( this.elements.length == 0 ) return;

    var setEditMode = !this.editModeRegExp.test( this.elements[ 0 ].comment );

    for ( var i = 0; i < this.elements.length; i++ )
    {
        this.toggleElementEditMode( i, setEditMode )
    }
}

/**
 * Toggles the edit mode of one element in the structure
 * @memberof Structure
 * @param {int} elementIndex - The index of the element to toggle in the Structure.elements Array
 * @param {boolean} setEditMode - true to turn on edit mode, false to turn it off.
 */
Structure.prototype.toggleElementEditMode = function( elementIndex, setEditMode )
{
    var element = this.elements[ elementIndex ];
    DuAEF.DuAE.Layer.toggleEditMode( element );
}

/**
 * Toggles visibility of the structure
 * @memberof Structure
 */
Structure.prototype.showHide = function()
{
    if ( this.elements.length == 0 ) return;
    var comp = this.elements[ 0 ].containingComp;
    var show = !this.elements[ 0 ].enabled;

    for ( var i = 0, num = this.elements.length; i < num; i++ )
    {
        this.elements[ i ].enabled = show;
    }
}

/**
 * Gets the unique identifier of the structure
 * @memberof Structure
 * @return {int} the id
 */
Structure.prototype.getId = function()
{
    if ( this.elements.length == 0 ) return -1;
    var params = DuAEF.Duik.getDuikMarkerParameters( this.elements[ 0 ] );
    if ( !params ) return -1;
    if ( params[ DuAEF.Duik.MarkerParameters.STRUCTURE_ID ] ) return params[ DuAEF.Duik.MarkerParameters.STRUCTURE_ID ];
    return -1;
}

/**
 * "Bakes" the appearance of the Structure,<br />
 * in order to improve performance and simplify the use of the rig when animating.
 * @memberof Structure
 */
Structure.prototype.bakeAppearence = function()
{
    for ( var i = 0, num = this.elements.length; i < num; i++ )
    {
        DuAEF.Duik.Structure.bakeAppearence( this.elements[ i ] );
    }
}

/**
 * Duplicates a structure,<br />
 * @memberof Structure
 * @return {Structure} The new Structure
 */
Structure.prototype.duplicate = function()
{
    if ( this.elements.length == 0 ) return;
    //unselect all layers in the comp
    var comp = this.elements[ 0 ].containingComp;
    DuAEF.DuAE.Comp.unselectLayers( comp );
    //select elements of the structure, then duplicate
    DuAEF.DuAE.Comp.selectLayers( this.elements );
    comp.openInViewer();
    DuAEF.DuAE.App.duplicate();
    //get topmost element
    var topIndex = comp.numLayers;
    var it = new DuList( this.elements );
    while ( element = it.next() )
    {
        if ( element.index < topIndex ) topIndex = element.index;
        if ( topIndex == 1 ) break;
    };

    oldLayers = DuAEF.DuAE.Layer.sortByIndex( this.elements ).reverse();
    var newLayers = DuAEF.DuAE.Layer.sortByIndex( comp.selectedLayers ).reverse();

    //adjustments
    function layerInArray ( layer, index )
    {
        return layer.index == index;
    }

    var id = new Date().getTime();

    var autorigId = new Date().getTime() + 1;

    new DuList( newLayers ).do( function( layer )
    {
        layer.moveBefore( comp.layer( topIndex ) );
        //set display link
        var pE = DuAEF.Duik.PseudoEffects.STRUCTURE;
        var effect = layer.effect( pE.matchName );
        if (effect)
        {
            var oldLinkIndex = DuAEF.DuJS.Array.indexOf( oldLayers, effect( pE.index['Display options_Target_Layer'] ).value, layerInArray );
            if ( oldLinkIndex >= 0 )
            {
                effect( pE.index['Display options_Target_Layer'] ).setValue( newLayers[ oldLinkIndex ].index );
            }
        }
        
        //set id
        DuAEF.Duik.setDuikMarkerParameter( layer, DuAEF.Duik.MarkerParameters.STRUCTURE_ID, id );
    } );

    //return
    return new Structure( newLayers );
}

/**
 * Search for a controller which can be used with this Structure.
 * @memberof Structure
 * @param {Layer[]|LayerCollection} layers - The layers where to search for the controller
 * @param {boolean} [preferFK=false] - Set to true to search for the controller at the root of the chain first instead of the end
 * @param {int} [threshold=0] - The minimum distance in pixels between the controller and the structure to consider it valid.
 * @return {Layer|null} The controller found or null if there's nothing to find<br />
 * The Controller object has an attribute "structureIndex" corresponding to the index of the element of the structure where it was found.
 */
Structure.prototype.getController = function( layers, preferFK, threshold )
{
    if ( this.elements.length == 0 ) return null;

    if ( typeof root === 'undefined' ) root = false;
    if ( typeof threshold === 'undefined' ) threshold = 0;

    function getCtrl ( index, struc )
    {
        for ( var i = 0, num = layers.length; i < num; i++ )
        {
            var ctrl = layers[ i ];
            var dist = DuAEF.DuAE.Layer.getDistance( struc.elements[ index ], ctrl );
            if ( dist <= threshold )
            {
                ctrl.structureIndex = index;
                return ctrl;
            }
            if ( index > 0 ) dist = DuAEF.DuAE.Layer.getDistance( struc.elements[ index - 1 ], ctrl );
            if ( dist <= threshold )
            {
                ctrl.structureIndex = index - 1;
                return ctrl;
            }
        }
        return null;
    }

    var elementIndex = 0;
    if ( !preferFK ) elementIndex = this.elements.length - 1;

    var ctrl = getCtrl( elementIndex, this );
    if ( ctrl ) return ctrl;

    if ( preferFK ) elementIndex = this.elements.length - 1;
    else elementIndex = 0;

    return getCtrl( elementIndex, this );
}

/**
 * Selects all the elements of the structure
 * @memberof Structure
 */
Structure.prototype.select = function()
{
    for ( var i = 0, num = this.elements.length; i < num; i++ )
    {
        this.elements[ i ].selected = true;
    }
}

/**
 * Structures
 * @namespace
 * @memberof DuAEF.Duik
 */
DuAEF.Duik.Structure = {};

/**
 * Translatable strings used to name layers and effects<br />
 * These strings are translated at init time using the {@link tr} function from {@link DuTranslator}.
 * @enum {string}
 * @readonly
 */
DuAEF.Duik.Structure.Strings = {
    STRUCTURE: "Structure",
    SHOULDER: "Shoulder",
    ARM: "Arm",
    FOREARM: "Forearm",
    HAND: "Hand",
    CLAWS: "Claws",
    HOOF: "Hoof",
    HEEL: "Heel",
    ARM_TIP: "Arm tip",
    THIGH: "Thigh",
    CALF: "Calf",
    FOOT: "Foot",
    TOES: "Toes",
    TIPTOE: "Tiptoe",
    HIPS: "Hips",
    SPINE: "Spine",
    NECK: "Neck",
    HEAD: "Head",
    SPINE_TIP: "Spine tip",
    TAIL: "Tail",
    TAIL_TIP: "Tail tip"
};

//low-level undocumented function
//this function has to be called once at runtime.
DuAEF.Duik.Structure.postInit = function()
{
    //translate strings
    for ( i in DuAEF.Duik.Structure.Strings )
    {
        var str = DuAEF.Duik.Structure.Strings[ i ];
        DuScriptUI.uiStrings.push( str );
        DuAEF.Duik.Structure.Strings[ i ] = tr( str );
    }
}

/**
 * How to get structures depending on selection<br />
 * All structure, only children elements, or only selected element
 * @enum {int}
 * @readonly
 */
DuAEF.Duik.Structure.SelectionModes = {
    STRUCTURE: 0,
    CHILDREN: 1,
    ELEMENT: 2,
    ALL: 3
};

/**
 * Size hint of structure elements
 * @type {int}
 * @default DuAEF.Duik.Sizes.SMALL
 */
DuAEF.Duik.Structure.sizeHint = DuAEF.Duik.Sizes.SMALL;
/**
 * The default size for new structures if structureSizeHint is DuAEF.Duik.Sizes.CUSTOM
 * @type {int}
 * @default 100
 */
DuAEF.Duik.Structure.size = 100;
/**
 * The default color for new structures
 * @type {float[]}
 * @default DuColor.Color.RANDOM
 */
DuAEF.Duik.Structure.color = DuColor.Color.RANDOM
/**
 * Whether to auto link bezier paths to structure elements on creation
 * @type {bool}
 * @default true
 */
DuAEF.Duik.Structure.linkPaths = false;
/**
 * Whether to auto link puppet pins to structure elements on creation
 * @type {bool}
 * @default true
 */
DuAEF.Duik.Structure.linkPins = false;
/**
 * Whether to auto link layers to structure elements on creation
 * @type {bool}
 * @default true
 */
DuAEF.Duik.Structure.linkLayers = false;

/**
 * Creates structures in a composition.
 * If path properties are selected, will create the structures on the vertices, if puppet pins, on the pins, else if layers, on the layers if they are not aligned.
 * @memberof DuAEF.Duik.Structure
 * @param {int} [num=2] - The number of elements of the structure.
 * @param {CompItem} [comp] - The composition where to create the Structure. Default is the active item, if it's a comp.
 * @param {string} [name="Name"] - The name of the structure (used as layer names)
 * @param {bool} [forceNum=false] - When true, the strucutre will have num elements even if there is less items in the selection (but will respect the selection if it is bigger)
 * @param {bool} [reverseAutoLink=false] - When true, the preference to force auto linking is reversed (!DuAEF.Duik.Structure.linkPaths)
 * @return {Structure[]} The Structures
 */
DuAEF.Duik.Structure.addStructures = function( num, comp, name, forceNum, reverseAutoLink )
{
    num = def( num, 2 );
    comp = def( comp, DuAEF.DuAE.Project.getActiveComp() );
    if ( !comp ) return [];
    name = def( name, DuAEF.Duik.Structure.Strings.STRUCTURE );
    reverseAutoLink = def( reverseAutoLink, false );

    var structures = [];

    //paths filter.
    function pathsFilter ( prop )
    {
        if ( prop.matchName == "ADBE Vector Shape - Group" ) return true;
        if ( prop.matchName == "ADBE Mask Atom" ) return true;
        return false;
    }

    var layers = comp.selectedLayers;

    if ( layers.length > 0 )
    {
        var propsByLayer = [];
        var layerPositions = [];

        //get selected props
        var it = new DuList( layers );
        it.do( function( layer )
        {
            //get paths
            var props = DuAEF.DuAE.Layer.getSelectedProps( layer, pathsFilter );
            if ( props.length > 0 )
            {
                propsByLayer.push( props );
                return;
            }

            //puppet pins
            props = DuAEF.DuAE.Layer.getSelectedProps( layer, "ADBE FreePin3 PosPin Atom" );
            if ( props.length > 0 )
            {
                propsByLayer.push( props );
                return;
            }

            //puppet effect
            props = DuAEF.DuAE.Layer.getSelectedProps( layer, "ADBE FreePin3" );
            if ( props.length > 0 )
            {
                propsByLayer.push( props );
                return;
            }
        } );

        //create structures on selected props
        it = new DuList( propsByLayer );
        it.do( function( propsLayer )
        {
            if ( propsLayer.length == 0 ) return;

            //get paths
            if ( propsLayer[ 0 ].matchName == "ADBE Vector Shape - Group" || propsLayer[ 0 ].matchName == "ADBE Mask Atom" )
            {
                new DuList( propsLayer ).do( function( prop )
                {
                    structures.push( DuAEF.Duik.Structure.addStructureToPath( prop, num, forceNum, reverseAutoLink ) );
                } );
                return;
            }

            //puppet pins
            if ( propsLayer[ 0 ].matchName == "ADBE FreePin3 PosPin Atom" )
            {
                structures.push( DuAEF.Duik.Structure.addStructureToPuppetPins( propsLayer, num, forceNum, reverseAutoLink ) );
                return;
            }

            //puppet effect
            if ( propsLayer[ 0 ].matchName == "ADBE FreePin3" )
            {
                new DuList( propsLayer ).do( function( prop )
                {
                    if ( prop.matchName != "ADBE FreePin3" ) return;
                    structures.push( DuAEF.Duik.Structure.addStructureToPuppetEffect( prop, num, forceNum, reverseAutoLink ) );
                } );
                return;
            }
        } );

        if ( structures.length == 0 )
        {
            structures.push( DuAEF.Duik.Structure.addStructureToLayers( layers, num, forceNum, reverseAutoLink ) );
        }
    }

    if ( structures.length == 0 )
    {
        structures.push( DuAEF.Duik.Structure.addStructure( num, comp, name ) );
    }

    return structures;
}

/**
 * Creates a structure in a composition.
 * If path properties are selected, will create the structures on the vertices, if puppet pins, on the pins, else if layers, on the layers if they are not aligned.
 * @memberof DuAEF.Duik.Structure
 * @param {int}		[num=2]	- The number of elements of the structure.
 * @param {CompItem}	[comp]	- The composition where to create the Structure. Default is the active item, if it's a comp.
 * @param {string}	[name="Name"]	- The name of the structure (used as layer names)
 * @param {int}	[id] - An identifier for this structure
 * @return {Structure}	The Structure
 */
DuAEF.Duik.Structure.addStructure = function( num, comp, name, id )
{
    if ( typeof num === 'undefined' ) num = 2;
    if ( typeof comp === 'undefined' ) comp = DuAEF.DuAE.Project.getActiveComp();
    if ( !comp ) return new Structure();
    if ( typeof name === 'undefined' ) name = "Name";
    if ( typeof id === 'undefined' ) id = new Date().getTime();

    //end
    num++;

    //structure
    var structure = new Structure();

    //elements length
    var length = comp.width / 2 / ( num + 1 );

    var prevElement = null;
    var color = DuAEF.Duik.Structure.color;
    if ( color == DuColor.Color.RANDOM )
    {
        color = DuColor.randomFloatRGBA();
    }

    for ( var i = 0; i < num; i++ )
    {
        var end = i == num - 1;
        var element = DuAEF.Duik.Structure.addStructureElement( comp, color, undefined, id );
        if ( end )
        {
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( "S-End | " + name, comp );
            DuAEF.Duik.setDuikMarker( element, "Structure end", DuAEF.Duik.LayerTypes.STRUCTURE );
        }
        else
        {
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( "S | " + name, comp );
        }

        if ( prevElement )
        {
            element.parent = prevElement;
            element.transform.position.setValue( [ length, 0 ] );
        }
        else
        {
            element.transform.position.setValue( [ length + comp.width / 4, comp.height / 2 ] );
        }
        prevElement = element;
        structure.elements.push( element );
    }

    //links and layer selection
    for ( var i = 0; i < structure.elements.length; i++ )
    {
        if ( i == structure.elements.length - 1 )
        {
            structure.elements[ i ].effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( 3 ).setValue( structure.elements[ i ].index );
            structure.elements[ i ].selected = false;
        }
        else
        {
            structure.elements[ i ].effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( 3 ).setValue( structure.elements[ i + 1 ].index );
        }
    }
    structure.elements[ 0 ].selected = true;

    return structure;
}

/**
 * Adds a Structure to the Bezier Path
 * @param {Property|PropertyInfo} pathProperty - The path
 * @param {int} [num] - The number of elements of the structure.
 * @param {bool} [forceNum=false] - When true, the strucutre will have num elements even if there is less items in the selection (but will respect the selection if it is bigger)
 * @param {bool} [reverseAutoLink=false] - When true, the preference to force auto linking is reversed (!DuAEF.Duik.Structure.linkPaths)
 * @param {int}	[id] - An identifier for this structure
 * @return {Structure} The new Structure
 */
DuAEF.Duik.Structure.addStructureToPath = function( pathProperty, num, forceNum, reverseAutoLink, id )
{
    var propInfo = DuAEF.DuAE.Property.Bezier.checkProperty( pathProperty );
    if ( !propInfo ) throw "Expected a shape property, got another type of value.";
    var pathProperty = propInfo.getProperty();

    if ( typeof id === 'undefined' ) id = new Date().getTime();
    if ( typeof forceNum === 'undefined' ) forceNum = false;
    if ( typeof reverseAutoLink === 'undefined' ) reverseAutoLink = false;

    var link = DuAEF.Duik.Structure.linkPaths;
    if ( reverseAutoLink ) link = !DuAEF.Duik.Structure.linkPaths;

    var vertices = DuAEF.DuAE.Property.Bezier.verticesToComp( pathProperty );
    var comp = propInfo.comp;
    var layer = propInfo.layer;
    var name = pathProperty.parentProperty.name;

    var color = DuAEF.Duik.Structure.color;
    if ( color == DuColor.Color.RANDOM )
    {
        color = DuColor.randomFloatRGBA();
    }

    var numElements = vertices.length - 1;
    if ( typeof num === 'undefined' ) num = vertices.length - 1;
    if ( forceNum && num > numElements ) numElements = num;

    var structure = DuAEF.Duik.Structure.addStructure( numElements, comp, name, id );

    //move to the vertices
    var count = numElements;
    if ( vertices.length <= numElements ) count = vertices.length - 1;
    for ( var i = 0; i <= count; i++ )
    {
        var element = structure.elements[ i ];
        element.parent = null;
        element.transform.position.setValue( vertices[ i ] );
        structure.elements[ i ].moved = true;
        if ( i > 0 ) element.parent = structure.elements[ i - 1 ];
    }

    //add bones to the path
    if ( link && DuAEF.DuAE.App.version.version >= 15 )
    {
        DuAEF.Duik.Bone.rigShape( pathProperty, undefined, true, false );
        //set effects to use structure
        var currentElement = 0;
        for ( var i = 1; i <= layer( 'ADBE Effect Parade' ).numProperties; i++ )
        {
            var fx = layer( 'ADBE Effect Parade' ).property( i );
            if ( fx.matchName == DuAEF.Duik.PseudoEffects.SHAPE_LINKER.matchName )
            {
                fx( DuAEF.Duik.PseudoEffects.SHAPE_LINKER.vertexLayer ).setValue( structure.elements[ currentElement ].index );
                currentElement++;
                if ( currentElement == structure.elements.length ) break;
            }
        }
    }

    structure.moved = true;

    return structure;
}

/**
 * Adds a Structure to the layers. Will return an empty structure if all the layers are at the same place.
 * @param {Layer[]} layers - The layers
 * @param {int} [num] - The number of elements of the structure.
 * @param {bool} [forceNum=false] - When true, the strucutre will have num elements even if there is less items in the selection (but will respect the selection if it is bigger)
 * @param {bool} [reverseAutoLink=false] - When true, the preference to force auto linking is reversed (!DuAEF.Duik.Structure.linkPaths)
 * @return {Structure} The new Structure
 */
DuAEF.Duik.Structure.addStructureToLayers = function( layers, num, forceNum, reverseAutoLink, id )
{
    if ( typeof id === 'undefined' ) id = new Date().getTime();
    if ( typeof forceNum === 'undefined' ) forceNum = false;
    if ( typeof reverseAutoLink === 'undefined' ) reverseAutoLink = false;

    var link = DuAEF.Duik.Structure.linkLayers;
    if ( reverseAutoLink ) link = !DuAEF.Duik.Structure.linkLayers;

    var color = DuAEF.Duik.Structure.color;
    if ( color == DuColor.Color.RANDOM )
    {
        color = DuColor.randomFloatRGBA();
    }

    var comp = layers[ 0 ].containingComp;

    var numElements = layers.length - 1;
    if ( typeof num === 'undefined' ) num = layers.length - 1;
    if ( forceNum && num > numElements ) numElements = num;

    var structure = DuAEF.Duik.Structure.addStructure( numElements, comp, undefined, id );

    //check if there are layers at the same location
    var moveLayers = true;

    for ( var l = 0, numLayers = layers.length; l < numLayers; l++ )
    {
        var layer = layers[ l ];
        var pos = DuAEF.DuAE.Layer.getWorldPos( layer );
        //check if there is another layer at this position
        for ( var i = l + 1, num = layers.length; i < num; i++ )
        {
            var layer2 = layers[ i ];
            var pos2 = DuAEF.DuAE.Layer.getWorldPos( layer2 );
            if ( DuAEF.DuJS.Array.compare( pos2, pos, 0 ) )
            {
                moveLayers = false;
                break;
            }
        }
        if ( !moveLayers ) break;
    }

    //move to the layers, rename and parent
    var count = numElements;
    if ( layers.length <= numElements ) count = layers.length - 1;
    for ( var i = 0, num = count; i <= num; i++ )
    {
        var element = structure.elements[ i ];

        if ( moveLayers )
        {
            element.parent = null;
            element.transform.position.setValue( DuAEF.DuAE.Layer.getWorldPos( layers[ i ] ) );
            structure.elements[ i ].moved = true;
            if ( i > 0 ) element.parent = structure.elements[ i - 1 ];
        }

        if ( link ) layers[ i ].parent = element;

        element.name = DuAEF.DuAE.Comp.newUniqueLayerName( "S | " + layers[ i ].name, comp );
    }

    structure.moved = true;

    return structure;
}

/**
 * Adds a Structure to the Puppet Effect. Elements will be parented in the order of the pins in the stack
 * @param {PropertyGroup|PropertyInfo} puppetEffect - The puppet effect
 * @param {int} [num] - The number of elements of the structure.
 * @param {bool} [forceNum=false] - When true, the strucutre will have num elements even if there is less items in the selection (but will respect the selection if it is bigger)
 * @param {bool} [reverseAutoLink=false] - When true, the preference to force auto linking is reversed (!DuAEF.Duik.Structure.linkPaths)
 * @return {Structure} The new Structure
 */
DuAEF.Duik.Structure.addStructureToPuppetEffect = function( puppetEffect, num, forceNum, reverseAutoLink, id )
{
    var propInfo = new PropertyInfo( puppetEffect );
    puppetEffect = propInfo.getProperty();

    var pins = [];

    var meshGroup = puppetEffect.property( "ADBE FreePin3 ARAP Group" ).property( "ADBE FreePin3 Mesh Group" );
    for ( var i = 1, numProps = meshGroup.numProperties; i <= numProps; i++ )
    {
        var mesh = meshGroup( i );
        var pinsGroup = mesh.property( "ADBE FreePin3 PosPins" );
        for ( var j = 1, numPins = pinsGroup.numProperties; j <= numPins; j++ )
        {
            var pin = pinsGroup.property( j );
            var test = new PropertyInfo( pin.property( "ADBE FreePin3 PosPin Position" ) );
            if ( test.riggable ) pins.push( new PropertyInfo( pin ) );
        }
    }

    var structure = DuAEF.Duik.Structure.addStructureToPuppetPins( pins, num, forceNum, reverseAutoLink, id );

    return structure;
}

/**
 * Adds a Structure to the Puppet Pins. Elements will be parented in the order of the Array.
 * @param {Property[]|PropertyInfo[]} puppetPins - The pins
 * @param {int} [num] - The number of elements of the structure.
 * @param {bool} [forceNum=false] - When true, the strucutre will have num elements even if there is less items in the selection (but will respect the selection if it is bigger)
 * @param {bool} [reverseAutoLink=false] - When true, the preference to force auto linking is reversed (!DuAEF.Duik.Structure.linkPaths)
 * @return {Structure} The new Structure
 */
DuAEF.Duik.Structure.addStructureToPuppetPins = function( puppetPins, num, forceNum, reverseAutoLink, id )
{
    if ( typeof id === 'undefined' ) id = new Date().getTime();
    if ( typeof forceNum === 'undefined' ) forceNum = false;
    if ( typeof reverseAutoLink === 'undefined' ) reverseAutoLink = false;

    var link = DuAEF.Duik.Structure.linkPins;
    if ( reverseAutoLink ) link = !DuAEF.Duik.Structure.linkPins;

    var propInfo = new PropertyInfo( puppetPins[ 0 ] );
    var comp = propInfo.comp;

    var color = DuAEF.Duik.Structure.color;
    if ( color == DuColor.Color.RANDOM )
    {
        color = DuColor.randomFloatRGBA();
    }

    var numElements = puppetPins.length - 1;
    if ( typeof num === 'undefined' ) num = puppetPins.length - 1;
    if ( forceNum && num > numElements ) numElements = num;

    var structure = DuAEF.Duik.Structure.addStructure( numElements, comp, undefined, id );

    //move and link to the pins
    var count = numElements;
    if ( puppetPins.length <= numElements ) count = puppetPins.length - 1;
    for ( var i = 0, num = count; i <= num; i++ )
    {
        var element = structure.elements[ i ];
        element.parent = null;

        //get pin position
        var pin = puppetPins[ i ];

        var propInfo = new PropertyInfo( pin );
        pin = propInfo.getProperty();
        var parentPin;

        if ( pin.matchName == "ADBE FreePin3 PosPin Atom" )
        {
            parentPin = pin;
            pin = pin.property( "ADBE FreePin3 PosPin Position" );
        }
        else
        {
            parentPin = pin.parentProperty;
        }

        element.transform.position.setValue( DuAEF.DuAE.Layer.getWorldPos( propInfo.layer, pin.value ) );
        structure.elements[ i ].moved = true;

        element.name = DuAEF.DuAE.Comp.newUniqueLayerName( "S | " + parentPin.name, comp );
        if ( i > 0 ) element.parent = structure.elements[ i - 1 ];

        //link
        if ( link ) DuAEF.Duik.Bone.linkPositionToBone( pin, element, false );
    }

    structure.moved = true;

    return structure;
}

/**
 * Creates an element for a structure in a composition
 * @memberof DuAEF.Duik.Structure
 * @param {CompItem}	comp	- The composition where to create the Structure
 * @param {float[]}	[color=[1,0.764,0.764,1]]		- The color of the element, [R,G,B,A] Array from 0.0 to 1.0
 * @param {float}	[size] 		- The element size, a percentage. By default, it will adjust automatically depending on comp size and DuikLib.structureSizeHint
 * @return {ShapeLayer}	The element
 */
DuAEF.Duik.Structure.addStructureElement = function( comp, color, size, id )
{
    if ( size == undefined )
    {
        size = comp.width / 2 + comp.height / 2;
        if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.SMALL ) size = Math.floor( size / 14 );
        else if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.MEDIUM ) size = Math.floor( size / 10 );
        else if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.LARGE ) size = Math.floor( size / 6 );
        else if ( DuAEF.Duik.Structure.sizeHint == DuAEF.Duik.Sizes.CUSTOM ) size = DuAEF.Duik.Structure.size;
        size = DuMath.clamp(size, 0, 1000);
    }

    if ( !color )
    {
        color = DuAEF.Duik.Structure.color;
        if ( color == DuColor.Color.RANDOM )
        {
            color = DuColor.randomFloatRGBA();
        }
    }


    //======= CREATE ELEMENT USING SHAPE LAYER =======
    var element = comp.layers.addShape();
    DuAEF.Duik.setDuikMarker( element, DuAEF.Duik.Structure.Strings.STRUCTURE, DuAEF.Duik.LayerTypes.STRUCTURE );
    DuAEF.Duik.setDuikMarkerParameter( element, DuAEF.Duik.MarkerParameters.STRUCTURE_ID, id );
    element.label = 7;
    element.guideLayer = true;
    element.quality = LayerQuality.DRAFT;

    //add effect
    var elementEffect = DuAEF.Duik.PseudoEffects.STRUCTURE.apply( element );
    elementEffect( 2 ).setValue( size );
    elementEffect( 4 ).setValue( color );
    var index = DuAEF.Duik.PseudoEffects.STRUCTURE.index;

    //content

    //Structure Element Group
    var mainGroup = element("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    mainGroup.name = 'Structure Element';
    //scale
    mainGroup('ADBE Vector Transform Group')('ADBE Vector Scale').expression = [ DuAEF.Duik.expressionIds.STRUCTURE,
        'if(!active) value;',
        'else',
        '{',
        'var s = effect("' + elementEffect.name + '")(' + index['Display options_Size_Slider'] + ');',
        '[s,s];',
        '}'
	].join('\n');
    //look-at
    mainGroup('ADBE Vector Transform Group')('ADBE Vector Rotation').expression = [ DuAEF.Duik.expressionIds.STRUCTURE,
        'if ( active ) {',
        '    var child = null;',
        '    var childIndex = -1;',
        '    var fx = effect("' + elementEffect.name + '");',
        '    try {',
        '        child = fx( ' + index['Display options_Target_Layer'] + ' );',
        '        childIndex = child.index || fx( ' + index['Display options_Size_Slider'] + ' ).value == 0',
        '    } catch ( e ) {}',
        '    if ( childIndex == thisLayer.index ) value;',
        '    else {',
        '        var R = 45;',
        '',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Structure Element" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        var result = value;',
        '        var layer = thisLayer;',
        '        while ( layer.hasParent ) {',
        '            layer = layer.parent;',
        '            result = result - layer.rotation;',
        '        }',
        '        if ( child )',
        '            if ( child.index != index ) {',
        '                C = child.toWorld( child.anchorPoint );',
        '                O = thisLayer.toWorld( thisLayer.anchorPoint );',
        '                var vec = O - C;',
        '                var angle = Math.atan2( vec[ 1 ], vec[ 0 ] );',
        '                var ik = radiansToDegrees( angle );',
        '                result += ( ik - 90 - rotation )',
        '            }',
        '        result;',
        '    }',
        '} else value;'
	].join('\n');

    //Target Group
    var targetGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetGroup.name = 'Target';
    var targetContent = targetGroup.property("ADBE Vectors Group");
    //1st ellipse
    var shape = targetContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([15,15]);
    //2nd ellipse
    shape = targetContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([1,1]);
    //stroke
    var stroke = targetContent.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").setValue([ 0.1, 0.1, 0.1, 1.0]);
    stroke("ADBE Vector Stroke Width").setValue( 2 );

    //Display Group
    var displayGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    displayGroup.name = 'Display';
    //display opacity
    displayGroup('ADBE Vector Transform Group')('ADBE Vector Group Opacity').setValue(50);
    //Link Group 
    var linkGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    linkGroup.name = 'Link';
    //anchor point
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Anchor').setValue([ 0, 10]);
    var linkContent = linkGroup.property("ADBE Vectors Group");
    //star
    shape = linkContent.addProperty("ADBE Vector Shape - Star");
    shape("ADBE Vector Star Points").setValue( 3 );
    shape("ADBE Vector Star Outer Radius").setValue( 20 );
    shape("ADBE Vector Star Outer Roundess").setValue( 100 );
    shape("ADBE Vector Star Type").setValue( 2 );
    shape("ADBE Vector Star Outer Roundess").expression = [ DuAEF.Duik.expressionIds.STRUCTURE,
        'if ( active ) {',
        '    var child = null;',
        '    var childIndex = -1;',
        '    var fx = effect( "' + elementEffect.name + '" );',
        '    try {',
        '        child = fx( ' + index['Display options_Target_Layer'] + ' );',
        '        childIndex = child.index',
        '    } catch ( e ) {}',
        '    if ( childIndex == thisLayer.index || fx( ' + index['Display options_Size_Slider'] + ' ) == 0 ) value;',
        '    else {',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Structure Element" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        if ( child ) {',
        '            var A = child.toWorld( child.anchorPoint );',
        '            var B = thisLayer.toWorld( thisLayer.anchorPoint );',
        '            var dist = length( A, B );',
        '            if ( dist < 20 ) dist = 20;',
        '            var s = thisLayer( "ADBE Root Vectors Group" )( "Structure Element" ).transform.scale[ 0 ];',
        '            value / ( dist / 60 ) * s / 80;',
        '        } else value;',
        '    }',
        '}',
        'else value;'
    ].join('\n');
    //fill
    var fill = linkContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").expression = [ DuAEF.Duik.expressionIds.STRUCTURE,
	    'effect("' + elementEffect.name +'")( ' + index['Display options_Color_Color'] + ').value;'
	].join('\n');
    //group scale
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Scale').expression = [ DuAEF.Duik.expressionIds.STRUCTURE,
        'if ( active ) {',
        '    var child = null;',
        '    var childIndex = -1;',
        '    var fx = effect( "' + elementEffect.name + '" );',
        '    try {',
        '        child = fx( ' + index['Display options_Target_Layer'] + ' );',
        '        childIndex = child.index',
        '    } catch ( e ) {}',
        '    if ( childIndex == thisLayer.index || fx( ' + index['Display options_Size_Slider'] + ' ) == 0 )[ 0, 0 ];',
        '    else {',
        '        var X = 100;',
        '        var Y = 60;',
        '',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Structure Element" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        if ( child ) {',
        '            var A = child.toWorld( child.anchorPoint );',
        '            var B = thisLayer.toWorld( thisLayer.anchorPoint );',
        '            var dist = length( A, B );',
        '            Y = dist / 30 * 100;',
        '        }',
        '        [ X, Y * 100 / thisLayer( "ADBE Root Vectors Group" )( "Structure Element" ).transform.scale[ 1 ] ];',
        '    }',
        '} else value;'
	].join('\n');

    //group
    DuAEF.Dugr.addLayerToGroup( element, "Structures" );

    //lock scale
    element.transform.scale.expression = '[100,100];';
    element.moved = false;

    return element;
}

/**
 * Gets structures in the comp. If some layers are selected, uses selectionMode, else returns all structure elements found.
 * @memberof DuAEF.Duik.Structure
 * @param {CompItem}	[comp=app.project.activeItem]	- The composition where to get the structures
 * @param {int} [structureSelectionMode=DuAEF.Duik.Structure.SelectionModes.STRUCTURE]	- The selection mode. One of {@link DuAEF.Duik.Structure.SelectionModes}
 * @return {Structure[]}	The structures. If selectionMode is DuAEF.Duik.Structure.SelectionModes.ELEMENT, will be one structure with all elements found
 */
DuAEF.Duik.Structure.getStructures = function( comp, selectionMode )
{
    if ( typeof comp === 'undefined' ) comp = DuAEF.DuAE.Project.getActiveComp();
    if ( !comp ) return [];

    if ( selectionMode == undefined ) selectionMode = DuAEF.Duik.Structure.SelectionModes.STRUCTURE;
    var layers = comp.selectedLayers;

    if ( selectionMode == DuAEF.Duik.Structure.SelectionModes.ALL )
    {
        layers = comp.layers;
        selectionMode = DuAEF.Duik.Structure.SelectionModes.STRUCTURE;
    }

    var structures = [];
    var indexed = [];

    if ( layers.length == 0 ) return structures;

    var it = new DuList( layers );

    if ( selectionMode == DuAEF.Duik.Structure.SelectionModes.ELEMENT )
    {
        var elementLayers = [];

        it.do( function( layer )
        {
            if ( !DuAEF.Duik.isLayerType( layer, DuAEF.Duik.LayerTypes.STRUCTURE ) ) return;
            if ( DuAEF.DuJS.Array.indexOf( indexed, layer.index ) >= 0 ) return;

            indexed.push( layer.index );

            elementLayers.push( layer );
        } );

        //TODO sort by id.
        var structures = [];

        if ( elementLayers.length == 0 ) return structures;

        var itElements = new DuList( elementLayers );
        itElements.do( function( element )
        {
            var elementId = -1;
            var params = DuAEF.Duik.getDuikMarkerParameters( element );
            if ( params[ DuAEF.Duik.MarkerParameters.STRUCTURE_ID ] ) elementId = params[ DuAEF.Duik.MarkerParameters.STRUCTURE_ID ];
            //search in structures
            for ( var i = 0, num = structures.length; i < num; i++ )
            {
                var structure = structures[ i ];
                if ( structure.structureId == elementId )
                {
                    structure.elements.push( element );
                    return;
                }
            }
            //create new structure
            var structure = new Structure( [ element ] );
            structures.push( structure );
        } );

        return structures;

    }
    else
    {
        it.do( function( layer )
        {
            if ( !DuAEF.Duik.isLayerType( layer, DuAEF.Duik.LayerTypes.STRUCTURE ) ) return;
            if ( DuAEF.DuJS.Array.indexOf( indexed, layer.index ) >= 0 ) return;

            indexed.push( layer.index );

            structure = new Structure();

            //TODO improve using ID

            structure.elements.push( layer );
            //get children
            if ( selectionMode == DuAEF.Duik.Structure.SelectionModes.CHILDREN || selectionMode == DuAEF.Duik.Structure.SelectionModes.STRUCTURE )
            {
                //for all layers in the comp, get child
                var childLayer = layer;
                while ( childLayer != null )
                {
                    var structureEffect = childLayer.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName );
                    var childIndex = -1;
                    if ( structureEffect ) childIndex = structureEffect( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Target_Layer'] ).value;
                    if ( childIndex == childLayer.index ) break;
                    var currentIndex = childLayer.index;
                    childLayer = null;
                    //get child
                    if ( childIndex > 0 )
                    {
                        var child = comp.layer( childIndex );
                        //check if it's a structure element
                        if ( DuAEF.Duik.isLayerType( child, DuAEF.Duik.LayerTypes.STRUCTURE ) )
                        {
                            structure.elements.push( child );
                            childLayer = child;
                            indexed.push( child.index );
                            continue;
                        }
                    }
                    //search child
                    for ( var j = 1; j <= comp.layers.length; j++ )
                    {
                        var child = comp.layer( j );
                        if ( child.parent == null ) continue;
                        if ( DuAEF.Duik.isLayerType( child, DuAEF.Duik.LayerTypes.STRUCTURE ) && child.parent.index == currentIndex )
                        {
                            structure.elements.push( child );
                            childLayer = child;
                            indexed.push( child.index );
                            break;
                        }
                    }
                }
            }

            //get parents
            if ( selectionMode == DuAEF.Duik.Structure.SelectionModes.STRUCTURE )
            {
                var parentLayer = layer;
                while ( parentLayer != null )
                {
                    var testParent = parentLayer.parent;
                    var childIndex = parentLayer.index;

                    if ( testParent == null ) break;
                    else if ( !DuAEF.Duik.isLayerType( testParent, DuAEF.Duik.LayerTypes.STRUCTURE ) ) break;

                    var structureEffect = testParent.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName );
                    var testIndex = -1;
                    if ( structureEffect ) testIndex = structureEffect( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Target_Layer'] ).value;

                    parentLayer = null;

                    if ( testIndex == testParent.index ) break;
                    else if ( testIndex == 0 || testIndex == childIndex )
                    {
                        structure.elements.unshift( testParent );
                        parentLayer = testParent;
                        indexed.push( testParent.index );
                    }
                }
            }

            structures.push( structure );
        } );
    }

    return structures;
}

/**
 * Gets structures in the comp or the selection.
 * @param {CompItem}	[comp]	- The composition where to get the structure layers
 * @param {boolean} [selectedOnly=false] - Selected layers only
 * @return {ShapeLayer[]}	The structure layers.
 */
DuAEF.Duik.Structure.getStructureLayers = function( comp, selectedOnly )
{
    if ( typeof selectedOnly === 'undefined' ) selectedOnly = false;
    if ( typeof comp === 'undefined' ) comp = DuAEF.DuAE.Project.getActiveComp();
    if ( !comp ) return [];

    var structures = DuAEF.Duik.getLayers( DuAEF.Duik.LayerTypes.STRUCTURE, selectedOnly, comp );

    return structures;
}

/**
 * Selects structures in the comp. If some layers are selected, uses selectionMode, else returns selects all structure elements found.
 * @memberof DuAEF.Duik.Structure
 * @param {CompItem}	[comp=app.project.activeItem]	- The composition where to select the structures
 * @param {int} [structureSelectionMode=DuAEF.Duik.Structure.SelectionModes.STRUCTURE]	- The selection mode. One of {@link DuAEF.Duik.Structure.SelectionModes}
 * @return {Structure[]}	The structures. If selectionMode is DuAEF.Duik.Structure.SelectionModes.ELEMENT, will be one structure with all elements found
 */
DuAEF.Duik.Structure.selectStructures = function( comp, selectionMode )
{
    if ( typeof comp === 'undefined' ) comp = DuAEF.DuAE.Project.getActiveComp();
    if ( !comp ) return;

    var structures = DuAEF.Duik.Structure.getStructures( comp, selectionMode );
    if ( structures.length == 0 ) return;

    DuAEF.DuAE.Comp.unselectLayers( comp );

    var itStr = new DuList( structures );
    itStr.do( function( structure )
    {
        var itElmts = new DuList( structure.elements );
        itElmts.do( function( element )
        {
            element.selected = true;
        } );
    } );
}

/**
 * Creates a predefined structure for an arm.
 * @memberof DuAEF.Duik.Structure
 * @param {boolean} [shoulder=false] - true if the arm has a shoulder.
 * @param {boolean} [humerus=true] - true if the arm has a humerus.
 * @param {boolean} [radius=true] - true if the arm has a radius.
 * @param {boolean} [hand=true] - true if the arm has a hand.
 * @param {boolean} [claws=false] - true if the arm has claws.
 * @param {boolean} [left=false] - true if this is a Left arm, false for a Right arm
 * @param {DuAEF.Duik.Autorig.AnimalTypes} [type=DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE] - the type of animal
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @param {Number[]} [originPosition] - The coordinates in the comp of the first element of the structure.
 * @param {boolean} [symetry=false] - changes the coordinates of the humerus, applying a symetry on the shoulder (if any).
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createArm = function( shoulder, humerus, radius, hand, claws, left, type, comp, originPosition, symetry, forceLink )
{
    comp = def( comp, DuAEF.DuAE.Project.getActiveComp() );
    if ( !comp ) return null;
    shoulder = def( shoulder, false );
    humerus = def( humerus, true );
    radius = def( radius, true );
    hand = def( hand, true );
    claws = def( claws, false );
    left = def( left, false );
    type = def( type, DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE );
    originPosition = def( originPosition, [ comp.width / 2, comp.height / 4 ] );
    symetry = def( symetry, false );

    var plantigrade = type == DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE;
    var digitigrade = type == DuAEF.Duik.Autorig.AnimalTypes.DIGITIGRADE;
    var ungulate = type == DuAEF.Duik.Autorig.AnimalTypes.UNGULATE;

    //create structure
    var numElements = 0;
    if ( shoulder ) numElements++;
    if ( humerus ) numElements++;
    if ( radius ) numElements++;
    if ( hand ) numElements++;
    if ( claws ) numElements++;

    if ( numElements == 0 ) return null;

    var structures = DuAEF.Duik.Structure.addStructures( numElements, comp, undefined, true, forceLink );

    new DuList( structures ).do( function( structure )
    {
        //element index we're working on
        var currentElement = 0;

        //size of the humerus
        var size = comp.height / 7;
        if ( digitigrade ) size = comp.height / 9;
        else if ( ungulate ) size = comp.height / 11;

        //position of the next limb
        var nextPosition = originPosition;

        var shoulderLayer, humerusLayer, radiusLayer, handLayer, clawsLayer, palmLayer, tipLayer;

        if ( shoulder )
        {
            //set limb position and name
            var element = structure.elements[ currentElement ];
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.SHOULDER );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.RAINBOX_RED );
            //position of the next limb
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            shoulderLayer = element;
            if ( !symetry )
            {
                if ( plantigrade ) nextPosition = [ -size / 2, size / 6 ];
                else if ( digitigrade ) nextPosition = [ -size * 3 / 4, size * 3 / 4 ];
                else if ( ungulate ) nextPosition = [ -size, size ];
            }
            else
            {
                if ( plantigrade ) nextPosition = [ size / 2, size / 6 ];
                else if ( digitigrade ) nextPosition = [ size * 3 / 4, size * 3 / 4 ];
                else if ( ungulate ) nextPosition = [ size, size ];
            }

            //next
            currentElement++;
        }
        if ( humerus )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.ARM );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.ORANGE );
            humerusLayer = element;
            if ( plantigrade ) nextPosition = [ size / 6, size ];
            else if ( digitigrade ) nextPosition = [ size * 3 / 4, size * 3 / 4 ];
            else if ( ungulate ) nextPosition = [ size * 3 / 4, size * 3 / 4 ];
            currentElement++;
        }
        if ( radius )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            else size = DuMath.getLength( [ 0, 0 ], element.transform.position.value );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.FOREARM );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.YELLOW );
            radiusLayer = element;
            if ( plantigrade ) nextPosition = [ -size / 6, size ];
            else if ( digitigrade ) nextPosition = [ -size / 3, size * 4 / 3 ];
            else if ( ungulate ) nextPosition = [ -size / 2, size * 3 / 2 ];
            currentElement++;
        }
        if ( hand )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.HAND );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.GREEN );
            handLayer = element;
            if ( plantigrade )
            {
                if ( claws ) nextPosition = [ -size / 3, size / 8 ];
                else nextPosition = [ size / 3, size / 3 ];
            }
            else if ( digitigrade ) nextPosition = [ 0, size * 3 / 8 ];
            else if ( ungulate ) nextPosition = [ size / 5, size ];
            currentElement++;
        }
        if ( claws )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = ungulate ? DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.HOOF ) : DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.CLAWS );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.LIGHT_BLUE );
            clawsLayer = element;
            if ( plantigrade ) nextPosition = [ -size / 4, 0 ];
            else if ( digitigrade ) nextPosition = [ -size / 4, 0 ];
            else if ( ungulate ) nextPosition = [ 0, size / 2 ];
            currentElement++;
        }
        var element = structure.elements[ currentElement ];
        if ( !element.moved ) element.transform.position.setValue( nextPosition );
        var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.ARM_TIP );
        element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
        tipLayer = element;

        //heel
        if ( plantigrade && claws )
        {
            var heelStructure = DuAEF.Duik.Structure.addStructure( 0, comp );
            var element = heelStructure.elements[ 0 ];
            element.parent = structure.elements[ structure.elements.length - 1 ];
            if ( !element.moved ) element.transform.position.setValue( [ size / 4 + size / 3, 0 ] );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( "S | Heel", comp );
            element.selected = false;
            structure.elements[ 0 ].selected = true;
            structure.elements.push( element );
            palmLayer = element;
        }

        DuAEF.Duik.Autorig.tagArm( shoulderLayer, humerusLayer, radiusLayer, handLayer, clawsLayer, palmLayer, tipLayer, type )
    } );

    return structures;

}

/**
 * Creates a predefined structure for an leg.
 * @memberof DuAEF.Duik.Structure
 * @param {boolean} [femur=true] - true if the leg has a shoulder.
 * @param {boolean} [tibia=true] - true if the leg has a humerus.
 * @param {boolean} [foot=true] - true if the leg has a radius.
 * @param {boolean} [toes=true] - true if the leg has a hand.
 * @param {boolean} [left=false] - true if this is a Left leg, false for a Right leg
 * @param {DuAEF.Duik.Autorig.AnimalTypes} [type=DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE] - the type of animal
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @param {Number[]} [originPosition] - The coordinates in the comp of the first element of the structure.
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createLeg = function( femur, tibia, foot, toes, left, type, comp, originPosition, forceLink )
{
    comp = def( comp, DuAEF.DuAE.Project.getActiveComp() );
    if ( !comp ) return null;
    femur = def( femur, true );
    tibia = def( tibia, true );
    foot = def( foot, true );
    toes = def( toes, true );
    left = def( left, false );
    type = def( type, DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE );
    originPosition = def( originPosition, [ comp.width / 2, comp.height / 2 ] );


    var plantigrade = type == DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE;
    var digitigrade = type == DuAEF.Duik.Autorig.AnimalTypes.DIGITIGRADE;
    var ungulate = type == DuAEF.Duik.Autorig.AnimalTypes.UNGULATE;

    //create structure
    var numElements = 0;
    if ( femur ) numElements++;
    if ( tibia ) numElements++;
    if ( foot ) numElements++;
    if ( toes ) numElements++;

    if ( numElements == 0 ) return null;

    var structures = DuAEF.Duik.Structure.addStructures( numElements, comp, undefined, true, forceLink );
    //need copy the type locally to make it available for the function in the DuList
    var legType = type;
    new DuList( structures ).do( function( structure )
    {
        //name and move

        //element index we're working on
        var currentElement = 0;

        //size of the femur
        var size = comp.height / 6;
        if ( digitigrade ) size = comp.height / 8;
        else if ( ungulate ) size = comp.height / 9;

        //position of the next limb
        var nextPosition = originPosition;

        var femurLayer, tibiaLayer, footLayer, toesLayer, heelLayer, tipLayer, type;

        if ( femur )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition ); 
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.THIGH );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.ORANGE );
            femurLayer = element;
            if ( plantigrade ) nextPosition = [ -size / 6, size ];
            else if ( digitigrade ) nextPosition = [ -size * 3 / 4, size * 3 / 4 ];
            else if ( ungulate ) nextPosition = [ -size / 2, size * 3 / 4 ];
            currentElement++;
        }
        if ( tibia )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            else size = DuMath.getLength( [ 0, 0 ], element.transform.position.value );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.CALF );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.YELLOW );
            tibiaLayer = element;
            if ( plantigrade ) nextPosition = [ size / 6, size ];
            else if ( digitigrade ) nextPosition = [ size * 3 / 4, size * 3 / 4 ];
            else if ( ungulate ) nextPosition = [ size * 2 / 3, size * 3 / 4 ];
            currentElement++;
        }
        if ( foot )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.FOOT );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.GREEN );
            footLayer = element;
            if ( plantigrade ) nextPosition = [ -size * 3 / 8, size / 6 ];
            else if ( digitigrade ) nextPosition = [ 0, size / 2 ];
            else if ( ungulate ) nextPosition = [ -size / 4, size ];
            currentElement++;
        }
        if ( toes )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = "";
            if ( plantigrade ) name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.TOES );
            else if ( digitigrade ) name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.CLAWS );
            else name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.HOOF );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.LIGHT_BLUE );
            toesLayer = element;
            if ( plantigrade ) nextPosition = [ -size / 8, 0 ];
            else if ( digitigrade ) nextPosition = [ -size / 4, 0 ];
            else if ( ungulate ) nextPosition = [ 0, size / 4 ];
            currentElement++;
        }

        var element = structure.elements[ currentElement ];
        if ( !element.moved ) element.transform.position.setValue( nextPosition );
        var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.TIPTOE );
        element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
        tipLayer = element;
        //heel
        if ( plantigrade && toes )
        {
            var heelStructure = DuAEF.Duik.Structure.addStructure( 0, comp );
            var element = heelStructure.elements[ 0 ];
            element.parent = structure.elements[ structure.elements.length - 1 ];
            if ( !element.moved )
            {
                var sign = 1;
                //if the tiptoe is on the right of the toe, move the heel to the left
                if (structure.elements[ currentElement ].transform.position.value[0] > 0 ) sign = -1;
                element.transform.position.setValue( [ sign * size / 2, 0 ] );
            }
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.HEEL );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.selected = false;
            structure.elements[ 0 ].selected = true;
            heelLayer = element;
        }

        DuAEF.Duik.Autorig.tagLeg( femurLayer, tibiaLayer, footLayer, toesLayer, heelLayer, tipLayer, legType );
    } );

    return structures;
}

/**
 * Creates a predefined structure for an spine / neck / head.
 * @memberof DuAEF.Duik.Structure
 * @param {boolean} [hips=true] - true if the spine has a hips.
 * @param {int} [spineCount=2] - the number of elements for the spine
 * @param {int} [neckCount=1] - the number of elements for the neck
 * @param {boolean} [head=true] - true if the spine has a hand.
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @param {Number[]} [originPosition] - The coordinates in the comp of the first element of the structure.
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createSpine = function( hips, spineCount, neckCount, head, comp, originPosition, forceLink )
{
    comp = def( comp, DuAEF.DuAE.Project.getActiveComp() );
    if ( !comp ) return null;
    hips = def( hips, true );
    spineCount = def( spineCount, 2 );
    neckCount = def( neckCount, 1 );
    head = def( head, true );
    originPosition = def( originPosition, [ comp.width / 2, comp.height * 3 / 4 ] );

    //create structure
    var numElements = 0;
    if ( head ) numElements++;
    numElements += neckCount;
    numElements += spineCount;
    if ( hips ) numElements++;

    if ( numElements == 0 ) return null;

    var structures = DuAEF.Duik.Structure.addStructures( numElements, comp, undefined, true, forceLink );
    new DuList(structures).do( function( structure )
    {
        //name and move

        //element index we're working on
        var currentElement = 0;

        //size of the spine
        var size = comp.height / 4;

        //position of the next limb
        var nextPosition = originPosition;

        var hipsLayer, headLayer, tipLayer;
        var spineLayer = [];
        var neckLayer = [];

        if ( hips )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.HIPS );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.RAINBOX_RED );
            hipsLayer = element;
            nextPosition = [ 0, -size / 6 ];
            currentElement++;
        }
        for ( var i = 0; i < spineCount; i++ )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            else if ( i > 0 ) size = DuMath.getLength( [ 0, 0 ], element.transform.position.value );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.SPINE );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.ORANGE );
            spineLayer.push( element );
            nextPosition = [ 0, -size / spineCount ];
            currentElement++;
        }
        for ( var i = 0; i < neckCount; i++ )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.NECK );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.YELLOW );
            neckLayer.push( element );
            nextPosition = [ 0, -size / 6 / neckCount ];
            currentElement++;
        }
        if ( head )
        {
            var element = structure.elements[ currentElement ];
            if ( !element.moved ) element.transform.position.setValue( nextPosition );
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.HEAD );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.GREEN );
            headLayer = element;
            nextPosition = [ 0, -size / 3 ];
            currentElement++;
        }
        var element = structure.elements[ currentElement ];
        if ( !element.moved ) element.transform.position.setValue( nextPosition );
        var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.SPINE_TIP );
        element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
        tipLayer = element;

        DuAEF.Duik.Autorig.tagSpine( hipsLayer, spineLayer, neckLayer, headLayer, tipLayer );
    } );

    return structures;
}

/**
 * Creates a predefined structure for a tail.
 * @memberof DuAEF.Duik.Structure
 * @param {int} [elementCount=2] - the number of elements for the tail
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createTail = function( elementCount, comp, forceLink )
{
    comp = def( comp, DuAEF.DuAE.Project.getActiveComp() );
    if ( !comp ) return null;

    //create structure
    elementCount = def( elementCount, 3 );
    if ( elementCount == 0 ) return;

    var structures = DuAEF.Duik.Structure.addStructures( elementCount, comp, undefined, true, forceLink );
    new DuList( structures ).do( function( structure )
    {
        var tailLayer = [];
        var tipLayer;

        for ( var i = 0, num = structure.elements.length; i < num; i++ )
        {
            var element = structure.elements[ i ];
            var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.TAIL );
            element.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
            if ( i < num / 3 - 1 ) element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.ORANGE );
            else if ( i < num * 2 / 3 - 1 ) element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.YELLOW );
            else element.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName )( DuAEF.Duik.PseudoEffects.STRUCTURE.index['Display options_Color_Color'] ).setValue( DuColor.Color.LIGHT_BLUE );
            tailLayer.push( element );
        }

        tipLayer = structure.elements[ elementCount ];
        var name = DuAEF.Duik.generateName( "S", DuAEF.Duik.Structure.Strings.TAIL_TIP );
        tipLayer.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );

        DuAEF.Duik.Autorig.tagTail( tailLayer, tipLayer );
    } );

    return structures;
}

/**
 * Resets the transformations (rotation and scale) of the element to 0 and 100%
 * @memberof DuAEF.Duik.Structure
 * @param {Layer} layer - the element
 */
DuAEF.Duik.Structure.resetTransform = function( layer )
{
    if ( !DuAEF.Duik.isLayerType( layer, DuAEF.Duik.LayerTypes.STRUCTURE ) ) return;
    var children = DuAEF.DuAE.Layer.getChildren( layer );
    var it = new DuList( children );
    it.do( function( child )
    {
        var locked = child.locked;
        if ( locked ) child.locked = false;
        child.parent = null;
        child.locked = locked;
    } );
    layer.transform.rotation.setValue( 0 );
    layer.transform.scale.setValue( [ 100, 100, 100 ] );
    it.do( function( child )
    {
        var locked = child.locked;
        if ( locked ) child.locked = false;
        child.parent = layer;
        child.locked = locked;
    } );
}

/**
 * "Bakes" the appearance of the Structure,<br />
 * in order to improve performance and simplify the use of the rig when animating.
 * @memberof DuAEF.Duik.Structure
 * @param {Layer} layer - the element
 */
DuAEF.Duik.Structure.bakeAppearence = function( layer )
{
    if ( !DuAEF.Duik.isLayerType( layer, DuAEF.Duik.LayerTypes.STRUCTURE ) ) return;

    var effect = layer.effect( DuAEF.Duik.PseudoEffects.STRUCTURE.matchName );
    if ( !effect ) return;

    //bake all
    var elementGroup = layer.property( 'ADBE Root Vectors Group' )( "Structure Element" );
    DuAEF.DuAE.Property.removeExpression( elementGroup.property( 'ADBE Vector Transform Group' )( 'ADBE Vector Scale' ) );
    DuAEF.DuAE.Property.removeExpression( elementGroup.property( "ADBE Vector Transform Group" )( "ADBE Vector Rotation" ) );

    var displayGroup = elementGroup.property( 'ADBE Vectors Group' )( "Display" );
    var stretchBoneGroup = displayGroup.property( 'ADBE Vectors Group' )( "Link" );
    var stretchBoneContent = stretchBoneGroup.property( "ADBE Vectors Group" );

    DuAEF.DuAE.Property.removeExpression( stretchBoneContent.property( "ADBE Vector Shape - Star" )( "ADBE Vector Star Outer Roundess" ) );
    DuAEF.DuAE.Property.removeExpression( stretchBoneContent.property( "ADBE Vector Graphic - Fill" )( "ADBE Vector Fill Color" ) );
    DuAEF.DuAE.Property.removeExpression( stretchBoneGroup.property( "ADBE Vector Transform Group" )( "ADBE Vector Scale" ) );

    effect.remove();
}

/**
	* Automations
	* @namespace
	* @memberof DuAEF.Duik
*/
DuAEF.Duik.Automation = {};

/**
 * Adds a effect on the layer to control all the interpolations from all the properties from a single property.
 * @param {PropertyBase[]|PropertyInfo[]} [props] The properties to control. All selected properties from current comp by default.
 */
DuAEF.Duik.Automation.interpolator = function (props)
{
	props = def(props, DuAEF.DuAE.Comp.getSelectedProps());
	props = DuAEF.DuAE.getPropertyInfos( props );

	if (props.length == 0) return;

	//TODO if multiple layers, create a controller

	//add the effect
	var ctrlLayer = DuAEF.DuAE.Property.getLayer(props[0]);
	var pE = DuAEF.Duik.PseudoEffects.INTERPOLATOR;
	var effect = pE.apply( ctrlLayer );
	effect(1).expression = [ DuAEF.Duik.expressionIds.INTERPOLATOR,
		'var fx = thisProperty.propertyGroup(' + pE.index['Interpolation (frames)_Slider'] + ');',
		'var interpolationType = fx(' + pE.index['Interpolation Type_Popup'] + ').value;',
		'var bezierIn = fx(' + pE.index['Bézier_In_Slider'] + ').value;',
		'var bezierOut = fx(' + pE.index['Bézier_Out_Slider'] + ').value;',
		'var gaussianRate = fx(' + pE.index['Gaussian_Rate_Slider'] + ').value;',
		'var xSheetMode = fx(' + pE.index['X-Sheet_Mode_Popup'] + ').value;',
		'var xSheetFrameDuration = fx(' + pE.index['X-Sheet_Frame Duration_Slider'] + ').value;',
		'var xSheet = fx(' + pE.index['X-Sheet_X-Sheet_Checkbox'] + ');',
		'',
		DuAEF.DuExpression.get(['bezierInterpolation', 'gaussianInterpolation', 'getNextKey', 'getPrevKey']),
		'var duTime = time;',
		'',
		'function posterizeDuTime()',
		'{',
		'	function getTimeAtKey(prop)',
		'	{',
		'		if (prop.numKeys > 0)',
		'		{',
		'			var k = prop.nearestKey(time);',
		'			if (k.time > time && k.index > 1) k = prop.key(k.index-1);',
		'			return k.time;',
		'		}',
		'		else return time;',
		'	}',
		'',
		'	if (xSheetMode == 1 && xSheetFrameDuration != 1)',
		'	{',
		'		xSheetFrameDuration = Math.round(xSheetFrameDuration);',
		'		timef = timeToFrames(time);',
		'		duTime = framesToTime( timef - timef%xSheetFrameDuration );',
		'	}',
		'	else if (xSheetMode == 2) duTime = getTimeAtKey(xSheetVal);',
		'	else if (xSheetMode == 3) duTime = getTimeAtKey(thisLayer.marker);',
		'	else duTime = getTimeAtKey(thisComp.marker);',
		'}',
		'',
		'function interpolator()',
		'{',
		'	if (numKeys < 2) return value;',
		'	if (duTime <= key(1).time) return value;',
		'	if (duTime >= key(numKeys).time) return value;',
		'	if (interpolationType == 1) return value;',
		'	var startKey = getPrevKey();',
		'	var endKey = getNextKey();',
		'	if (interpolationType == 2)',
		'	{',
		'		return bezierInterpolation( duTime, startKey.time, endKey.time, startKey.value, endKey.value, [bezierOut/100, 0, (100-bezierIn)/100, 1]);',
		'	}',
		'	if (interpolationType == 3)',
		'	{',
		'		return gaussianInterpolation( duTime, startKey.time, endKey.time, startKey.value, endKey.value, gaussianRate);',
		'	}',
		'}',
		'',
		'posterizeDuTime();',
		'var result = interpolator();',
		'result;',
		].join('\n');

	var interpolatorKeys = [];
	var interpolatorTimes = [];

	new DuList(props).do(function (prop)
	{
		if (prop.riggable)
		{
			var p = prop.getProperty();
			for (var i = 1, n = p.numKeys; i <= n; i++)
			{
				interpolatorKeys.push( Math.round( p.keyTime(i)/ctrlLayer.containingComp.frameDuration ));
				interpolatorTimes.push(p.keyTime(i));
			}
			p.expression = [ DuAEF.Duik.expressionIds.INTERPOLATOR,
				'var fx = thisComp.layer("' + ctrlLayer.name + '").effect("' + effect.name + '");',
				'var result = valueAtTime(framesToTime( fx(1) ) );',
				'result;'
			].join('\n');
		}
	});

	effect(1).setValuesAtTimes(interpolatorTimes, interpolatorKeys);
}

/**
	* Adds a list on a property
	* @memberof DuAEF.Duik.Automation
	* @param {PropertyInfo|Property} prop - The Property
*/
DuAEF.Duik.Automation.list = function (prop)
{
	if (typeof prop === 'undefined') throw "Missing Param 1: list needs a Property";
	if (!(prop instanceof PropertyInfo)) prop = new PropertyInfo(prop);
	if (!prop.riggable) return;

	var dim = prop.dimensions;

	var layer = prop.layer;
	var comp = layer.containingComp;

	var effect = null;
	var name = prop.getProperty().name + ' List';
	if (dim == 1) effect = DuAEF.Duik.PseudoEffects.ONED_LIST.apply(layer, name);
	else if (dim == 2) effect = DuAEF.Duik.PseudoEffects.TWOD_LIST.apply(layer, name);
	else if (dim == 3) effect = DuAEF.Duik.PseudoEffects.THREED_LIST.apply(layer, name);
	else return;

	//set animation with expression
	var anim = DuAEF.DuAE.Property.getAnim(prop,false);
	if (anim) DuAEF.DuAE.Property.setAnim(effect(2),anim,0,true,true,false);
	DuAEF.DuAE.Property.removeAnim(prop);

	prop.getProperty().expression =  "//Duik.list\r\n" +
					"var fx = effect(\"" + effect.name + "\");\n" +
					"var v1 = fx(2);\n" +
					"var w1 = fx(3);\n" +
					"var v2 = fx(6);\n" +
					"var w2 = fx(7);\n" +
					"var v3 = fx(10);\n" +
					"var w3 = fx(11);\n" +
					"var v4 = fx(14);\n" +
					"var w4 = fx(15);\n" +
					"var v5 = fx(18);\n" +
					"var w5 = fx(19);\n" +
					"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
}

/**
 * Adds a wiggle to a property
 * @memberof DuAEF.Duik.Automation
 * @param {PropertyInfo}	prop 				- The property.
 * @param {boolean}		[separateDimensions] 	- Set to true to separate the dimensions (to adjust amplitude and frequency) if the property is multi-dimensionnal.
 * @param {PropertyGroup|null}	[effect]	- A wiggle effect already created by Duik to use as a controller for this wiggle
 * @return {PropertyGroup} The effect created (or provided)
 */
DuAEF.Duik.Automation.wiggle = function (prop,separateDimensions,effect)
{
	if (separateDimensions == undefined) separateDimensions = false;
	if (effect == undefined) effect = null;
	if (!prop) return effect;
	if (!prop.riggable) return effect;

	//dimensions
	var dimensions = prop.dimensions;
	var layer = prop.layer;
	var comp = layer.containingComp;

	if (effect == null)
	{
		layer.selected = true;
		if (!separateDimensions && dimensions > 1) effect = DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.apply(layer);
		else if (dimensions == 3) effect = DuAEF.Duik.PseudoEffects.THREED_WIGGLE.apply(layer);
		else if (dimensions == 2) effect = DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.apply(layer);
		else effect = DuAEF.Duik.PseudoEffects.ONED_WIGGLE.apply(layer);
		layer.selected = false;

		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Wiggle',layer);
	}

	var compEffect = DuAEF.DuAE.Property.getComp(effect);
	var sameComp = compEffect.name == comp.name;

	//set default values
	if (effect.matchName == DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.matchName)
	{
		effect(DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.loopSlider).setValue(comp.duration);
		effect(DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.randomSeedSlider).setValue(layer.index);
	}
	else if (effect.matchName == DuAEF.Duik.PseudoEffects.THREED_WIGGLE.matchName)
	{
		effect(DuAEF.Duik.PseudoEffects.THREED_WIGGLE.loopSlider).setValue(comp.duration);
		effect(DuAEF.Duik.PseudoEffects.THREED_WIGGLE.randomSeedSlider).setValue(layer.index);
	}
	else if (effect.matchName == DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.matchName)
	{
		effect(DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.loopSlider).setValue(comp.duration);
		effect(DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.randomSeedSlider).setValue(layer.index);
	}
	else if (effect.matchName == DuAEF.Duik.PseudoEffects.ONED_WIGGLE.matchName)
	{
		effect(DuAEF.Duik.PseudoEffects.ONED_WIGGLE.loopSlider).setValue(comp.duration);
		effect(DuAEF.Duik.PseudoEffects.ONED_WIGGLE.randomSeedSlider).setValue(layer.index);
	}

	//TODO Wiggle for other types of properties
	var effectLink = "var fx = " + DuAEF.DuAE.Property.getExpressionLink(effect,sameComp);

	if (!separateDimensions && dimensions > 1)
	{
		prop.getProperty().expression = '//Duik.1DMultiWiggle\n' + effectLink + '\n' +
				'var freq = fx(' + DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.frequencySlider + ');\n' +
				'var amp = fx(' + DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.amplitudeSlider + ');\n' +
				'var linked = fx(' + DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.linkDimensionsCheckbox + ').value;\n' +
				'var loop = fx(' + DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.loopSlider + ');\n' +
				'var complexity = fx(' + DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.complexitySlider + ');\n' +
				'var multiplier = fx(' + DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.multiplierSlider + ');\n' +
				'var seed = fx(' + DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE.randomSeedSlider + ');\n' +
				'seedRandom(seed);\n' +
				'if (loop == 0) loop = thisComp.duration;\n' +
				'var t = (time % loop)-loop;\n' +
				'var w1 = wiggle(freq,amp, complexity, multiplier, t);\n' +
				'var w2 = wiggle(freq,amp, complexity, multiplier, t - loop);\n' +
				'var w = ease(t, -loop,  0, w1, w2);\n' +
				'var result = [];\n' +
				'if(linked) while (result.length < value.length) result.push(w[0]);\n' +
				'else result = w;\n' +
				'result + value - valueAtTime(0);';
	}
	else if (dimensions == 3)
	{
		prop.getProperty().expression = '//Duik.3DWiggle\n' + effectLink + '\n' +
				'var Xfreq = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.xFrequencySlider + ');\n' +
				'var Yfreq = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.yFrequencySlider + ');\n' +
				'var Zfreq = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.zFrequencySlider + ');\n' +
				'var Xamp = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.xAmplitudeSlider + ');\n' +
				'var Yamp = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.yAmplitudeSlider + ');\n' +
				'var Zamp = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.zAmplitudeSlider + ');\n' +
				'var loop = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.loopSlider + ');\n' +
				'var complexity = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.complexitySlider + ');\n' +
				'var multiplier = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.multiplierSlider + ');\n' +
				'var seed = fx(' + DuAEF.Duik.PseudoEffects.THREED_WIGGLE.randomSeedSlider + ');\n' +
				'seedRandom(seed);\n' +
				'if (loop == 0) loop = thisComp.duration;\n' +
				'var t = (time % loop)-loop;\n' +
				'var X1 = wiggle(Xfreq,Xamp, complexity, multiplier, t);\n' +
				'var Y1 = wiggle(Yfreq,Yamp, complexity, multiplier, t);\n' +
				'var Z1 = wiggle(Zfreq,Zamp, complexity, multiplier, t);\n' +
				'var w1 = [X1[0],Y1[1],Z1[2]];\n' +
				'var Y2 = wiggle(Yfreq,Yamp, complexity, multiplier, t - loop);\n' +
				'var X2 = wiggle(Xfreq,Xamp, complexity, multiplier, t - loop);\n' +
				'var Z2 = wiggle(Zfreq,Zamp, complexity, multiplier, t - loop);\n' +
				'var w2 = [X2[0],Y2[1],Z2[2]];\n' +
				'var w = ease(t, -loop,  0, w1, w2);\n' +
				'w + value - valueAtTime(0)';
	}
	else if (dimensions == 2)
	{
	 	prop.getProperty().expression = '//Duik.2DWiggle\n' + effectLink + '\n' +
				'var Xfreq = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.xFrequencySlider + ');\n' +
				'var Yfreq = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.yFrequencySlider + ');\n' +
				'var Xamp = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.xAmplitudeSlider + ');\n' +
				'var Yamp = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.yAmplitudeSlider + ');\n' +
				'var loop = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.loopSlider + ');\n' +
				'var complexity = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.complexitySlider + ');\n' +
				'var multiplier = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.multiplierSlider + ');\n' +
				'var seed = fx(' + DuAEF.Duik.PseudoEffects.TWOD_WIGGLE.randomSeedSlider + ');\n' +
				'seedRandom(seed);\n' +
				'if (loop == 0) loop = thisComp.duration;\n' +
				'var t = (time % loop)-loop;\n' +
				'var X1 = wiggle(Xfreq,Xamp, complexity, multiplier, t);\n' +
				'var Y1 = wiggle(Yfreq,Yamp, complexity, multiplier, t);\n' +
				'var w1 = [X1[0],Y1[1]];\n' +
				'var X2 = wiggle(Xfreq,Xamp, complexity, multiplier, t - loop);\n' +
				'var Y2 = wiggle(Yfreq,Yamp, complexity, multiplier, t - loop);\n' +
				'var w2 = [X2[0],Y2[1]];\n' +
				'var w = ease(t, -loop,  0, w1, w2);\n' +
				'w + value - valueAtTime(0)';
	}
	else if (dimensions == 1)
	{
		prop.getProperty().expression = '//Duik.1DWiggle\n' + effectLink + '\n' +
				'var freq = fx(' + DuAEF.Duik.PseudoEffects.ONED_WIGGLE.frequencySlider + ');\n' +
				'var amp = fx(' + DuAEF.Duik.PseudoEffects.ONED_WIGGLE.amplitudeSlider + ');\n' +
				'var loop = fx(' + DuAEF.Duik.PseudoEffects.ONED_WIGGLE.loopSlider + ');\n' +
				'var complexity = fx(' + DuAEF.Duik.PseudoEffects.ONED_WIGGLE.complexitySlider + ');\n' +
				'var multiplier = fx(' + DuAEF.Duik.PseudoEffects.ONED_WIGGLE.multiplierSlider + ');\n' +
				'var seed = fx(' + DuAEF.Duik.PseudoEffects.ONED_WIGGLE.randomSeedSlider + ');\n' +
				'seedRandom(seed);\n' +
				'if (loop == 0) loop = thisComp.duration;\n' +
				'var t = (time % loop)-loop;\n' +
				'var w1 = wiggle(freq,amp, complexity, multiplier, t);\n' +
				'var w2 = wiggle(freq,amp, complexity, multiplier, t - loop);\n' +
				'var w = ease(t, -loop,  0, w1, w2);\n' +
				'w + value - valueAtTime(0)';
	}

	return effect;
}

/**
 * Adds a swing to a property
 * @memberof DuAEF.Duik.Automation
 * @param {PropertyInfo}	prop 				- The property.
 */
DuAEF.Duik.Automation.swing = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	var dimensions = prop.dimensions;
	var layer = prop.layer;

	if (dimensions < 1 || dimensions > 3) return;

	layer.selected = true;
	if (prop.getProperty().isSpatial) layer.applyPreset(DuAEF.Duik.PseudoEffects.SPATIAL_SWING);
	else if (dimensions == 1) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_SWING);
	else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.PseudoEffects.TWOD_SWING);
	else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.PseudoEffects.THREED_SWING);
	layer.selected = false;
	var effect = layer.effect("Swing");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Swing',layer);



	if (prop.getProperty().isSpatial)
	{
		prop.getProperty().expression = 	'//Duik.spatialSwing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = Math.abs(fx(4));\n' +
					'var angle = fx(5)/180*Math.PI;\n' +
					'var result = [0,0];\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'sin = sin*amp;\n' +
					'result = [0,sin];\n' +
					'var x = -sin*Math.sin(angle);\n' +
					'var y = sin*Math.cos(angle);\n' +
					'result = [ x,y ] ;\n' +
					'}\n' +
					'result + value;\n';
	}
	else if (dimensions == 1)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'result + value;';
	}
	else if (dimensions == 2)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var axis = fx(5);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'if (axis == 1) result = [result,result];\n' +
					'else if (axis == 2) result =[result,0];\n' +
					'else if (axis == 3) result =[0,result];\n' +
					'result+value;';
	}
	else if (dimensions == 3)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var axis = fx(5);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'if (axis == 1) result = [result,result,result];\n' +
					'else if (axis == 2) result =[result,0,0];\n' +
					'else if (axis == 3) result =[0,result,0];\n' +
					'else if (axis == 4) result =[0,0,result];\n' +
					'result+value;';
	}
}

/**
 * Automates the rotation of a layer as a wheel
 * @memberof DuAEF.Duik.Automation
 * @param {Layer}	layer - The layer.
 * @param {int}	[radius] - The radius of the wheel, in pixels. Will be auto-detected if possible
 */
DuAEF.Duik.Automation.wheel = function (layer,radius)
{
	if (typeof layer === 'undefined') throw "Missing Param 1: Wheel needs a Layer";
	if (typeof radius === 'undefined')
	{
		var parent = layer.parent;
		layer.parent = null;
		var rect = layer.sourceRectAtTime(0,false);
		radius = rect.width/2*layer.transform.scale.value[0]/100;
		radius = Math.abs(radius);
		layer.parent = parent;
	}
	var rotation = layer.transform.rotation;
	if (layer.threeDLayer) rotation = layer.transform.zRotation;

	var effect = DuAEF.Duik.PseudoEffects.WHEEL.apply(layer);

	effect(DuAEF.Duik.PseudoEffects.WHEEL.index['Radius_Slider']).setValue(radius);

	rotation.expression = ['//Duik.Wheel',
		'var fx = thisLayer.effect("' + effect.name + '");',
		'var R = fx(' + DuAEF.Duik.PseudoEffects.WHEEL.index['Radius_Slider'] + ').value;',
		'var Rev = fx(' + DuAEF.Duik.PseudoEffects.WHEEL.index['Reverse_Checkbox'] + ');',
		'var curved = fx(' + DuAEF.Duik.PseudoEffects.WHEEL.index['Trajectory_Popup'] + ') == 2;',
		'var moBlurPrecision = fx(' + DuAEF.Duik.PseudoEffects.WHEEL.index['Motion Blur Precision_Slider'] + ');',
		'',
		'function pos(t) {',
		'    return thisLayer.toWorld(thisLayer.anchorPoint, t);',
		'}',
		'var result = 0;',
		'if (R > 0) {',
		'    var distance = 0;',
		'    if (curved) {',
		'        var start = thisLayer.inPoint > thisComp.displayStartTime ? thisLayer.inPoint : thisComp.displayStartTime;',
		'        var end = time < thisLayer.outPoint ? time : thisLayer.outPoint;',
		'        var step = framesToTime(1)/moBlurPrecision;',
		'        var cT = start;',
		'        while (cT <= end)',
		'        {',
		'            if (pos(cT+step)[0] - pos(step)[0] > 0) distance += length(pos(cT+step), pos(cT));',
		'            else distance -= length(pos(cT+step), pos(cT));',
		'            cT += step;',
		'        }',
		'    } else {',
		'        distance = pos(time)[0];',
		'    }',
		'    result = radiansToDegrees(distance / R);',
		'}',
		'Rev == 1 ? value - result : value + result;'
		].join('\n');

}

/**
	* Creates the effector controller layer
	* @param {CompItem} [comp=DuAEF.DuAE.Project.getActiveComp] - The composition where to create the controller
	* @return {ShapeLayer} The controller
	*/
DuAEF.Duik.Automation.createEffectorController = function (comp)
{
		comp = def(comp, DuAEF.DuAE.Project.getActiveComp());
		if(!comp) throw "Bad Argument: DuAEF.Duik.Automation.createEffectorController needs a composition";

		var ctrlLayer = comp.layers.addShape();
		DuAEF.Duik.setDuikMarker(ctrlLayer,"Effector",DuAEF.Duik.LayerTypes.EFFECTOR);
		ctrlLayer.name = DuAEF.DuAE.Comp.newUniqueLayerName("Effector",comp);
		//effect
		ctrlLayer.selected = true;
		var ef = DuAEF.Duik.PseudoEffects.EFFECTOR.apply(ctrlLayer);
		//content
		var centerGroup = ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		centerGroup.name = "Center";
		var centerContent = centerGroup.property("ADBE Vectors Group");
		var centerCircle = centerContent.addProperty("ADBE Vector Shape - Ellipse");
		centerCircle("ADBE Vector Ellipse Size").setValue([4,4]);
		var centerFill = centerContent.addProperty("ADBE Vector Graphic - Fill");
		centerFill("ADBE Vector Fill Color").setValue(DuColor.Color.BLACK);
		centerFill("ADBE Vector Fill Opacity").setValue(50);

		var innerGroup =  ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		innerGroup.name = "Inner (Circle)";
		var innerContent = innerGroup.property("ADBE Vectors Group");
		var innerCircle = innerContent.addProperty("ADBE Vector Shape - Ellipse");
		innerCircle("ADBE Vector Ellipse Size").expression = '//Duik.effector.inner\n' +
			'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 1)\n' +
			'{\n' +
			'var inner = effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.innerLimitSlider + ')*2;\n' +
			'[inner,inner];\n' +
			'}\n' +
			'else [0,0];';
		var innerStroke = innerContent.addProperty("ADBE Vector Graphic - Stroke");
		innerStroke("ADBE Vector Stroke Color").setValue(DuColor.Color.GREEN);
		innerGroup.property('ADBE Vector Transform Group').property('ADBE Vector Group Opacity').expression = 'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 1) 100; else 0;';

		var outerGroup =  ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		outerGroup.name = "Outer (Circle)";
		var outerContent = outerGroup.property("ADBE Vectors Group");
		var outerCircle = outerContent.addProperty("ADBE Vector Shape - Ellipse");
		outerCircle("ADBE Vector Ellipse Size").expression = '//Duik.effector.outer\n' +
			'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 1)\n' +
			'{\n' +
			'var inner = effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.outerLimitSlider + ')*2;\n' +
			'[inner,inner];\n' +
			'}\n' +
			'else [0,0];';
		var outerStroke = outerContent.addProperty("ADBE Vector Graphic - Stroke");
		outerStroke("ADBE Vector Stroke Color").setValue(DuColor.Color.RAINBOX_RED);
		outerGroup.property('ADBE Vector Transform Group').property('ADBE Vector Group Opacity').expression = 'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 1) 100; else 0;';

		var innerGroupLinear = ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		innerGroupLinear.name = "Inner (Line)";
		var innerContentLinear = innerGroupLinear.property("ADBE Vectors Group");
		var innerRect = innerContentLinear.addProperty("ADBE Vector Shape - Rect");
		innerRect("ADBE Vector Rect Size").expression = '//Duik.effector.inner\n' +
			'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 2)\n' +
			'[effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.innerLimitSlider + '),thisComp.height];\n' +
			'else [0,0];';
		var innerTrim = innerContentLinear.addProperty('ADBE Vector Filter - Trim');
		innerTrim('ADBE Vector Trim Start').setValue(50);
		innerTrim('ADBE Vector Trim End').expression = 'var w = effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.innerLimitSlider + ');\n' +
			'var h = thisComp.height;\n' +
			'var l = 2*w+2*h;\n' +
			'100-w/l*100;';
		var innerStroke = innerContentLinear.addProperty("ADBE Vector Graphic - Stroke");
		innerStroke("ADBE Vector Stroke Color").setValue(DuColor.Color.GREEN);
		innerGroupLinear.property('ADBE Vector Transform Group').property('ADBE Vector Group Opacity').expression = 'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 2) 100; else 0;';

		var outerGroupLinear = ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		outerGroupLinear.name = "Inner (Line)";
		var outerContentLinear = outerGroupLinear.property("ADBE Vectors Group");
		var outerRect = outerContentLinear.addProperty("ADBE Vector Shape - Rect");
		outerRect("ADBE Vector Rect Size").expression = '//Duik.effector.inner\n' +
			'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 2)\n' +
			'[effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.innerLimitSlider + '),thisComp.height];\n' +
			'else [0,0];';
		var outerTrim = outerContentLinear.addProperty('ADBE Vector Filter - Trim');
		outerTrim('ADBE Vector Trim Start').setValue(0);
		outerTrim('ADBE Vector Trim End').expression = 'var w = effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.innerLimitSlider + ');\n' +
			'var h = thisComp.height;\n' +
			'var l = 2*w+2*h;\n' +
			'100-(h+2*w)/l*100;';
		var outerStroke = outerContentLinear.addProperty("ADBE Vector Graphic - Stroke");
		outerStroke("ADBE Vector Stroke Color").setValue(DuColor.Color.RAINBOX_RED);
		outerGroupLinear.property('ADBE Vector Transform Group').property('ADBE Vector Group Opacity').expression = 'if (effect("' + ef.name + '")(' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ').value == 2) 100; else 0;';

		//unselect
		ctrlLayer.guideLayer = true;

		return ctrlLayer;
}

/**
	* Links a property to an effector controller
	* @param {PropertyInfo} prop - The property to rig
	* @param {PropertyGroup|null} [effect] - A Layer expression control used to link to the effector. Will be created on the layer if not provided
	* @param {ShapeLayer|null} [ctrlLayer] - The effector layer. will be created if not provided
	* @return {object} A custom object with two attributes:<br />
	* - effectorLayer: the effector layer
	* - effect: the layer expression control on the rigged layer used to link to the effector
	*/
DuAEF.Duik.Automation.effector = function (prop,effect,ctrlLayer)
{
	if (effect == undefined) effect = null;
	if (ctrlLayer == undefined) ctrlLayer = null;
	if (!(prop instanceof PropertyInfo)) prop = new PropertyInfo(prop);
	var effector = {};
	effector.effectorLayer = ctrlLayer;
	effector.effect = effect;
	if (!prop) return effector;
	if (!prop.riggable) return effector;

	var layer = prop.layer;
	var comp = layer.containingComp;

	var createCtrlLayer = ctrlLayer == null;

	//create effector
	if (createCtrlLayer)
	{
		ctrlLayer = DuAEF.Duik.Automation.createEffectorController(comp);
		//unselect
		ctrlLayer.selected = false;
		//set Defaults
		var distance = DuAEF.DuAE.Layer.getDistance(layer,ctrlLayer);
		ctrlLayer.effect( DuAEF.Duik.PseudoEffects.EFFECTOR.matchName )( DuAEF.Duik.PseudoEffects.EFFECTOR.innerLimitSlider ).setValue(distance/4);
		ctrlLayer.effect( DuAEF.Duik.PseudoEffects.EFFECTOR.matchName )( DuAEF.Duik.PseudoEffects.EFFECTOR.outerLimitSlider ).setValue(distance*3/4);
	}

	var effectorEffect = ctrlLayer.effect( DuAEF.Duik.PseudoEffects.EFFECTOR.matchName );

	var ctrlComp = ctrlLayer.containingComp;

	//create effect
	if (effect == null && comp.id == ctrlComp.id)
	{
		effect = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Effector',layer);
	}

	//Set effect
	if (effect) effect(1).setValue(ctrlLayer.index);

	//set expression
	var ctrlLink = '';
	if ( comp.id != ctrlComp.id ) ctrlLink = DuAEF.DuAE.Property.getExpressionLink(ctrlLayer);
	else ctrlLink = 'effect( "' + effect.name + '" )( 1 )';
	var expression = ['//Duik.effector',
		'var fx = null;',
		'var result = value;',
		'',
		'try',
		'{',
		'    var ctrl = ' + ctrlLink  + ';',
		'    fx = ctrl.effect( "' + effectorEffect.name + '" );',
		'}',
		'catch ( e )',
		'{}',
		'',
		DuAEF.DuExpression.get(['getScale']),
		'',
		'// Get layer world position',
		'function p ( l )',
		'{',
		'    return l.toWorld( l.anchorPoint )',
		'}',
		'',
		'function effector ()',
		'{',
		'    var min = fx( ' + DuAEF.Duik.PseudoEffects.EFFECTOR.innerLimitSlider + ' ).value;',
		'    var max = fx( ' + DuAEF.Duik.PseudoEffects.EFFECTOR.outerLimitSlider + ' ).value;',
		'    var mode = fx( ' + DuAEF.Duik.PseudoEffects.EFFECTOR.modePopup + ' ).value;',
		'    var type = fx( ' + DuAEF.Duik.PseudoEffects.EFFECTOR.typePopup + ' ).value;',
		'    var reverse = fx( ' + DuAEF.Duik.PseudoEffects.EFFECTOR.reverseCheckbox + ' ).value;',
		'',
		'    if ( mode == 2 ) //line',
		'    {',
		'        max = min;',
		'        min = 0;',
		'        reverse = !reverse;',
		'    }',
		'',
		' 	// Get scale values',
		'	min = min * (getScale(ctrl)[0] / 100);',
		'	max = max * (getScale(ctrl)[0] / 100);',
		'',
		'   var distance = effectorDistance( max, mode );',
		'',
		'   return effectorValue( distance, min, max, type, reverse );',
		'}',
		'',
		'function effectorDistance ( max, mode )',
		'{',
		'    var distance = 0;',
		'',
		'    var worldPos = p( thisLayer );',
		'',
		'    if ( mode == 1 ) //circle',
		'    {',
		'        distance = length( worldPos, p( ctrl ) );',
		'    }',
		'    else if ( mode == 2 ) //line',
		'    {',
		'        var coords = ctrl.fromWorld( worldPos );',
		'        distance = -coords[ 0 ] + max / 2;',
		'    }',
		'',
		'    return distance;',
		'}',
		'',
		'function effectorValue ( distance, min, max, type, reverse )',
		'{',
		'    var t = 0;',
		'    var beginTime = key( 1 ).time;',
		'    var endTime = key( numKeys ).time;',
		'',
		'    if ( type == 1 )',
		'    {',
		'        if ( !reverse ) t = linear( distance, min, max, endTime, beginTime );',
		'        else t = linear( distance, min, max, beginTime, endTime );',
		'    }',
		'    else',
		'    {',
		'        var mid = ( min + max ) / 2;',
		'        if ( !reverse )',
		'        {',
		'            if ( distance > mid ) t = linear( distance, mid, max, endTime, beginTime );',
		'            else t = linear( distance, min, mid, beginTime, endTime );',
		'        }',
		'        else',
		'        {',
		'            if ( distance > mid ) t = linear( distance, mid, max, beginTime, endTime );',
		'            else t = linear( distance, min, mid, endTime, beginTime );',
		'        }',
		'    }',
		'    return valueAtTime( t );',
		'}',
		'',
		'result = ( fx && numKeys >= 2 ) ? effector() : result;',
		''
		].join('\n');

	prop.getProperty().expression = expression;

	effector.effectorLayer = ctrlLayer;
	effector.effect = effect;

	return effector;
}

/**
	* Links a property to a texture layer
	* @param {PropertyInfo} prop - The property to rig
	* @param {AVLayer} texture - The texture layer.
	* @param {PropertyGroup|null} [effect] - A Layer expression control used to link to the effector. Will be created on the layer if not provided
	* @return {PropertyGroup} The layer expression control added on the layer.
	*/
DuAEF.Duik.Automation.mapEffector = function (prop,texture,effect)
{
	effect = def(effect, null);

	if (!(prop instanceof PropertyInfo)) prop = new PropertyInfo(prop);
	if (!prop) return effect;
	if (!prop.riggable) return effect;

	var layer = prop.layer;
	var comp = layer.containingComp;
	var textureComp = texture.containingComp;

	//create effect
	if (effect == null && comp.id == textureComp.id)
	{
		effect = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Effector',layer);
		layer.name = DuAEF.DuAE.Comp.newUniqueLayerName(layer.name, comp);
	}

	//Set effect
	if (effect) effect(1).setValue(texture.index);

	//Add texture effect 
	var textureEffect = texture.effect(DuAEF.Duik.PseudoEffects.MAP_EFFECTOR.matchName);
	if (!textureEffect)
	{
		textureEffect = DuAEF.Duik.PseudoEffects.MAP_EFFECTOR.apply(texture);
	}

	//set expression
	var textureLink = '';
	if ( comp.id != textureComp.id ) textureLink = DuAEF.DuAE.Property.getExpressionLink(texture);
	else
	{
		var effectLayer = DuAEF.DuAE.Property.getLayer(effect);
		if (effectLayer.index != layer.index) textureLink = 'thisComp.layer("' + effectLayer.name + '").'
		textureLink += 'effect( "' + effect.name + '" )( 1 )';
	}
	
	var expression = ['//Duik.mapEffector',
		'var fx = null;',
		'var ctrl = null;',
		'var result = value;',
		'',
		'try',
		'{',
		'    ctrl = ' + textureLink + ';',
		'    fx = ctrl.effect( "' + textureEffect.name + '" );',
		'}',
		'catch ( e )',
		'{}',
		'',
		'// Get layer world position',
		'function p ( l )',
		'{',
		'    return l.toWorld( l.anchorPoint )',
		'}',
		'',
		'function effector ()',
		'{',
		'    var min = fx( ' + DuAEF.Duik.PseudoEffects.MAP_EFFECTOR.index['Minimum_Slider'] + ' ).value;',
		'    var max = fx( ' + DuAEF.Duik.PseudoEffects.MAP_EFFECTOR.index['Maximum_Slider'] + ' ).value;',
		'    var reverse = fx( ' + DuAEF.Duik.PseudoEffects.MAP_EFFECTOR.index['Reverse_Checkbox'] + ' ).value;',
		'    var channel = fx( ' + DuAEF.Duik.PseudoEffects.MAP_EFFECTOR.index['Channel_Popup'] + ' ).value;',
		'',
		'    min = min / 100;',
		'    max = max / 100;',
		'',
		'    var distance = effectorDistance( channel );',
		'    return effectorValue( distance, min, max, reverse );',
		'',
		'}',
		'',
		'function effectorDistance ( channel )',
		'{',
		'    var distance = 0;',
		'',
		'    var worldPos = p( thisLayer );',
		'',
		'    if ( typeof channel === "undefined" ) channel = 5;',
		'    var colorPoint = ctrl.fromWorld( worldPos );',
		'    var color = ctrl.sampleImage( colorPoint );',
		'    if ( channel <= 3 ) distance = color[ channel-1 ];',
		'	else if (channel <= 6)',
		'	{',
		'		color = rgbToHsl(color);',
		'		distance = color[ channel - 4 ];',
		'	}',
		'    else distance = color[ 3 ];',
		'',
		'    return distance;',
		'}',
		'',
		'function effectorValue ( distance, min, max, reverse )',
		'{',
		'    var t = 0;',
		'    var beginTime = key( 1 ).time;',
		'    var endTime = key( numKeys ).time;',
		'',
		'    if ( !reverse ) t = linear( distance, min, max, beginTime, endTime );',
		'    else t = linear( distance, min, max, endTime, beginTime );',
		'',
		'    return valueAtTime( t );',
		'}',
		'',
		'result = ( fx && numKeys >= 2 ) ? effector() : result;',
		''
		].join('\n');

	prop.getProperty().expression = expression;

	return effect;
}

/**
 * Adds a spring effect on the property
 * @deprecated since Duik 16.2. Use DuAEF.Duik.Animation.kleaner instead, which includes an auto follow-through.
 * @param {PropertyInfo} prop - The property to rig
*/
DuAEF.Duik.Automation.spring = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	//search for one dimension effects, to know if we need a "bounce" checkbox
	var bounce = false;
	if (prop.dimensions == 1) bounce = true;

	//check if it's spatial
	var spatial = prop.getProperty().isSpatial;
	var layer = prop.layer;

	var effect = null;

	layer.selected = true;
	if (bounce) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_SPRING);
	else if (spatial) layer.applyPreset(DuAEF.Duik.PseudoEffects.SPATIAL_SPRING);
	else layer.applyPreset(DuAEF.Duik.PseudoEffects.MULTID_SPRING);
	layer.selected = false;
	effect = layer.effect("Spring");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().parentProperty.name + ' Spring',layer);

	if (bounce)
	{
		prop.getProperty().expression = '//Duik.Spring\n' +
			'var fx = effect("' + effect.name + '")\n' +
			'damping = fx(2).value;\n' +
			'elasticity = fx(1).value;\n' +
			'speedLimit = 0.1;\n' +
			'bounce = fx(3).value;\n' +
			'var result = value;\n' +
			'if (numKeys > 1 && elasticity != 0 && nearestKey(time).index != 1 && length(velocity) <= speedLimit)\n' +
			'{\n' +
			'    tempsClefProx = nearestKey(time).time;\n' +
			'    if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n' +
			'    else { tempsDebut = key(nearestKey(time).index-1).time }\n' +
			'    temps = time - tempsDebut;\n' +
			'    spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n' +
			'    if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n' +
			'    if (!bounce) result = valueAtTime(tempsDebut) + spring;\n' +
			'    if (bounce &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) result = valueAtTime(tempsDebut) + Math.abs(spring);\n' +
			'    if (bounce &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) result = valueAtTime(tempsDebut) - Math.abs(spring);\n' +
			'}\n' +
			'result;';
	}
	else if (spatial)
	{
		var toWorldFunc = '';
		if (prop.getProperty().matchName == 'ADBE Position')
		{
			toWorldFunc = "function worldVelocity(temps) {\n" +
			"worldVelocityX = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[0]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[0])*100;\n" +
			"worldVelocityY = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[1]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[1])*100;\n" +
			"return [worldVelocityX,worldVelocityY];\n" +
			"}\n";
		}
		else
		{
			toWorldFunc = "function worldVelocity(temps) {\n" +
			"worldVelocityX = (thisLayer.toWorld(value,temps)[0]-thisLayer.toWorld(value,temps-.01)[0])*100;\n" +
			"worldVelocityY = (thisLayer.toWorld(value,temps)[1]-thisLayer.toWorld(value,temps-.01)[1])*100;\n" +
			"return [worldVelocityX,worldVelocityY];\n" +
			"}\n";
		}
		prop.getProperty().expression = '//Duik.spring\n' +
			'var fx = effect("' + effect.name + '")\n' +
			'damping = fx(2).value;\n' +
			'elasticity = fx(1).value;\n' +
			'simulation = fx(3).value;\n' +
			'speedLimit = 0.1;\n' +
			'if (damping == 0) damping = 0.01;\n' +
			'if (elasticity == 0) elasticity = 0.01;\n' +
			'retard = elasticity/damping;\n' +
			'poids = 1/damping/10;\n' +
			'precision = thisComp.frameDuration;\n' +
			'var result = value;\n' +
			toWorldFunc +
			'function worldSpeed(temps) {\n' +
			'    return length(worldVelocity(temps));\n' +
			'}\n' +
			'if (simulation == 2)\n' +
			'{\n' +
			'    tempsDebut = 0;\n' +
			'    tempsRedemarrage = 0;\n' +
			'    stop = false;\n' +
			'    arrete = false;\n' +
			'    for (i=timeToFrames(time);i>=0;i--) {\n' +
			'        var instant = framesToTime(i);\n' +
			'        var instantSuivant = instant-precision;\n' +
			'        if (worldSpeed(instant) == 0 ) {\n' +
			'        if (tempsRedemarrage == 0) tempsRedemarrage = instant;\n' +
			'        if (worldSpeed(instantSuivant) !=0 ) {\n' +
			'        tempsDebut = instantSuivant;\n' +
			'        break;\n' +
			'        }\n' +
			'        }\n' +
			'    }\n' +
			'    temps = time-tempsDebut;\n' +
			'    frameRedemarre = timeToFrames( time-tempsRedemarrage);\n' +
			'    valeur = value\n' +
			'    if ( frameRedemarre <= retard) result = value - worldVelocity(time)*poids*(frameRedemarre/retard);\n' +
			'    else result = value - worldVelocity(time)*poids;\n' +
			'    if (worldSpeed(time) == 0) {\n' +
			'    result += worldVelocity(tempsDebut) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n' +
			'    }\n' +
			'}\n' +
			'else if (numKeys > 1 && elasticity != 0 && nearestKey(time).index != 1 && length(velocity) <= speedLimit)\n' +
			'{\n' +
			'    tempsClefProx = nearestKey(time).time;\n' +
			'    if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n' +
			'    else { tempsDebut = key(nearestKey(time).index-1).time }\n' +
			'    temps = time - tempsDebut;\n' +
			'    spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n' +
			'    if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n' +
			'    result = valueAtTime(tempsDebut) + spring;\n' +
			'}\n' +
			'result;';

	}
	else
	{
		prop.getProperty().expression = "//Duik.Spring\r\n" +
					'var fx = effect("' + effect.name + '")\n' +
					"damping = fx(2).value;\n" +
					"elasticity = fx(1).value;\n" +
					"speedLimit = 0.1;\n" +
					"if (numKeys > 1 && elasticity != 0 ){\n" +
					"if (nearestKey(time).index == 1) { value }\n" +
					"else {\n\n" +
					"if (length(velocity) <= speedLimit ) {\n\n" +
					"tempsClefProx = nearestKey(time).time;\n\n" +
					"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
					"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
					"temps = time - tempsDebut;\n\n" +
					"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
					"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
					"valueAtTime(tempsDebut) + spring;\n\n" +
					"}\n" +
					"else { value }\n" +
					"}\n" +
					"}\n" +
					"else { value }";
	}
}

/**
	* Adds a blink effect on the property
	* @param {PropertyInfo} prop - The property to rig
*/
DuAEF.Duik.Automation.blink = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	var dimensions = prop.dimensions;
	var layer = prop.layer;

	layer.selected = true;
	if (dimensions == 1) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_BLINK);
	else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.PseudoEffects.TWOD_BLINK);
	else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.PseudoEffects.THREED_BLINK);
	else if (dimensions == 4) layer.applyPreset(DuAEF.Duik.PseudoEffects.COLOR_BLINK);
	layer.selected = false;

	var effect = layer.effect('Blink');
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Blink',layer);
	DuAEF.DuAE.Property.setValue(effect(1),prop.getProperty().value);

	prop.getProperty().expression = [DuAEF.Duik.expressionIds.BLINK,
		'var fx = effect("' + effect.name + '")\n' +
		"var phase = fx(3).value;",
		"var timeOn = fx(4).value;",
		"var offset = fx(5).value;",
		"var valueA = fx(1).value;",
		"var valueB = fx(2).value;",
		'var result = value;',
		'if (phase > 0) {',
		'	freq= timeToFrames(1)/phase;',
		'	var currentFrame = timeToFrames(time+offset/phase/100);',
		'	if (currentFrame%freq > freq*timeOn/100) result = valueB;',
		'	else result = valueA;',
		'}',
		'else {',
		'	result = valueA;',
		'}',
		'result;'
		].join('\n');
}

/**
	* Adds a move away effect on the layer
	* @param {Layer} layer - The layer to rig
*/
DuAEF.Duik.Automation.moveAway = function (layer)
{
	if (typeof layer === 'undefined') return;
	var effect = layer.Effects.addProperty("ADBE Slider Control");
	effect.name =  DuAEF.DuAE.Layer.newUniqueEffectName('Move away from parent',layer);

	layer.transform.position.expression = ['//Duik.moveAway',
		'var result = value;',
		'if (thisLayer.hasParent && value[0] != 0 && value[1] != 0)',
		'{',
		'	thisWorldPos = thisLayer.toWorld(thisLayer.anchorPoint);',
		'	parentWorldPos = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);',
		'	depl = effect("' + effect.name + '")(1)',
		'	dist = length(parentWorldPos ,thisWorldPos )',
		'	coef = (dist+depl)/dist',
		'	newWorldPos = (thisWorldPos-parentWorldPos)*coef+parentWorldPos',
		'	result = thisLayer.parent.fromWorld(newWorldPos)',
		'}',
		'result;'
	].join('\n');
}

/**
	* Rigs the paint effects found on the layer to animate all the strokes as if there was only one
	* @param {Layer} layer - The layer to rig
*/
DuAEF.Duik.Automation.paintRig = function (layer)
{
	if (layer == undefined) return;

	//if there's no paint effect
	var paintEffect = layer("ADBE Effect Parade")("ADBE Paint");
	if (paintEffect == null) return;

	//add effect
	var newName = DuAEF.DuAE.Layer.newUniqueEffectName('Paint Rig',layer);
	layer.selected = true;
	layer.applyPreset(DuAEF.Duik.PseudoEffects.PAINT_RIG);
	layer.selected = false;
	var effect = layer.effect('Paint Rig');
	effect.name = newName;

	//need to get the paint effect again after addProperty, After Effects bug.......
	var paintEffect = layer("Effects")("ADBE Paint");

	//the first diameter and color
	var defaultDiam = 0;
	var defaultCol = [0,0,0,0];

	//for each stroke
	var nbre = paintEffect.property(2).numProperties;
	for (var j=1;j<=nbre;j++)
	{
		var stroke = paintEffect.property(2).property(j);
		var propStart = stroke.property(4).property('ADBE Paint Begin');
		var propEnd = stroke.property(4).property('ADBE Paint End');
		var propCol = stroke.property(4).property('ADBE Paint Color');
		var propDiam = stroke.property(4).property('ADBE Paint Diameter');

		if (defaultDiam == 0)
		{
			defaultDiam = propDiam.value;
			effect(13).setValue(defaultDiam);
			effect(14).setValue(defaultDiam);
		}
		if (defaultCol[3] == 0)
		{
			defaultCol = propCol.value;
			effect(9).setValue(defaultCol);
			effect(10).setValue(defaultCol);
		}

		var startExp = '//Duik.PaintRig\n' +
			'var ctrl = effect("' + effect.name + '")(1);\n' +
			'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
			'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex\n' +
			'result = ctrl - ((100/total)*(ind-1));\n' +
			'result = result * total;\n' +
			'result;';
		DuAEF.DuAE.Property.setExpression( propStart, startExp, false );

		var endExp = '//Duik.PaintRig\n' +
			'var ctrl = effect("' + effect.name + '")(2);\n' +
			'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
			'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
			'result = ctrl - ((100/total)*(ind-1));\n' +
			'result = result * total;\n' +
			'result;';
		DuAEF.DuAE.Property.setExpression( propEnd, endExp, false );

		
		var diamExp = '//Duik.PaintRig\n' +
			'var fx = effect("' + effect.name + '");\n' +
			'var ctrlA = fx(13).value;\n' +
			'var ctrlB = fx(14).value;\n' +
			'var reverse = fx(6).value;\n' +
			'var interpolation =fx(5).value;\n' +
			'var mode = fx(4).value;\n' +
			'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
			'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
			'if (reverse)\n' +
			'{\n' +
			'var t = ctrlA;\n' +
			'ctrlA = ctrlB;\n' +
			'ctrlB = t;\n' +
			'}\n' +
			'var result = ctrlA;\n' +
			'if (mode == 2)\n' +
			'{\n' +
			'if (interpolation == 1) result = linear(ind,1,total,ctrlA,ctrlB);\n' +
			'else if (interpolation == 2) result = ease(ind,1,total,ctrlA,ctrlB);\n' +
			'else if (interpolation == 3) result = easeIn(ind,1,total,ctrlA,ctrlB);\n' +
			'else if (interpolation == 4) result = easeOut(ind,1,total,ctrlA,ctrlB);\n' +
			'}\n' +
			'else if (mode == 3)\n' +
			'{\n' +
			'if (ind < total /2)\n' +
			'{\n' +
			'if (interpolation == 1) result = linear(ind,1,total/2,ctrlA,ctrlB);\n' +
			'else if (interpolation == 2) result = ease(ind,1,total/2,ctrlA,ctrlB);\n' +
			'else if (interpolation == 3) result = easeIn(ind,1,total/2,ctrlA,ctrlB);\n' +
			'else if (interpolation == 4) result = easeOut(ind,1,total/2,ctrlA,ctrlB);\n' +
			'}\n' +
			'else\n' +
			'{\n' +
			'if (interpolation == 1) result = linear(ind,total/2,total,ctrlB,ctrlA);\n' +
			'else if (interpolation == 2) result = ease(ind,total/2,total,ctrlB,ctrlA);\n' +
			'else if (interpolation == 3) result = easeIn(ind,total/2,total,ctrlB,ctrlA);\n' +
			'else if (interpolation == 4) result = easeOut(ind,total/2,total,ctrlB,ctrlA);\n' +
			'}\n' +
			'}\n' +
			'result;';
		DuAEF.DuAE.Property.setExpression( propDiam, diamExp, false );

		
		var colExp = '//Duik.PaintRig\n' +
			'var fx = effect("' + effect.name + '");\n' +
			'var ctrlA = fx(9).value;\n' +
			'var ctrlB = fx(10).value;\n' +
			'var reverse = fx(6).value;\n' +
			'var interpolation = fx(5).value;\n' +
			'var mode = fx(4).value;\n' +
			'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
			'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
			'if (reverse)\n' +
			'{\n' +
			'var t = ctrlA;\n' +
			'ctrlA = ctrlB;\n' +
			'ctrlB = t;\n' +
			'}\n' +
			'var result = ctrlA;\n' +
			'if (mode == 2)\n' +
			'{\n' +
			'if (interpolation == 1) result = linear(ind,1,total,ctrlA,ctrlB);\n' +
			'else if (interpolation == 2) result = ease(ind,1,total,ctrlA,ctrlB);\n' +
			'else if (interpolation == 3) result = easeIn(ind,1,total,ctrlA,ctrlB);\n' +
			'else if (interpolation == 4) result = easeOut(ind,1,total,ctrlA,ctrlB);\n' +
			'}\n' +
			'else if (mode == 3)\n' +
			'{\n' +
			'if (ind < total /2)\n' +
			'{\n' +
			'if (interpolation == 1) result = linear(ind,1,total/2,ctrlA,ctrlB);\n' +
			'else if (interpolation == 2) result = ease(ind,1,total/2,ctrlA,ctrlB);\n' +
			'else if (interpolation == 3) result = easeIn(ind,1,total/2,ctrlA,ctrlB);\n' +
			'else if (interpolation == 4) result = easeOut(ind,1,total/2,ctrlA,ctrlB);\n' +
			'}\n' +
			'else\n' +
			'{\n' +
			'if (interpolation == 1) result = linear(ind,total/2,total,ctrlB,ctrlA);\n' +
			'else if (interpolation == 2) result = ease(ind,total/2,total,ctrlB,ctrlA);\n' +
			'else if (interpolation == 3) result = easeIn(ind,total/2,total,ctrlB,ctrlA);\n' +
			'else if (interpolation == 4) result = easeOut(ind,total/2,total,ctrlB,ctrlA);\n' +
			'}\n' +
			'}\n' +
			'result;';
		DuAEF.DuAE.Property.setExpression( propCol, colExp , false );

	}
}

/**
	* Create a procedural walk cycle on the controllers.<br />
	* This methods automatically detects the limbs, the sides, etc.
	* @param {Controller[]|Layer[]} controllers - The controllers
	* @param {CompItem} [comp] - The comp where to add the walk cycle
*/
DuAEF.Duik.Automation.autoWalk = function(controllers,comp)
{
	var headCtrl = null;
	var neckCtrl = null;
	var bodyCtrl = null;
	var hipsCtrl = null;
	var rHandCtrl = null;
	var lHandCtrl = null;
	var rFootCtrl = null;
	var lFootCtrl = null;

	var it = new DuList(controllers);
	it.do(function(controller)
	{
		var layer = controller;
		if (controller instanceof Controller) layer = controller.layer;

		var params = DuAEF.Duik.getDuikMarkerParameters(layer);
		var type = params[DuAEF.Duik.MarkerParameters.CONTROLLER_TYPE];

		//head
		if (type == DuAEF.Duik.Controller.Types.HEAD) headCtrl = layer;
		if (type == DuAEF.Duik.Controller.Types.SHOULDERS) neckCtrl = layer;
		if (type == DuAEF.Duik.Controller.Types.BODY) bodyCtrl = layer;
		if (type == DuAEF.Duik.Controller.Types.HIPS) hipsCtrl = layer;
		if (type == DuAEF.Duik.Controller.Types.HAND)
		{
			if (DuAEF.Duik.Autorig.isRight(layer)) rHandCtrl = layer;
			else lHandCtrl = layer;
		}
		if (type == DuAEF.Duik.Controller.Types.FOOT)
		{
			if (DuAEF.Duik.Autorig.isRight(layer)) rFootCtrl = layer;
			else lFootCtrl = layer;
		}
	});

	DuAEF.Duik.Automation.walk(headCtrl,neckCtrl,bodyCtrl,hipsCtrl,rHandCtrl,lHandCtrl,rFootCtrl,lFootCtrl,comp);

}

/**
	* Loops the property
	* @param {Property|PropertyInfo}	prop - The property.
	* @param {PropertyGroup|null}	[effect]	- A looper effect already created by Duik to use as a controller for this looper
	* @param {DuAEF.DuAE.LoopTypes} [loopInType=DuAEF.DuAE.LoopTypes.CYCLE] - The type of loopIn
	* @param {DuAEF.DuAE.LoopTypes} [loopOutType=DuAEF.DuAE.LoopTypes.CYCLE] - The type of loopOut
*/
DuAEF.Duik.Automation.loop = function(prop,ctrlEffect, loopInType, loopOutType)
{
	if (typeof ctrlEffect === 'undefined') ctrlEffect = null;
	if (typeof loopInType === 'undefined') loopInType = DuAEF.DuAE.LoopTypes.CYCLE;
	if (typeof loopInType === 'undefined') loopOutType = DuAEF.DuAE.LoopTypes.CYCLE;
	if (!prop) return ctrlEffect;
	if (!(prop instanceof PropertyInfo)) prop = new PropertyInfo(prop);
	if (!prop.riggable) return ctrlEffect;

	var layer = prop.layer;

	if (!ctrlEffect)
	{
		ctrlEffect = DuAEF.Duik.PseudoEffects.LOOPER.apply(layer);
		ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.inCheckbox).setValue(1);
		ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.outCheckbox).setValue(1);
	}

	if (loopInType == DuAEF.DuAE.LoopTypes.NONE || loopInType == DuAEF.DuAE.LoopTypes.HOLD) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.inCheckbox).setValue( 0 );
	if (loopInType == DuAEF.DuAE.LoopTypes.CYCLE) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.inTypePopup).setValue( 1 );
	if (loopInType == DuAEF.DuAE.LoopTypes.OFFSET) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.inTypePopup).setValue( 2 );
	if (loopInType == DuAEF.DuAE.LoopTypes.PINPONG) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.inTypePopup).setValue( 3 );
	if (loopInType == DuAEF.DuAE.LoopTypes.CONTINUE) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.inTypePopup).setValue( 4 );

	if (loopOutType == DuAEF.DuAE.LoopTypes.NONE || loopInType == DuAEF.DuAE.LoopTypes.HOLD) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.outCheckbox).setValue( 0 );
	if (loopOutType == DuAEF.DuAE.LoopTypes.CYCLE) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.outTypePopup).setValue( 1 );
	if (loopOutType == DuAEF.DuAE.LoopTypes.OFFSET) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.outTypePopup).setValue( 2 );
	if (loopOutType == DuAEF.DuAE.LoopTypes.PINPONG) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.outTypePopup).setValue( 3 );
	if (loopOutType == DuAEF.DuAE.LoopTypes.CONTINUE) ctrlEffect(DuAEF.Duik.PseudoEffects.LOOPER.outTypePopup).setValue( 4 );

	prop.getProperty().expression = '//Duik.looper\n' +
		'var fx = ' + DuAEF.DuAE.Property.getExpressionLink(ctrlEffect,true) + '\n' +
		'var isIn = fx(' + DuAEF.Duik.PseudoEffects.LOOPER.inCheckbox + ').value;\n' +
		'var isOut = fx(' + DuAEF.Duik.PseudoEffects.LOOPER.outCheckbox + ').value;\n' +
		'var inType = fx(' + DuAEF.Duik.PseudoEffects.LOOPER.inTypePopup + ').value;\n' +
		'var outType = fx(' + DuAEF.Duik.PseudoEffects.LOOPER.outTypePopup + ').value;\n' +
		'var outNumKeyframes = fx(' + DuAEF.Duik.PseudoEffects.LOOPER.outNumKeyframesSlider + ').value;\n' +
		'var inNumKeyframes = fx(' + DuAEF.Duik.PseudoEffects.LOOPER.inNumKeyframesSlider + ').value;\n' +
		'var result = value;\n' +
		'if (numKeys > 1)\n' +
		'{\n' +
		'if (time < key(1).time && isIn)\n' +
		'{\n' +
		'if (inType == 1) result = loopIn("cycle", outNumKeyframes);\n' +
		'else if (inType == 2) result = loopIn("offset", outNumKeyframes);\n' +
		'else if (inType == 3) result = loopIn("pingpong", outNumKeyframes);\n' +
		'else if (inType == 4) result = loopIn("continue");\n' +
		'}\n' +
		'else if (time > key(numKeys).time && isOut)\n' +
		'{\n' +
		'if (outType == 1) result = loopOut("cycle", outNumKeyframes);\n' +
		'else if (outType == 2) result = loopOut("offset", outNumKeyframes);\n' +
		'else if (outType == 3) result = loopOut("pingpong", outNumKeyframes);\n' +
		'else if (outType == 4) result = loopOut("continue");\n' +
		'}\n' +
		'}\n' +
		'\n' +
		'result;';

		return ctrlEffect;
}

/**
	* Create a procedural walk cycle.
	* @param {Controller[]|Layer[]} controllers - The controllers
	* @param {Controller|Layer|null} [headCtrl=null] - The head controller
	* @param {Controller|Layer|null} [neckCtrl=null] - The neck/shoulders controller
	* @param {Controller|Layer|null} [bodyCtrl=null] - The body controller
	* @param {Controller|Layer|null} [hipsCtrl=null] - The hips controller
	* @param {Controller|Layer|null} [rHandCtrl=null] - The right hand controller
	* @param {Controller|Layer|null} [lHandCtrl=null] - The left hand controller
	* @param {Controller|Layer|null} [rFootCtrl=null] - The right foot controller
	* @param {Controller|Layer|null} [lFootCtrl=null] - The left foot controller
	* @param {CompItem} [comp] - The comp where to add the walk cycle
*/
DuAEF.Duik.Automation.walk = function(headCtrl, neckCtrl, bodyCtrl, hipsCtrl, rHandCtrl, lHandCtrl, rFootCtrl, lFootCtrl, comp)
{
	if (typeof headCtrl == 'undefined') headCtrl == null;
	if (typeof neckCtrl == 'undefined') neckCtrl == null;
	if (typeof bodyCtrl == 'undefined') bodyCtrl == null;
	if (typeof hipsCtrl == 'undefined') hipsCtrl == null;
	if (typeof rHandCtrl == 'undefined') rHandCtrl == null;
	if (typeof lHandCtrl == 'undefined') lHandCtrl == null;
	if (typeof rFootCtrl == 'undefined') rFootCtrl == null;
	if (typeof lFootCtrl == 'undefined') lFootCtrl == null;

	if (headCtrl instanceof Controller) headCtrl = headCtrl.layer;
	if (neckCtrl instanceof Controller) neckCtrl = neckCtrl.layer;
	if (bodyCtrl instanceof Controller) bodyCtrl = bodyCtrl.layer;
	if (hipsCtrl instanceof Controller) hipsCtrl = hipsCtrl.layer;
	if (rHandCtrl instanceof Controller) rHandCtrl = rHandCtrl.layer;
	if (lHandCtrl instanceof Controller) lHandCtrl = lHandCtrl.layer;
	if (rFootCtrl instanceof Controller) rFootCtrl = rFootCtrl.layer;
	if (lFootCtrl instanceof Controller) lFootCtrl = lFootCtrl.layer;

	if (headCtrl != null) comp = headCtrl.containingComp;
	else if (neckCtrl != null) comp = neckCtrl.containingComp;
	else if (bodyCtrl != null) comp = bodyCtrl.containingComp;
	else if (hipsCtrl != null) comp = hipsCtrl.containingComp;
	else if (rHandCtrl != null) comp = rHandCtrl.containingComp;
	else if (lHandCtrl != null) comp = lHandCtrl.containingComp;
	else if (rFootCtrl != null) comp = rFootCtrl.containingComp;
	else if (lFootCtrl != null) comp = lFootCtrl.containingComp;

	if (!comp) comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return;

	var mainController = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.Controller.Types.WALK_CYCLE);
	var mainControllerLayer = mainController.layer;
	var mainControllerName = mainControllerLayer.name;

	//add effect
	var effect = DuAEF.DuAE.Layer.applyPreset(mainControllerLayer,DuAEF.Duik.PseudoEffects.WALK_CYCLE,DuAEF.Duik.PseudoEffectsMatchNames.WALK_CYCLE);
	var effectName = effect.name;

	//set up
	var exp1 = '//Duik.walkCycle\n' + 'thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")(';
	var exp2 = ') + value;';
	var top = 0;
	var foot = 0;
	var hips = 0;
	var right = 0;

	function updateTop(layer)
	{
		if (top == 0) top = DuAEF.DuAE.Layer.getWorldPos(layer)[1];
		else
		{
			var ctrlPos = DuAEF.DuAE.Layer.getWorldPos(layer)[1];
			if (top > ctrlPos) top = ctrlPos;
		}
	}

	//head
	if (headCtrl)
	{
		updateTop(headCtrl);
		headCtrl.transform.rotation.expression = exp1 + '60' + exp2;
	}

	//neck
	if (neckCtrl)
	{
		updateTop(neckCtrl);
		neckCtrl.transform.rotation.expression = exp1 + '61' + exp2;
		neckCtrl.transform.position.expression = exp1 + '62' + exp2;
	}

	//body
	if (bodyCtrl)
	{
		updateTop(bodyCtrl);
		bodyCtrl.transform.position.expression = exp1 + '63' + exp2;
		if (hips == 0) hips = DuAEF.DuAE.Layer.getWorldPos(bodyCtrl)[1];
	}

	//hips
	if (hipsCtrl)
	{
		updateTop(hipsCtrl);

		hipsCtrl.transform.rotation.expression = exp1 + '64' + exp2;
		hips = DuAEF.DuAE.Layer.getWorldPos(hipsCtrl)[1];
	}

	//arm
	function rigHand (layer,isRight)
	{
		updateTop(layer);
		DuAEF.Duik.Autorig.setSide(layer,isRight);
		var sideEffect = layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.SIDE);

		//look for clavicle
		var clavEffect = layer.effect(DuAEF.Duik.PseudoEffects.ONELAYER_IK.matchName);
		if (clavEffect)
		{
			//TODO IK2FK
			clavEffect(DuAEF.Duik.PseudoEffects.ONELAYER_IK.fkAngle).expression = '//Duik.walkCycle\n' +
				'var sideFx = effect("' + sideEffect.name + '")(1).value;\n' +
				'var walkFx = thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")\n' +
				'sideFx == 1 ? walkFx(66).value + value : walkFx(72).value + value';
		}
		//look for FK
		var ikEffect = layer.effect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.matchName);
		if (ikEffect)
		{
			var ik = ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox).value;
			if (ik == 1) DuAEF.Duik.Animation.switchIkFk(layer);

			ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperAngle).expression = '//Duik.walkCycle\n' +
				'var sideFx = effect("' + sideEffect.name + '")(1).value;\n' +
				'var walkFx = thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")\n' +
				'sideFx == 1 ? walkFx(67).value + value : walkFx(73).value + value';

			ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerAngle).expression = '//Duik.walkCycle\n' +
				'var sideFx = effect("' + sideEffect.name + '")(1).value;\n' +
				'var walkFx = thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")\n' +
				'sideFx == 1 ? walkFx(68).value + value : walkFx(74).value + value';

			ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalAngle).expression = '//Duik.walkCycle\n' +
				'var sideFx = effect("' + sideEffect.name + '")(1).value;\n' +
				'var walkFx = thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")\n' +
				'sideFx == 1 ? walkFx(69).value + value : walkFx(75).value + value';
		}
	}

	if (rHandCtrl) rigHand(rHandCtrl,true)
	if (lHandCtrl) rigHand(lHandCtrl,false)

	//leg
	function rigFoot (layer,isRight)
	{
		foot = DuAEF.DuAE.Layer.getWorldPos(layer)[1];

		DuAEF.Duik.Autorig.setSide(layer,isRight);
		var sideEffect = layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.SIDE);

		var ikEffect = layer.effect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.matchName);
		if (ikEffect)
		{
			var ik = ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox).value;
			if (ik == 0) DuAEF.Duik.Animation.switchIkFk(layer);
			right = ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox).value;
		}

		layer.transform.position.expression = '//Duik.walkCycle\n' +
			'var sideFx = effect("' + sideEffect.name + '")(1).value;\n' +
			'var walkFx = thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")\n' +
			'sideFx == 1 ? walkFx(78).value + value : walkFx(83).value + value';

		layer.transform.rotation.expression = '//Duik.walkCycle\n' +
			'var sideFx = effect("' + sideEffect.name + '")(1).value;\n' +
			'var walkFx = thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")\n' +
			'sideFx == 1 ? walkFx(79).value + value : walkFx(84).value + value';

		var footRollEffect = layer.effect(DuAEF.Duik.PseudoEffects.FOOT_ROLL.matchName);
		if (footRollEffect)
		{
			footRollEffect(DuAEF.Duik.PseudoEffects.FOOT_ROLL.footRollAngle).expression = '//Duik.walkCycle\n' +
				'var sideFx = effect("' + sideEffect.name + '")(1).value;\n' +
				'var walkFx = thisComp.layer("' + mainControllerName + '").effect("' + effectName + '")\n' +
				'sideFx == 1 ? walkFx(80).value + value : walkFx(85).value + value';
		}
	}

	if (rFootCtrl) rigFoot(rFootCtrl,true)
	if (lFootCtrl) rigFoot(lFootCtrl,false)

	var characterHeight = Math.abs(foot - top);
	var legHeight = Math.abs(foot - hips);
	if (characterHeight < legHeight) characterHeight = legHeight;
	if (legHeight > 0) effect(91).setValue(legHeight);
	if (characterHeight > 0) effect(92).setValue(characterHeight);
	if (right == 0) effect(27).setValue(-3.5);
}

/**
	* Randomize tools
	* @namespace
	* @memberof DuAEF.Duik.Automation
*/
DuAEF.Duik.Automation.Randomize = {};

/**
	* Randomizes the values at current time of the Properties
	* @param {PropertyBase[]|PropertyInfo[]} props - The Properties
	* @param {boolean} [fromCurrentVal] - true to offset the current value
	* @param {float} xMin - X minimum value
	* @param {float} xMax - X maximum value
	* @param {float} [yMin] - Y minimum value
	* @param {float} [yMax] - Y maximum value
	* @param {float} [zMin] - Z minimum value
	* @param {float} [zMax] - Z maximum value
	* @param {boolean} [collapseDimensions=false] - True to use the same random value (x) on all axis
*/
DuAEF.Duik.Automation.Randomize.properties = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax,collapseDimensions)
{
	if (props == undefined) throw "You must select the properties you want to randomize";
	if (props.length == 0) throw "You must select the properties you want to randomize";
	var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
	var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
	var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));
	if (typeof collapseDimensions === 'undefined') collapseDimensions = false;

	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			var xval = 0;
			var yval = 0;
			var zval = 0;
			//X
			if (x) xval = DuMath.random(xMin,xMax);
			else if (dim == 1) xval = prop.value;
			else xval = prop.value[0];
			//Y
			if (dim == 2 || dim == 3 && y) yval = DuMath.random(yMin,yMax);
			else if (dim == 3 || dim == 2) yval = 0;
			//Z
			if (dim == 3 && z) zval = DuMath.random(zMin,zMax);
			else if (dim == 3) zval = 0;
			//SET VALUE
			var val;
			if (dim == 1) val = xval;
			if (collapseDimensions)
			{
				if (dim == 2) val = [xval,xval];
				if (dim == 3) val = [xval,xval,xval];
			}
			else
			{
				if (dim == 2) val = [xval,yval];
				if (dim == 3) val = [xval,yval,zval];
			}

			if (fromCurrentVal) val = val + prop.value;
			prop.numKeys ? prop.setValueAtTime(comp.time,val) : prop.setValue(val);
		}
	}
}

/**
	* Randomizes the values of the selected keys of the Properties
	* @param {PropertyBase[]} props - The Properties
	* @param {boolean} [fromCurrentVal] - true to offset the current value
	* @param {float} xMin - X minimum value
	* @param {float} xMax - X maximum value
	* @param {float} [yMin] - Y minimum value
	* @param {float} [yMax] - Y maximum value
	* @param {float} [zMin] - Z minimum value
	* @param {float} [zMax] - Z maximum value
	* @param {boolean} [collapseDimensions=false] - True to use the same random value (x) on all axis
	*/
DuAEF.Duik.Automation.Randomize.selectedKeys = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax,collapseDimensions)
{
	if (props == undefined) throw "You must select the keyframes you want to randomize";
	if (props.length == 0) throw "You must select the keyframes you want to randomize";
	var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
	var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
	var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));
	if (typeof collapseDimensions === 'undefined') collapseDimensions = false;

	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp and dimensions
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
				var key = prop.selectedKeys[j];
				var xval = 0;
				var yval = 0;
				var zval = 0;
				//X
				if (x) xval = DuMath.random(xMin,xMax);
				else xval = 0;
				//Y
				if (dim == 2 || dim == 3 && y) yval = DuMath.random(yMin,yMax);
				else if (dim == 3 || dim == 2) yval = 0;
				//Z
				if (dim == 3 && z) zval = DuMath.random(zMin,zMax);
				else if (dim == 3) zval = 0;
				//SET VALUE
				var val;
				if (dim == 1) val = xval;
				if (collapseDimensions)
				{
					if (dim == 2) val = [xval,xval];
					if (dim == 3) val = [xval,xval,xval];
				}
				else
				{
					if (dim == 2) val = [xval,yval];
					if (dim == 3) val = [xval,yval,zval];
				}
				if (fromCurrentVal) val = val + prop.keyValue(key);
				prop.setValueAtKey(key,val);
			}
		}
	}
}

/**
* Randomizes the times of the selected keys of the Properties
* @param {PropertyBase[]} props - The Properties
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.selectedKeyTimes = function (props,fromCurrentVal,min,max)
{
	if (props == undefined) throw "You must select the keyframes you want to randomize";
	if (props.length == 0) throw "You must select the keyframes you want to randomize";
	var x = (min != undefined && max != undefined && !isNaN(min) && !isNaN(max));
	if (!x) throw "You must define a randomizing range";

	//array to list keys to be removed
	var krKeys = [];


	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		var krK = [];
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp and dimensions
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
				var key = prop.selectedKeys[j];
				var t = DuMath.random(min,max)*comp.frameDuration;
				//SET VALUE
				if (!fromCurrentVal) t -= prop.keyTime(key);
				var oldKey = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,key);
				krK.push(prop.keyTime(key));
				DuAEF.DuAE.Property.setKey(prop,oldKey,t);
			}
		}
		krKeys.push(krK);
	}

	for (var i = 0 ; i < props.length ; i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		for (var j = 0 ; j < krKeys[i].length ; j++)
		{
			prop.removeKey(prop.nearestKeyIndex(krKeys[i][j]));
		}
	}
}

/**
* Randomizes the start times of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.startTimes = function (layers,fromCurrentVal,min,max)
{
		if (layers == undefined) return;
		if (layers.length == 0 ) return;

		var it = new DuList(layers);

		while (!it.atEnd)
		{
			it.next();
			var l = layers[it.current];
			var comp = l.containingComp;
			var startTime = DuMath.random(min,max)*comp.frameDuration;
			if (fromCurrentVal) l.startTime = l.startTime + startTime;
			else l.startTime = startTime;
		}
	}

/**
* Randomizes the in points of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.inPoints = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = new DuList(layers);

	while (!it.atEnd)
	{
		it.next();
		var l = layers[it.current];
		var comp = l.containingComp;
		var inPoint = DuMath.random(min,max)*comp.frameDuration;
		if (fromCurrentVal) l.inPoint = l.inPoint + inPoint;
		else l.inPoint = inPoint;
	}
}

/**
* Randomizes the out points of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.outPoints = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = new DuList(layers);

	for (var i = it.min; i<= it.max;i++)
	{
		it.next();
		var l = layers[it.current];
		var comp = l.containingComp;
		var outPoint = DuMath.random(min,max)*comp.frameDuration;
		if (fromCurrentVal) l.outPoint = l.outPoint + outPoint;
		else l.outPoint = outPoint;
	}
}

/**
* Randomizes the indices of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum index
* @param {float} max - maximum index
*/
DuAEF.Duik.Automation.Randomize.indices = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = new DuList(layers);

	while (!it.atEnd)
	{
		it.next();
		var l = layers[it.current];
		var index = parseInt(DuMath.random(min,max));
		if (fromCurrentVal) index = l.index + index;
		if (index == l.index) continue;
		var comp = l.containingComp;
		if (index >= comp.numLayers) l.moveToEnd();
		else if (index < 2) l.moveToBeginning();
		else l.moveBefore(comp.layer(index));
	}
}
